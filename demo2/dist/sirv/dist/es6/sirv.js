if (!window.Sirv) {
  (function () {
    // eslint-disable-next-line wrap-iife
    (function () {
      var modules = {};

      var sirvRequire = function (deps, cb) {
        // if (!deps) {
        //     deps = [];
        // }
        if (!Array.isArray(deps)) {
          deps = [deps];
        }

        const args = [];
        deps.forEach(dep => {
          if (modules[dep]) {
            if (!modules[dep].result) {
              modules[dep].result = sirvRequire(modules[dep].deps, modules[dep].cb);
            }

            args.push(modules[dep].result);
          } else {
            args.push(null);
          }
        });
        return typeof cb === 'function' ? cb.apply(this, args) : cb;
      };

      var sirvDefine = function (name, deps, cb) {
        if (!cb) {
          cb = deps;
          deps = null;
        }

        modules[name] = {
          deps: deps,
          cb: cb,
          result: null
        };
      };

      window.Sirv = {
        require: sirvRequire,
        define: sirvDefine
      };
    })();

    Sirv.define('magicJS', ['bHelpers'], bHelpers => {
      let magicJS;
      let $J;

      magicJS = $J = function () {
        let WIN = window;
        let UND = WIN.undefined;
        let DOC = document;
        /* eslint-env es6 */

        /* global UND, WIN, DOC, Doc */

        /* eslint-disable no-use-before-define */

        /* eslint no-return-assign: "error" */

        /* eslint no-extra-boolean-cast: "off" */

        /* eslint no-continue: "off" */

        /* eslint no-restricted-syntax: ["error", "WithStatement", "BinaryExpression[operator='in']"] */

        /* eslint-disable dot-notation */

        /* eslint-disable eqeqeq */

        const STORAGE = new WeakMap();
        /*
         * Script: base.js
         * Contains core methods.
         */

        /**
         * Contains core methods.
         * @class
         * @static
         */

        const magicJS =
        /** @lends magicJS# */
        {
          /**
           * Start UUID for objects
           */
          UUID: 0,

          /**
           * Storage for object properties
           */
          storage: {},

          /**
           * Assign unique id for an object
           */
          $uuid: o => {
            return o.$J_UUID || (o.$J_UUID = ++$J.UUID);
          },

          /**
           * Retreive storage of an object by uuid
           */
          getStorage: uuid => {
            return $J.storage[uuid] || ($J.storage[uuid] = {});
          },

          /**
           * Empty function that returns false
           */
          $false: () => {
            return false;
          },

          /**
           * Empty function that returns true
           */
          $true: () => {
            return true;
          },

          /**
           * Id of the magicJS <style></style>
           */
          stylesId: 'mjs-' + Math.floor(Math.random() * new Date().getTime()),

          /**
           * Check if the object defined
           *
           * @param {Object}   object to check
           *
           * @returns {bool}  - true or false
           */
          defined: o => {
            return o != UND;
          },

          /**
           * Get type of the object
           *
           * @param {Object}  object to check
           *
           * @returns {String}    - object type
           */
          typeOf: o => {
            if (!$J.defined(o)) {
              return false;
            }

            if (o.$J_TYPE) {
              return o.$J_TYPE;
            }

            if (!!o.nodeType) {
              if (o.nodeType === 1) {
                return 'element';
              }

              if (o.nodeType === 3) {
                return 'textnode';
              }
            }

            if (o === WIN) {
              return 'window';
            }

            if (o === DOC) {
              return 'document';
            } // if ((o instanceof WIN.Object || o instanceof WIN.Function) && o.constructor === $J.Class) {
            //     return 'class';
            // }


            if (o instanceof WIN.Array) {
              return 'array';
            }

            if (o instanceof WIN.Function) {
              return 'function';
            }

            if (o instanceof WIN.String) {
              return 'string';
            }

            if ($J.browser.trident) {
              if ($J.defined(o.cancelBubble)) {
                return 'event';
              }
            } else {
              //if ( o instanceof WIN.Event || o === WIN.event || o.constructor == WIN.MouseEvent ) { return 'event'; }
              // eslint-disable-next-line
              if (o === WIN.event || o.constructor == WIN.Event || o.constructor == WIN.MouseEvent || o.constructor == WIN.UIEvent || o.constructor == WIN.KeyboardEvent || o.constructor == WIN.KeyEvent) {
                return 'event';
              }
            }

            if (o instanceof WIN.Date) {
              return 'date';
            }

            if (o instanceof WIN.RegExp) {
              return 'regexp';
            }

            if (o.length && o.item) {
              return 'collection';
            }

            if (o.length && o.callee) {
              return 'arguments';
            }

            return typeof o;
          },
          detach: o => {
            let r;

            switch ($J.typeOf(o)) {
              case 'object':
                r = {};

                for (const p in o) {
                  if (Object.prototype.hasOwnProperty.call(o, p)) {
                    r[p] = $J.detach(o[p]);
                  }
                }

                break;

              case 'array':
                r = [];

                for (let i = 0, l = o.length; i < l; i++) r[i] = $J.detach(o[i]);

                break;

              default:
                return o;
            }

            return $J.$(r);
          },
          $: o => {
            let result = o;

            switch ($J.typeOf(o)) {
              case 'string':
                {
                  const el = DOC.getElementById(o);

                  if ($J.defined(el)) {
                    result = $J.$(el);
                  } else {
                    result = null;
                  }

                  break;
                }

              case 'window':
              case 'document':
                if (STORAGE.has(o)) {
                  result = STORAGE.get(o);
                } else {
                  result = new Doc(o);
                }

                break;

              case 'element':
                if (STORAGE.has(o)) {
                  result = STORAGE.get(o);
                } else {
                  result = new Element(o);
                }

                break;

              case 'event':
                result = new $J.Events.MagicEvent(o);
                break;
              // no default
            }

            return result;
          },

          /**
           * Creates new dom element
           *
           * @param   {String}
           *
           * @returns
           */
          $new: (tag, props, css) => {
            return $J.$(DOC.createElement(tag)).setProps(props || {}).setCss(css || {});
          },

          /**
           * Adds new CSS style definition to the document
           *
           * @param {String} selector CSS selector
           * @param {String|Object} css CSS rules
           * @param {String} [id] Identifier of the style sheet. Optional.
           * @param {dom object} [root] Context of searching element by id
           *
           * @return {Number} position of the added CSS within the style sheet
           */
          addCSS: (selector, css, id, root) => {
            let rootNode = DOC.head || DOC.body;

            if (root) {
              rootNode = $(root).node || root;
            }

            if (!id) {
              id = $J.stylesId;
            }

            let style = $(rootNode.querySelector('#' + id));

            if (!style) {
              style = $J.$new('style').attr('id', id).attr('type', 'text/css');
              rootNode.insertBefore(style.node, rootNode.firstChild);
            }

            let sheet = style.node.sheet;

            if (!sheet) {
              sheet = style.node.styleSheet;
            }

            if ($J.typeOf(css) !== 'string') {
              css = Object.entries(css).map(values => values[0] + ':' + values[1]).join(';');
            }

            let idx = -1;

            if (sheet.insertRule) {
              idx = sheet.insertRule(selector + ' {' + css + '}', sheet.cssRules.length);
            } else {
              idx = sheet.addRule(selector, css);
            }

            return idx;
          },

          /**
           * Remove CSS rule by index from a particular stylesheet
           *
           * @param {String} id Identifier of the style sheet
           * @param {Number} index Position of the CSS to be removed within the style sheet
           */
          removeCSS: (id, index) => {
            if ($J.typeOf(style) !== 'element') {
              return;
            }

            const style = $J.$(id);
            const sheet = style.sheet || style.styleSheet;

            if (sheet.deleteRule) {
              sheet.deleteRule(index);
            } else if (sheet.removeRule) {
              sheet.removeRule(index);
            }
          },

          /**
           * Create UUID
           * @return {String}
           */
          generateUUID: () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
              const r = Math.random() * 16 | 0;
              const v = c === 'x' ? r : r & 0x3 | 0x8;
              return v.toString(16);
            }).toUpperCase();
          },

          /**
           * Retrieve absolute URL of a given link
           * @param {String} url link
           * @return {String}
           */
          getAbsoluteURL: (() => {
            let a;
            return url => {
              if (!a) a = DOC.createElement('a');
              a.setAttribute('href', url);
              return ('!!' + a.href).replace('!!', '');
            };
          })(),

          /**
           * String hash function similar to java.lang.String.hashCode().
           *
           * @param {String} s A string.
           * @return {Number} Hash value for {@code s}, between 0 (inclusive) and 2^32
           *  (exclusive). The empty string returns 0.
           */
          getHashCode: s => {
            let r = 0;
            const l = s.length;

            for (let i = 0; i < l; ++i) {
              r = 31 * r + s.charCodeAt(i);
              r %= 0x100000000;
            }

            return r;
          },

          /**
           * Return camel-case string
           *
           * @param {String}
           *
           * @returns {String}    - string in camel-case
           */
          camelize: str => {
            return str.replace(/-\D/g, m => {
              return m.charAt(1).toUpperCase();
            });
          },

          /**
           * Return hyphenated string
           *
           * @param {String}
           *
           * @returns {String} - hyphenated string
           */
          dashize: function (str) {
            return str.replace(/[A-Z]/g, m => {
              return '-' + m.charAt(0).toLowerCase();
            });
          },

          /**
           * Check if string contains substring
           *
           * @param {string}      - source
           * @param {string}      - needle to find
           * @param {string}      - Optional. Separator
           *
           * @returns {bool}      - True if the needle found, False otherwise
           */
          stringHas: (source, str, sep) => {
            sep = sep || '';
            return (sep + source + sep).indexOf(sep + str + sep) > -1;
          }
        };
        const $J = magicJS;
        const $j = magicJS.$; //eslint-disable-line no-unused-vars

        const $ = $J.$;
        /* eslint-env es6 */

        /* global $J, WIN, DOC, UND, DocumentTouch */

        /* eslint-disable dot-notation */

        /* eslint new-parens: "off" */

        /* eslint no-extra-boolean-cast: "off" */

        /* eslint no-unused-vars: ["error", { "args": "none" }] */

        /**
          *     Browser engines
          *         Gecko:
          *             1.81 - Firefox 2
          *             1.90 - Firefox 3
          *             1.91 - Firefox 3.5
          *             1.92 - Firefox 3.6
          *             2.0  - Firefox 4.0
          *             5    - Firefox 5.0
          *             ...
          *             25    - Firefox 25
          *
          *         Trident:
          *             7 - IE 11
          */
        // Normalized event names

        const EVENTS_MAP = {}; // Shortcut for userAgent

        const _UA = navigator.userAgent.toLowerCase();

        const _engine = _UA.match(/(webkit|gecko|trident)\/(\d+\.?\d*)/i);

        const _version = _UA.match(/(edge|opr)\/(\d+\.?\d*)/i) || _UA.match(/(crios|chrome|safari|firefox|opera|opr)\/(\d+\.?\d*)/i);

        const _safariVer = _UA.match(/version\/(\d+\.?\d*)/i);

        class Browser {
          constructor() {
            this._magicClasses = []; // Extra CSS classes applied to <html> (e.g. lt-ie9-magic, mobile-magic)

            this._features = {
              fullScreen: !!(DOC.fullscreenEnabled || DOC.msFullscreenEnabled || DOC.webkitFullScreenEnabled || DOC.webkitFullscreenEnabled),
              cssFilters: false // ie11 does not support

            };

            this._touchScreen = (() => {
              return 'ontouchstart' in WIN || WIN.DocumentTouch && DOC instanceof DocumentTouch || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
            })();

            this._mobile = !!_UA.match(/(android|bb\d+|meego).+|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/);

            this._engine = (() => {
              let result = 'unknown';

              if (_engine && _engine[1]) {
                result = _engine[1].toLowerCase();
              } else if (!!WIN.ActiveXObject) {
                result = 'trident';
              } else if (DOC.getBoxObjectFor !== UND || WIN.mozInnerScreenY !== null) {
                result = 'gecko';
              } else if (WIN.WebKitPoint !== null || !navigator.taintEnabled) {
                result = 'webkit';
              }

              return result;
            })();

            this._chrome = false;
            this._webkit = this._engine === 'webkit';
            this._gecko = this._engine === 'gecko';
            this._trident = this._engine === 'trident';
            this._androidBrowser = false;
            this._version = _engine && _engine[2] ? parseFloat(_engine[2]) : 0;
            this._uaName = _version && _version[1] ? _version[1].toLowerCase() : '';
            this._uaVersion = _version && _version[2] ? parseFloat(_version[2]) : 0;
            this._cssPrefix = '';
            this._cssDomPrefix = '';
            this._domPrefix = '';
            this._ieMode = 0;

            this._platform = (() => {
              let result;

              if (_UA.match(/ip(?:ad|od|hone)/)) {
                result = 'ios';
              } else {
                result = _UA.match(/(?:webos|android)/);

                if (!result) {
                  result = navigator.platform.match(/mac|win|linux/i);

                  if (!result) {
                    result = ['other'];
                  }
                }

                result = result[0].toLowerCase();
              }

              return result;
            })();

            this._backCompat = DOC.compatMode && DOC.compatMode.toLowerCase() === 'backcompat';
            this._scrollbarsWidth = 0;
            this._ready = false;
            this.calculate();
          }

          calculate() {
            switch (this._engine) {
              case 'trident':
                if (!this._version) {
                  this._version = !!WIN.XMLHttpRequest ? 3 : 2;
                }

                break;

              case 'gecko':
                this._version = _version && _version[2] ? parseFloat(_version[2]) : 0;
                break;
              // no default
            }

            if (_version && _version[1] === 'crios') {
              this._uaName = 'chrome';
            }

            if (!!WIN.chrome) {
              this._chrome = true;
            }

            if (this._uaName === 'safari' && _safariVer && _safariVer[1]) {
              this._uaVersion = parseFloat(_safariVer[1]);
            }

            if (this._platform === 'android' && this._webkit && _safariVer && _safariVer[1]) {
              this._androidBrowser = true;
            } // browser prefixes


            const prefixes = {
              gecko: ['-moz-', 'Moz', 'moz'],
              webkit: ['-webkit-', 'Webkit', 'webkit'],
              trident: ['-ms-', 'ms', 'ms']
            }[this._engine] || ['', '', ''];
            this._cssPrefix = prefixes[0];
            this._cssDomPrefix = prefixes[1];
            this._domPrefix = prefixes[2]; // for ie 11

            this._ieMode = (() => {
              if (this._trident && DOC.documentMode) {
                return DOC.documentMode;
              }

              return UND;
            })(); // Mobile Safari engine in the “request desktop site” mode on iOS/iPadOS.
            // Since iPadOS 13, Safari's “request desktop site” setting is turned on by default for all websites


            if (!this._mobile && this._platform === 'mac' && this._touchScreen) {
              this._mobile = true;
              this._platform = 'ios';
            }

            this._magicClasses.push(this._platform + '-magic');

            if (this._mobile) {
              this._magicClasses.push('mobile-magic');
            }

            if (this._androidBrowser) {
              this._magicClasses.push('android-browser-magic');
            }

            if (this._ieMode) {
              // Add CSS class of the IE version to <html> for possible tricks
              this._uaName = 'ie';
              this._uaVersion = this._ieMode;

              this._magicClasses.push('ie' + this._ieMode + '-magic'); // for (let i = 11; i > this._ieMode; i--) {
              //     this._magicClasses.push('lt-ie' + i + '-magic');
              // }

            } // if (this._webkit && this._version < 536) { // Disable fullscreen in old Safari
            //     this._features.fullScreen = false;
            // }


            this._magicClasses.push('svg-magic');

            const exClasses = (DOC.documentElement.className || '').match(/\S+/g) || [];
            DOC.documentElement.className = exClasses.concat(this._magicClasses).join(' ');

            try {
              DOC.documentElement.setAttribute('data-magic-ua', $J.browser.uaName);
              DOC.documentElement.setAttribute('data-magic-ua-ver', $J.browser.uaVersion);
              DOC.documentElement.setAttribute('data-magic-engine', $J.browser.engine);
              DOC.documentElement.setAttribute('data-magic-engine-ver', $J.browser.version); // DOC.documentElement.setAttribute('data-magic-features', magicClasses.join(' '));
            } catch (ex) {// empty
            } // Map pointer events for IE 10.


            if (!WIN.navigator.pointerEnabled) {
              ['Down', 'Up', 'Move', 'Over', 'Out'].forEach(type => {
                // EVENTS_MAP['pointer' + type.toLowerCase()] = WIN.navigator.msPointerEnabled ? 'MSPointer' + type : -1;
                const evt = 'pointer' + type.toLowerCase();

                if (this._uaName === 'edge') {
                  EVENTS_MAP[evt] = evt;
                } else if (WIN.navigator.msPointerEnabled) {
                  EVENTS_MAP[evt] = 'MSPointer' + type;
                } else {
                  EVENTS_MAP[evt] = -1;
                }
              });
            }
          }
          /**
           * Browser supported features
           */


          get features() {
            return this._features;
          }
          /**
           * Touch screen support
           */


          get touchScreen() {
            return this._touchScreen;
          }
          /**
           * Mobile device?
           */


          get mobile() {
            return this._mobile;
          }
          /**
           * Browser engine
           */


          get engine() {
            return this._engine;
          }
          /**
           * Browser engine version
           */


          get version() {
            return this._version;
          }
          /**
           * Browser name & version
           */


          get uaName() {
            return this._uaName;
          }

          get uaVersion() {
            return this._uaVersion;
          } // prefix for css properties like -webkit-box-shadow


          get cssPrefix() {
            return this._cssPrefix;
          } // prefix for style properties like element.style.WebkitBoxShadow


          get cssDomPrefix() {
            return this._cssDomPrefix;
          } // DOM prefix


          get domPrefix() {
            return this._domPrefix;
          }
          /**
           * IE document mode
           */


          get ieMode() {
            return this._ieMode;
          }
          /**
           * Platform
           *
           * mac      - Mac OS
           * win      - Windows
           * linux    - Linux
           * ios      - Apple iPod/iPhone/iPad
           *
           */


          get platform() {
            return this._platform;
          }
          /**
           * Browser box model
           *
           * Basically used to determine how IE renders in quirks mode
           */


          get backCompat() {
            return this._backCompat;
          }
          /**
           * Width of the browser's scrollbars
           */


          get scrollbarsWidth() {
            return this._scrollbarsWidth;
          }
          /**
           * Reference to the real document element
           *
           * Used to correct work with page dimension
           */
          // eslint-disable-next-line class-methods-use-this


          get doc() {
            return DOC.compatMode && DOC.compatMode.toLowerCase() === 'backcompat' ? DOC.body : DOC.documentElement;
          }
          /**
           * Indicates that DOM content is ready for manipulation
           *
           * @see domready
           */


          get ready() {
            return this._ready;
          }

          get chrome() {
            return this._chrome;
          }

          get webkit() {
            return this._webkit;
          }

          get gecko() {
            return this._gecko;
          }

          get trident() {
            return this._trident;
          }

          get androidBrowser() {
            return this._androidBrowser;
          }
          /**
           * Fires when DOM content is ready for manipulation
           *
           * @see domready
           */


          onready() {
            if (this._ready) {
              return;
            }

            this._ready = true;

            try {
              // Calculate width of browser's scrollbars
              const tmp = $J.$new('div').setCss({
                width: 100,
                height: 100,
                overflow: 'scroll',
                position: 'absolute',
                top: -9999
              }).appendTo(DOC.body);
              this._scrollbarsWidth = tmp.node.offsetWidth - tmp.node.clientWidth;
              tmp.remove();
            } catch (ex) {// empty
            }

            try {
              // Test CSS filters support
              const node = $J.$new('div');
              node.node.style.cssText = $J.dashize('filter') + ':blur(2px);';
              this._features.cssFilters = !!node.node.style.length;
            } catch (ex) {// empty
            }

            if (!this._features.cssFilters) {
              $J.$(DOC.documentElement).addClass('no-cssfilters-magic');
            } // if (WIN.TransitionEvent === UND && WIN.WebKitTransitionEvent !== UND) {
            //     EVENTS_MAP['transitionend'] = 'webkitTransitionEnd';
            // }


            $J.$(DOC).callEvent('domready');
          }

        }

        $J.browser = new Browser();

        (() => {
          const getCancel = () => {
            let result = DOC.exitFullscreen || DOC.cancelFullScreen || DOC[$J.browser.domPrefix + 'ExitFullscreen'] || DOC[$J.browser.domPrefix + 'CancelFullScreen'];

            if (!result) {
              result = () => {};
            }

            return result;
          };

          const getChangeEventName = () => {
            let result;

            if (DOC.msExitFullscreen) {
              result = 'MSFullscreenChange';
            } else {
              if (DOC.exitFullscreen) {
                result = '';
              } else {
                result = $J.browser.domPrefix;
              }

              result += 'fullscreenchange';
            }

            return result;
          };

          const getErrorEventName = () => {
            let result;

            if (DOC.msExitFullscreen) {
              result = 'MSFullscreenError';
            } else {
              if (DOC.exitFullscreen) {
                result = '';
              } else {
                result = $J.browser.domPrefix;
              }

              result += 'fullscreenerror';
            }

            return result;
          };

          const callRequestFullscreen = el => {
            let f = el.requestFullscreen || el[$J.browser.domPrefix + 'RequestFullscreen'] || el[$J.browser.domPrefix + 'RequestFullScreen'];

            if (!f) {
              f = () => {};
            }

            f.call(el);
          };

          const fullScreen = {
            capable: $J.browser.features.fullScreen,
            enabled: () => {
              return !!(DOC.fullscreenElement || DOC[$J.browser.domPrefix + 'FullscreenElement'] || DOC.fullScreen || DOC.webkitIsFullScreen || DOC[$J.browser.domPrefix + 'FullScreen']);
            },
            request: (el, opts) => {
              if (!opts) {
                opts = {};
              }

              if (fullScreen.capable && !opts.windowFullscreen) {
                fullScreen.onchange = e => {
                  // onfullscreenchange event
                  if (fullScreen.enabled()) {
                    // we entered full-screen mode
                    if (opts.onEnter) {
                      opts.onEnter();
                    }
                  } else {
                    // left fullscreen mode
                    $J.$(DOC).removeEvent(fullScreen.changeEventName, fullScreen.onchange);

                    if (opts.onExit) {
                      opts.onExit();
                    }
                  }
                };

                $J.$(DOC).addEvent(fullScreen.changeEventName, fullScreen.onchange);

                fullScreen.onerror = e => {
                  // onfullscreenchange event
                  if (opts.fallback) {
                    opts.fallback();
                  }

                  $J.$(DOC).removeEvent(fullScreen.errorEventName, fullScreen.onerror);
                }; // if native fullscreen failed, enter pseudo mode


                $J.$(DOC).addEvent(fullScreen.errorEventName, fullScreen.onerror);
                callRequestFullscreen($(el).node);
              } else if (opts.fallback) {
                opts.fallback();
              }
            },
            cancel: getCancel(),
            changeEventName: getChangeEventName(),
            errorEventName: getErrorEventName(),
            prefix: $J.browser.domPrefix,
            activeElement: null
          };
          $J.browser.fullScreen = fullScreen;
        })();
        /* eslint-env es6 */

        /* global WIN, DOC, UND, STORAGE, EVENTS_MAP */

        /* eslint-disable quote-props */

        /* eslint no-restricted-syntax: ["error", "WithStatement"] */

        /* eslint-disable camelcase */
        // Not whitespace regexp
        // const r_nwp = /\S+/g;


        const r_cssToNum = /^(border(Top|Bottom|Left|Right)Width)|((padding|margin)(Top|Bottom|Left|Right))$/; // normalize CSS names

        const cssMap = {}; // Unitless CSS properties (w/o 'px')

        const nopxCSS = {
          'fontWeight': true,
          'lineHeight': true,
          'opacity': true,
          'zIndex': true,
          'zoom': true
        };

        const getCssValue = (e, name) => {
          const css = WIN.getComputedStyle(e, null);
          return css ? css.getPropertyValue(name) || css[name] : null;
        }; // Returns normalize CSS name (probably with a vendor prefix)


        const normalizeCSS = name => {
          const standard = (name in DOC.documentElement.style); // if ( !(name in DOC.documentElement.style) ) {

          if (!standard) {
            const pName = $J.browser.cssDomPrefix + name.charAt(0).toUpperCase() + name.slice(1);

            if (pName in DOC.documentElement.style) {
              return pName;
            }
          }

          return name;
        };

        $J.normalizeCSS = normalizeCSS;

        class Base {
          constructor(node) {
            this.node = node;
            this.$J_UUID = ++$J.UUID;
            this.$J_TYPE = null;

            this.$J_EXT = () => {};

            STORAGE.set(this.node, this);
          }
          /**
           * Retreive object's property from the global storage
           *
           * @param  {string}    - property name
           * @param  {mixed}     - default value
           *
           * @returns {mixed}     - property value
           */


          fetch(prop, def) {
            const s = $J.getStorage(this.$J_UUID);
            let p = s[prop];
            let result = null;

            if (def !== UND && p === UND) {
              s[prop] = def;
              p = s[prop];
            }

            if ($J.defined(p)) {
              result = p;
            }

            return result;
          }
          /**
           * Store object's property in the global storage
           *
           * @param  {string}    - property name
           * @param  {mixed}     - value
           *
           * @returns {element}   - HTML element
           */


          store(prop, val) {
            const s = $J.getStorage(this.$J_UUID);
            s[prop] = val;
            return this;
          }
          /**
           * Delete object's property from the global storage
           *
           * @param  {string}    - property name
           *
           * @returns {element}   - HTML element
           */


          del(prop) {
            const s = $J.getStorage(this.$J_UUID);
            delete s[prop];
            return this;
          }
          /**
           * Add event listener
           *
           * @param  type  {Mixed}     event type
           * @param  fn  {Function}    listener
           * @param  [priority=10] {Integer} order in which the listener will be called
           */


          addEvent(type, fn, priority, options) {
            if ($J.typeOf(type) === 'array') {
              type.forEach(__type => {
                // this.addEvent.call(this, __type, fn, priority, options);
                this.addEvent(__type, fn, priority, options);
              });
              return this;
            } // Normalize event name


            type = EVENTS_MAP[type] || type;

            if (!type || !fn || $J.typeOf(type) !== 'string' || $J.typeOf(fn) !== 'function') {
              return this;
            }

            if (type === 'domready' && $J.browser.ready) {
              // fn.call(this);
              fn();
              return this;
            }

            priority = parseInt(priority || 50, 10);

            if (!fn.$J_EUID) {
              fn.$J_EUID = Math.floor(Math.random() * +new Date());
            } // const events = $J.Doc.fetch.call(this, '_EVENTS_', {});


            const events = this.fetch('_EVENTS_', {});
            let handlers = events[type];

            if (!handlers) {
              // Initialize event handlers queue
              handlers = [];
              events[type] = handlers;

              if ($J.Events.handlers[type]) {
                $J.Events.handlers[type].add.call(this, options); // $J.Events.handlers[type].add(this, options);
              } else {
                // handlers['handle'] = function (e) {
                handlers['handle'] = e => {
                  e = Object.assign(e || WIN.e, {
                    $J_TYPE: 'event'
                  }); // $J.Doc.callEvent.call(_self, type, $J.$(e));

                  this.callEvent(type, $J.$(e));
                };

                this.node[$J._event_add_]($J._event_prefix_ + type, handlers['handle'], false);
              }
            }

            const fnObj = {
              type: type,
              fn: fn,
              priority: priority,
              euid: fn.$J_EUID
            };
            handlers.push(fnObj);
            handlers.sort((a, b) => {
              return a.priority - b.priority;
            });
            return this;
          } // removeEvent(type/*, fn */) {


          removeEvent(...args) {
            // const events = $J.Doc.fetch.call(this, '_EVENTS_', {});
            const events = this.fetch('_EVENTS_', {}); // let del;

            let type = args[0]; // const fn = arguments.length > 1 ? arguments[1] : -100;

            const fn = args.length > 1 ? args[1] : -100;

            if ($J.typeOf(type) === 'array') {
              // $J.$(type).each(this.removeEvent.bindAsEvent(this, fn));
              type.forEach(__type => {
                this.removeEvent(__type, fn);
              });
              return this;
            } // Normalize event name


            type = EVENTS_MAP[type] || type;

            if (!type || $J.typeOf(type) !== 'string' || !events || !events[type]) {
              return this;
            }

            const handlers = events[type] || [];

            for (let k = 0; k < handlers.length; k++) {
              const fnObj = handlers[k];

              if (fn === -100 || !!fn && fn.$J_EUID === fnObj.euid) {
                // del = handlers.splice(k--, 1);
                handlers.splice(k--, 1);
              }
            }

            if (handlers.length === 0) {
              if ($J.Events.handlers[type]) {
                $J.Events.handlers[type].remove.call(this);
              } else {
                this.node[$J._event_del_]($J._event_prefix_ + type, handlers['handle'], false);
              }

              delete events[type];
            }

            return this;
          }

          callEvent(type, e) {
            const events = this.fetch('_EVENTS_', {}); // Normalize event name

            type = EVENTS_MAP[type] || type;

            if (!type || $J.typeOf(type) !== 'string' || !events || !events[type]) {// return this;
            } else {
              try {
                if (!e || !e.type) {
                  e = Object.assign(e || {}, {
                    type: type
                  });
                }
              } catch (ev) {// empty
              }

              if (e.timeStamp === UND) {
                e.timeStamp = +new Date();
              }

              const handlers = events[type] || [];

              for (let k = 0; k < handlers.length && !(e.isQueueStopped && e.isQueueStopped()); k++) {
                handlers[k].fn.call(this, e);
              }
            }
          }

          raiseEvent(type, name) {
            const _native = type !== 'domready';

            let o = this; // Normalize event name

            type = EVENTS_MAP[type] || type;

            if (!_native) {
              this.callEvent(type);
              return this;
            }

            if (o === DOC && DOC.createEvent && !o.dispatchEvent) {
              o = DOC.documentElement;
            }

            let e;

            if (DOC.createEvent) {
              e = DOC.createEvent(type);
              e.initEvent(name, true, true);
            } else {
              e = DOC.createEventObject();
              e.eventType = type;
            }

            if (DOC.createEvent) {
              o.dispatchEvent(e);
            } else {
              o.fireEvent('on' + name, e);
            }

            return e;
          }

          clearEvents() {
            const events = this.fetch('_EVENTS_');

            if (!events) {
              return this;
            }

            Object.keys(events).forEach(_type => {
              this.removeEvent(_type);
            });
            this.del('_EVENTS_');
            return this;
          }

        } // eslint-disable-next-line no-unused-vars


        class Element extends Base {
          constructor(node) {
            super(node);
            this.$J_TYPE = 'magicjs-element';
          } // Full screen


          requestFullScreen() {
            if ($J.browser.fullScreen.capable && !DOC.requestFullScreen) {
              $J.browser.fullScreen.request(this.node);
            } else {
              this.node.requestFullScreen(this.node);
            }
          }
          /**
           * Adds class(es) to element
           *
           * @param {String}   val   One or more space-separated classes to be added
           *
           * @returns {Element}    Reference to the element itself
           */


          addClass(...args) {
            args.forEach(className => {
              this.node.classList.add(className);
            });
            return this;
          }
          /**
           * Removes class(es) from element.
           *
           * @param {String}  [val] One or more space-separated classes to be removed. If omitted, remove all classes.
           *
           * @returns {Element}    Reference to the element itself
           */


          removeClass(val) {
            this.node.classList.remove(val);
            return this;
          }
          /**
           * Toogles a class on element
           *
           * @param {String}   val  A class name to be toggled
           *
           * @returns {Element}    Reference to the element itself
           */
          // toggleClass(val) {
          //     this.node.classList.toggle(val);
          //     return this;
          // }

          /**
           * Retrieves element's css style
           *
           * @param {String}   property CSS property to retrieve
           *
           * @returns {Mixed}     Value of CSS property
           */


          getCss(p) {
            const cssName = $J.camelize(p);

            if (!cssMap[cssName]) {
              cssMap[cssName] = normalizeCSS(cssName);
            }

            p = cssMap[cssName];
            let v = getCssValue(this.node, p);

            if (v === 'auto') {
              v = null;
            }

            if (v !== null) {
              if (p === 'opacity') return $J.defined(v) ? parseFloat(v) : 1.0;

              if (r_cssToNum.test(p)) {
                v = parseInt(v, 10) ? v : '0px';
              }
            }

            return v;
          }
          /**
           * Applies a single CSS style to element
           *
           * @param {String}      key        CSS property name
           * @param {Mixed}      value    Value to be set up
           *
           * @returns {Element}   Reference to the element itself
           */


          setCssProp(k, v) {
            const cssName = $J.camelize(k);

            try {
              if (!cssMap[cssName]) {
                cssMap[cssName] = normalizeCSS(cssName);
              }

              k = cssMap[cssName];
              this.node.style[k] = v + ($J.typeOf(v) === 'number' && !nopxCSS[cssName] ? 'px' : '');
            } catch (e) {// empty
            }

            return this;
          }
          /**
           * Applies css styles to element
           *
           * @param {Hash}    styles  Set of the CSS styles to apply
           *
           * @returns {Element}    Reference to the element itself
           */


          setCss(styles) {
            Object.entries(styles).forEach(values => {
              this.setCssProp(...values);
            });
            return this;
          }
          /**
           * Retrieves set of element's css style
           *
           * @param {String[]}   styles   CSS styles to retrieve
           *
           * @returns {Hash}      Set of CSS styles
           */
          // getStyles(...args) {
          //     const r = {};
          //     args.forEach((k) => {
          //         r[k] = this.getCss(k);
          //     });
          //     return r;
          // }


          getStyles(...args) {
            return Object.fromEntries(args.map(value => [value, this.getCss(value)]));
          }
          /**
           * Applies properties to element
           *
           * @param {Hash}    properties  Set of properties to apply
           *
           * @returns {Element}    Reference to the element itself
           */


          setProps(props) {
            Object.entries(props).forEach(values => {
              values[1] = '' + values[1];

              if (values[0] === 'class') {
                this.addClass(values[1]);
              } else {
                this.node.setAttribute(...values);
              }
            });
            return this;
          } // getTransitionDuration() {
          //     let duration = 0;
          //     let delay = 0;
          //     duration = this.getCss('transition-duration');
          //     delay = this.getCss('transition-delay');
          //     if (duration.indexOf('ms') > -1) {
          //         duration = parseFloat(duration);
          //     } else if (duration.indexOf('s') > -1) {
          //         duration = parseFloat(duration) * 1000;
          //     }
          //     if (delay.indexOf('ms') > -1) {
          //         delay = parseFloat(delay);
          //     } else if (delay.indexOf('s') > -1) {
          //         delay = parseFloat(delay) * 1000;
          //     }
          //     return duration + delay;
          // }

          /**
           * Gets size of element
           *
           * @returns {Hash} Size of the element  {width: x, height: x}
           */


          get size() {
            return {
              width: this.node.offsetWidth,
              height: this.node.offsetHeight
            };
          }
          /**
           * Gets size of element for view rendering
           *
           * @returns {Hash} Size of the element  {width: x, height: x}
           */


          render() {
            return this.size;
          }
          /**
           * Gets inner size of element
           *
           * @param  [withPadding=false] {Boolean} include padding in returning size
           *
           * @returns {Hash} Size of the element  {width: x, height: x}
           */


          getInnerSize(withPadding) {
            const size = this.size;
            size.width -= parseFloat(this.getCss('border-left-width') || 0) + parseFloat(this.getCss('border-right-width') || 0);
            size.height -= parseFloat(this.getCss('border-top-width') || 0) + parseFloat(this.getCss('border-bottom-width') || 0);

            if (!withPadding) {
              size.width -= parseFloat(this.getCss('padding-left') || 0) + parseFloat(this.getCss('padding-right') || 0);
              size.height -= parseFloat(this.getCss('padding-top') || 0) + parseFloat(this.getCss('padding-bottom') || 0);
            }

            return size;
          }
          /**
           * Gets scroll offsets
           *
           * @returns {Hash} Number of pixels that element has been scrolled upward and to the left
           */


          get scroll() {
            return {
              top: this.node.scrollTop,
              left: this.node.scrollLeft
            };
          }
          /**
           * Gets scroll offsets from the window top left corner
           *
           * @returns {Hash}
           */


          get fullScroll() {
            let el = this.node;
            const p = {
              top: 0,
              left: 0
            };

            do {
              p.left += el.scrollLeft || 0;
              p.top += el.scrollTop || 0;
              el = el.parentNode;
            } while (el);

            return p;
          }
          /**
           * Gets absolue position of element
           *
           * @returns {Hash} Coordinates of element's top left corner
           */


          get position() {
            const b = this.node.getBoundingClientRect();
            const docScroll = $J.$(DOC).scroll;
            const doc = $J.browser.doc;
            return {
              top: b.top + docScroll.y - doc.clientTop,
              left: b.left + docScroll.x - doc.clientLeft
            };
          }
          /**
           * Gets element's absolute coordinates on a page
           *
           * @returns {Hash}  top/left/bottom/right coordinates
           */


          get rect() {
            const p = this.position;
            const s = this.size;
            return {
              top: p.top,
              bottom: p.top + s.height,
              left: p.left,
              right: p.left + s.width
            };
          }
          /**
           * Sets element content
           *
           * @param {String} content New content
           *
           * @returns {Element}   Reference to the element itself
           */


          changeContent(c) {
            try {
              this.node.innerHTML = c;
            } catch (e) {
              this.node.innerText = c;
            }

            return this;
          }
          /**
           * Removes element from the DOM tree
           *
           * @returns {Element} Reference to the removed element
           */


          remove() {
            let result = this;

            if (this.node.parentNode) {
              result = $J.$(this.node.parentNode.removeChild(this.node));
            } // TODO remove from storage


            return result;
          }
          /**
           * Kills element by removes it DOM tree and clear all events.
           * All child elements will be killed too.
           *
           * @returns Null
           */


          kill() {
            Array.from(this.node.childNodes).forEach(o => {
              if (o.nodeType === 3 || o.nodeType === 8) {
                return;
              }

              $J.$(o).kill();
            });
            this.remove();
            this.clearEvents();

            if (this.$J_UUID) {
              $J.storage[this.$J_UUID] = null;
              delete $J.storage[this.$J_UUID];
            }

            return null;
          }
          /**
           * Appends child element
           *
           * @param  {Element}   element  Element to append
           * @param  {String}    [position='bottom']  Where to append: top/bottom.
           *
           * @returns {Element}    Reference to the element itself
           */


          append(o, p = 'bottom') {
            const f = this.node.firstChild;
            o = $J.$(o);

            if (p === 'top' && f) {
              this.node.insertBefore(o.node, f);
            } else {
              this.node.appendChild(o.node || o);
            }

            return this;
          }
          /**
           * Appends element to parent
           *
           * @param  {Element}   parent   Parent element
           * @param  {String}    [position='bottom']  Where to append: top/bottom.
           *
           * @returns {Element}    Reference to the element itself
           */


          appendTo(o, p) {
            // return $J.$(o).append(this, p);
            $J.$(o).append(this, p);
            return this;
          }

          get tagName() {
            return this.node.tagName.toLowerCase();
          }

          attr(attrName, attrValue) {
            let result = this;

            if ($J.defined(attrValue)) {
              this.node.setAttribute(attrName, attrValue);
            } else {
              result = this.node.getAttribute(attrName);

              if (!result || $J.typeOf(result) !== 'string' || result.trim() === '') {
                result = null;
              }
            }

            return result;
          }

          removeAttr(attrName) {
            this.node.removeAttribute(attrName);
            return this;
          }
          /**
           * Checks if the specified class applied to the element
           * @param  {String}  cName Class to check
           * @return {Boolean}
           */


          hasClass(cName) {
            // Use `classList` if browser supports it.
            if (this.node.classList) {
              return this.node.classList.contains(cName);
            }

            let className = this.node.className;

            if (this.node.className instanceof SVGAnimatedString) {
              className = this.node.className.baseVal;
            }

            return !$J.stringHas(cName || '', ' ') && $J.stringHas(className || '', ' ');
          }

          hasAttribute(attrName) {
            return this.node.hasAttribute(attrName);
          }

        }
        /* eslint-disable class-methods-use-this */
        // eslint-disable-next-line no-unused-vars


        class Doc extends Base {
          constructor(node) {
            super(node);
            let type = 'magicjs-document';

            if (node === WIN) {
              type = 'magicjs-window';
            }

            this.$J_TYPE = type;
          }
          /**
           * Gets size of browser window
           */


          get size() {
            if ($J.browser.touchScreen) {
              return {
                width: WIN.innerWidth,
                height: WIN.innerHeight
              };
            }

            return {
              width: $J.browser.doc.clientWidth,
              height: $J.browser.doc.clientHeight
            };
          }
          /**
           * Gets window scroll offsets
           */


          get scroll() {
            return {
              x: WIN.pageXOffset || $J.browser.doc.scrollLeft,
              y: WIN.pageYOffset || $J.browser.doc.scrollTop
            };
          }
          /**
           * Get full page size including scroll
           */


          get fullSize() {
            const s = this.size;
            return {
              width: Math.max($J.browser.doc.scrollWidth, s.width),
              height: Math.max($J.browser.doc.scrollHeight, s.height)
            };
          }

        }
        /* eslint-env es6 */

        /* global magicJS, $J */

        /* global WIN, DOC, UND */

        /* global EVENTS_MAP */

        /* eslint-disable dot-notation */

        /* eslint-disable no-unused-vars */

        /* eslint no-restricted-syntax: ["error", "WithStatement", "BinaryExpression[operator='in']"] */

        /* eslint no-unused-vars: ["error", { "args": "none" }] */


        $J.Events = {};
        /**
         * Contains Event methods, custom Events and Element methods to dealing with events.
         * @class Contains Event methods, custom Events and Element methods to dealing with events.
         */

        class MagicEvent {
          constructor(originEvent) {
            this.oe = originEvent;
            this.$J_TYPE = 'event';
            this.isQueueStopped = $J.$false;
            this.type = this.oe.type;
            this.timeStamp = this.oe.timeStamp;
            this.propertyName = this.oe.propertyName;
            this.pointerType = this.oe.pointerType;
          }

          get originEvent() {
            return this.oe;
          }
          /**
           * Stop event propagation and default actions.
           * @return {Event}
           */


          stop() {
            return this.stopDistribution().stopDefaults();
          }
          /**
           * Stop event propagation.
           * @return {Event}
           */


          stopDistribution() {
            if (this.oe.stopPropagation) {
              // if (this.oe.cancelable) {
              this.oe.stopPropagation(); // }
            } else {
              this.oe.cancelBubble = true;
            }

            return this;
          }
          /**
           * Stop default action.
           * @return {Event}
           */


          stopDefaults() {
            if (this.oe.preventDefault) {
              this.oe.preventDefault();
            } else {
              this.oe.returnValue = false;
            }

            return this;
          }
          /**
           * Prevent other listeners to handle the event.
           * @return {Event}
           */


          stopQueue() {
            this.isQueueStopped = $J.$true;
            return this;
          }
          /**
           * Return mouse/pointer coordinates relative to the viewport.
           * @return {Object}
           */


          get clientXY() {
            let src;
            let result = {
              x: 0,
              y: 0
            };

            if (/touch/i.test(this.type)) {
              src = this.oe.changedTouches[0];
            } else {
              src = this.oe;
            }

            if ($J.defined(src)) {
              result = {
                x: src.clientX,
                y: src.clientY
              };
            }

            return result;
          }
          /**
           * Return mouse/pointer coordinates relative to the viewport, including scroll offset.
           * @return {Object}
           */


          get pageXY() {
            let src = this.oe;

            if (/touch/i.test(this.type)) {
              src = this.oe.changedTouches[0];
            }

            if ($J.defined(src)) {
              return {
                x: src.pageX || src.clientX + $J.browser.doc.scrollLeft,
                y: src.pageY || src.clientY + $J.browser.doc.scrollTop
              };
            }

            return {
              x: 0,
              y: 0
            };
          }
          /**
           * Return target element.
           * @return {Element}
           */


          get target() {
            let t = this.oe.target;

            if (!t) {
              t = this.oe.srcElement;
            }

            while (t && t.nodeType === 3) {
              t = t.parentNode;
            }

            return t;
          }
          /**
           * Return related element.
           * @return {Element}
           */


          get related() {
            let r = null;

            switch (this.type) {
              case 'mouseover':
              case 'pointerover':
              case 'MSPointerOver':
                r = this.oe.relatedTarget;

                if (!r) {
                  r = this.oe.fromElement;
                }

                break;

              case 'mouseout':
              case 'pointerout':
              case 'MSPointerOut':
                r = this.oe.relatedTarget;

                if (!r) {
                  r = this.oe.toElement;
                }

                break;

              default:
                return r;
            }

            try {
              while (r && r.nodeType === 3) {
                r = r.parentNode;
              }
            } catch (ex) {
              r = null;
            }

            return r;
          }
          /**
           * Return clicked button
           *  1 - left, 2 - middle, 3 - right
           *
           * @returns  {integer}   button index
           */


          get button() {
            let result = this.oe.which;

            if (!this.oe.which && this.oe.button !== UND) {
              if (this.oe.button & 1) {
                result = 1;
              } else if (this.oe.button & 2) {
                result = 3;
              } else if (this.oe.button & 4) {
                result = 2;
              } else {
                result = 0;
              }
            }

            return result;
          }
          /**
           * Return true if it's a Touch/Pointer event.
           * @return {Boolean}
           */


          isTouchEvent() {
            return this.oe.pointerType && (this.oe.pointerType === 'touch' || this.oe.pointerType === this.oe.MSPOINTER_TYPE_TOUCH) || /touch/i.test(this.type);
          }
          /**
           * Return true if it's a primary Touch/Pointer event.
           * @return {Boolean}
           */


          isPrimaryTouch() {
            if (this.oe.pointerType) {
              return (this.oe.pointerType === 'touch' || this.oe.MSPOINTER_TYPE_TOUCH === this.oe.pointerType) && this.oe.isPrimary;
            } else if (this.oe instanceof WIN.TouchEvent) {
              return this.oe.changedTouches.length === 1 && (this.oe.targetTouches.length ? this.oe.targetTouches[0].identifier === this.oe.changedTouches[0].identifier : true);
            }

            return false;
          }
          /**
           * Return reference to the primary Touch/Pointer event.
           * @return {Object}
           */


          get primaryTouch() {
            let result = null;

            if (this.oe.pointerType) {
              if (this.oe.isPrimary && (this.oe.pointerType === 'touch' || this.oe.MSPOINTER_TYPE_TOUCH === this.oe.pointerType)) {
                result = this.oe;
              }
            } else if (this.oe instanceof WIN.TouchEvent) {
              result = this.oe.changedTouches[0];
            }

            return result;
          }
          /**
           * Return identifier of the primary Touch/Pointer event.
           * @return {Int}
           */


          get primaryTouchId() {
            let result = null;

            if (this.oe.pointerType) {
              if (this.oe.isPrimary && (this.oe.pointerType === 'touch' || this.oe.MSPOINTER_TYPE_TOUCH === this.oe.pointerType)) {
                result = this.oe.pointerId;
              }
            } else if (this.oe instanceof WIN.TouchEvent) {
              result = this.oe.changedTouches[0].identifier;
            }

            return result;
          }

        }

        $J.Events.MagicEvent = MagicEvent;
        /* Extend Element and Document prototypes */

        $J._event_add_ = 'addEventListener';
        $J._event_del_ = 'removeEventListener';
        $J._event_prefix_ = '';

        if (!DOC.addEventListener) {
          $J._event_add_ = 'attachEvent';
          $J._event_del_ = 'detachEvent';
          $J._event_prefix_ = 'on';
        }

        class Custom {
          constructor(e) {
            this.$J_TYPE = 'event.custom';
            this.magicEvent = e.$J_TYPE === 'event' ? e : e.magicEvent;
            this.type = this.magicEvent.type;
            this._target = null;
            this.x = this.magicEvent.oe.x;
            this.y = this.magicEvent.oe.y;
            this.timeStamp = this.magicEvent.oe.timeStamp;
            this.relatedTarget = this.magicEvent.related;
            this.isQueueStopped = this.magicEvent.isQueueStopped; // TODO $J.$false

            this.events = [];
          }

          get originEvent() {
            return this.magicEvent.originEvent;
          }

          pushToEvents(e) {
            const eventCopy = e;
            this.events.push(eventCopy);
          }

          stop() {
            return this.stopDistribution().stopDefaults();
          }

          stopDistribution() {
            this.events.forEach(e => {
              try {
                e.stopDistribution();
              } catch (ex) {// empty
              }
            });
            return this;
          }

          stopDefaults() {
            this.events.forEach(e => {
              try {
                e.stopDefaults();
              } catch (ex) {// empty
              }
            });
            return this;
          }

          stopQueue() {
            this.isQueueStopped = $J.$true;
            this.magicEvent.stopQueue();
            return this;
          }
          /**
           * Return mouse/pointer coordinates relative to the viewport.
           * @return {Object}
           */


          get clientXY() {
            return {
              x: this.clientX || this.magicEvent.oe.clientX,
              y: this.clientY || this.magicEvent.oe.clientY
            };
          }
          /**
           * Return mouse/pointer coordinates relative to the viewport, including scroll offset.
           * @return {Object}
           */


          get pageXY() {
            return {
              x: this.x,
              y: this.y
            };
          }

          get target() {
            return this._target || this.magicEvent.oe.target;
          }

          get related() {
            return this.relatedTarget;
          }

          get button() {
            return this.magicEvent.button; // return this.button;
          }

          get originalTarget() {
            if (this.events.length > 0) {
              return this.events[0].target;
            }

            return UND;
          }
          /**
           * Return true if it's a Touch/Pointer event.
           * @return {Boolean}
           */


          isTouchEvent() {
            return this.magicEvent.isTouchEvent();
          }
          /**
           * Return true if it's a primary Touch/Pointer event.
           * @return {Boolean}
           */


          isPrimaryTouch() {
            return this.magicEvent.isPrimaryTouch();
          }
          /**
           * Return reference to the primary Touch/Pointer event.
           * @return {Object}
           */


          get primaryTouch() {
            return this.magicEvent.primaryTouch;
          }
          /**
           * Return identifier of the primary Touch/Pointer event.
           * @return {Int}
           */


          get primaryTouchId() {
            return this.magicEvent.primaryTouchId;
          }

        }

        $J.Events.Custom = Custom;
        $J.Events.handlers = {};
        /**
         * Dom ready custom event implementation
         */

        ($J => {
          if (DOC.readyState === 'interactive' || DOC.readyState === 'complete') {
            setTimeout(() => $J.browser.onready(), 0);
          } else {
            $J.$(DOC).addEvent('readystatechange', event => {
              if (event.target.readyState === 'interactive' || event.target.readyState === 'complete') {
                $J.browser.onready();
              }
            });
            $J.$(DOC).addEvent('DOMContentLoaded', () => {
              $J.browser.onready();
            });
            $J.$(WIN).addEvent('load', () => {
              $J.browser.onready();
            });
          }
        })(magicJS);
        /* eslint-env es6 */

        /* eslint no-restricted-properties: [2, {"object": "Math.pow"}] */

        /* global magicJS, DOC */


        ($J => {
          const RADIUS_THRESHOLD = 5; // Click radius  // Click speed threshold

          const TIME_THRESHOLD = 300; // Click speed threshold

          class BtnClick extends $J.Events.Custom {
            constructor(e, target) {
              super(e);
              const r = e.pageXY;
              this.type = 'btnclick';
              this.x = r.x;
              this.y = r.y;
              this.clientX = e.oe.clientX;
              this.clientY = e.oe.clientY;
              this._target = target.node;
              this.pushToEvents(e);
            }

          }

          const _options = {
            threshold: TIME_THRESHOLD,
            // Click speed threshold
            button: 1 // left button

          };

          const onclick = function (e) {
            e.stopDefaults();
          };

          const handle = function (e) {
            const options = this.fetch('event:btnclick:options');

            if (e.type !== 'dblclick' && e.button !== options.button) {
              return;
            }

            if (this.fetch('event:btnclick:ignore')) {
              this.del('event:btnclick:ignore');
              return;
            }

            let btnclickEvent;

            if (e.type === 'mousedown') {
              // e.stop(); // will it cause problems? but if we need to stop mousedown user wont be able to do this, as we don't pass it
              btnclickEvent = new BtnClick(e, this);
              this.store('event:btnclick:btnclickEvent', btnclickEvent);
            } else if (e.type === 'mouseup') {
              btnclickEvent = this.fetch('event:btnclick:btnclickEvent');

              if (!btnclickEvent) {
                return;
              }

              const r = e.pageXY;
              this.del('event:btnclick:btnclickEvent');
              btnclickEvent.pushToEvents(e); // if (e.timeStamp - btnclickEvent.timeStamp <= options.threshold && btnclickEvent.x == r.x && btnclickEvent.y == r.y) {

              if (e.timeStamp - btnclickEvent.timeStamp <= options.threshold && Math.sqrt(Math.pow(r.x - btnclickEvent.x, 2) + Math.pow(r.y - btnclickEvent.y, 2)) <= RADIUS_THRESHOLD) {
                this.callEvent('btnclick', btnclickEvent);
              } // Release mousedrag event


              $(DOC).callEvent('mouseup', e);
            } else if (e.type === 'dblclick') {
              // fire another btnclick because IE doesn't fire second mousedown on double click (and second click too)
              btnclickEvent = new BtnClick(e, this);
              this.callEvent('btnclick', btnclickEvent);
            }
          };

          const handler = {
            add: function (options) {
              this.store('event:btnclick:options', Object.assign($J.detach(_options), options || {}));
              this.addEvent(['mousedown', 'mouseup'], handle, 1).addEvent('click', onclick, 1);
            },
            remove: function () {
              this.removeEvent(['mousedown', 'mouseup'], handle).removeEvent('click', onclick);
            }
          };
          $J.Events.handlers.btnclick = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* global magicJS, DOC */


        ($J => {
          class Mousedrag extends $J.Events.Custom {
            constructor(e, target, state) {
              super(e);
              const r = e.pageXY;
              this.x = r.x;
              this.y = r.y;
              this.type = 'mousedrag';
              this.clientX = e.clientX;
              this.clientY = e.clientY;
              this._target = target.node;
              this.state = state; // dragmove / dragend

              this.dragged = false;
              this.pushToEvents(e);
            }

          }

          const handleMouseDown = function (e) {
            if (e.button !== 1) {
              return;
            } // e.stopDefaults();


            const dragEvent = new Mousedrag(e, this, 'dragstart');
            this.store('event:mousedrag:dragstart', dragEvent); // this.callEvent('mousedrag', dragEvent);
          };

          const handleMouseUp = function (e) {
            let dragEvent = this.fetch('event:mousedrag:dragstart');

            if (!dragEvent) {
              return;
            }

            e.stopDefaults();
            dragEvent = new Mousedrag(e, this, 'dragend');
            this.del('event:mousedrag:dragstart');
            this.callEvent('mousedrag', dragEvent);
          };

          const handleMouseMove = function (e) {
            let dragEvent = this.fetch('event:mousedrag:dragstart');

            if (!dragEvent) {
              return;
            }

            e.stopDefaults();

            if (!dragEvent.dragged) {
              dragEvent.dragged = true;
              this.callEvent('mousedrag', dragEvent); // send dragstart
            }

            dragEvent = new Mousedrag(e, this, 'dragmove');
            this.callEvent('mousedrag', dragEvent);
          };

          const handler = {
            add: function () {
              const move = handleMouseMove.bind(this);
              const end = handleMouseUp.bind(this);
              this.addEvent('mousedown', handleMouseDown, 1).addEvent('mouseup', handleMouseUp, 1);
              $(DOC).addEvent('mousemove', move, 1).addEvent('mouseup', end, 1);
              this.store('event:mousedrag:listeners:document:move', move);
              this.store('event:mousedrag:listeners:document:end', end);
            },
            remove: function () {
              const f = () => {};

              this.removeEvent('mousedown', handleMouseDown).removeEvent('mouseup', handleMouseUp);
              $(DOC).removeEvent('mousemove', this.fetch('event:mousedrag:listeners:document:move') || f).removeEvent('mouseup', this.fetch('event:mousedrag:listeners:document:end') || f);
              this.del('event:mousedrag:listeners:document:move').del('event:mousedrag:listeners:document:end');
            }
          };
          $J.Events.handlers.mousedrag = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* global magicJS */


        ($J => {
          class Dblbtnclick extends $J.Events.Custom {
            constructor(e, target) {
              super(e);
              const r = e.pageXY;
              this.x = r.x;
              this.y = r.y;
              this.type = 'dblbtnclick';
              this.clientX = e.clientX;
              this.clientY = e.clientY;
              this._target = target.node;
              this.timedout = false;
              this.tm = null;
              this.pushToEvents(e);
            }

          }

          const _options = {
            threshold: 200
          };

          const handle = function (e) {
            let event = this.fetch('event:dblbtnclick:event');

            if (!event) {
              // first click
              const options = this.fetch('event:dblbtnclick:options');
              event = new Dblbtnclick(e, this);
              event.tm = setTimeout(() => {
                event.timedout = true;
                e.isQueueStopped = $J.$false;
                this.callEvent('btnclick', e);
                this.del('event:dblbtnclick:event');
              }, options.threshold + 10);
              this.store('event:dblbtnclick:event', event);
              e.stopQueue();
            } else {
              clearTimeout(event.tm);
              this.del('event:dblbtnclick:event');

              if (!event.timedout) {
                // double click detected within threshold timeout
                event.pushToEvents(e);
                e.stopQueue().stop();
                this.callEvent('dblbtnclick', event);
              } else {// double click timed out
              }
            }
          };

          const handler = {
            add: function (options) {
              this.store('event:dblbtnclick:options', Object.assign($J.detach(_options), options || {}));
              this.addEvent('btnclick', handle, 1); // we should be first handler in queue or this wont work
            },
            remove: function () {
              this.removeEvent('btnclick', handle);
            }
          };
          $J.Events.handlers.dblbtnclick = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* global magicJS */

        /* eslint no-restricted-properties: [2, {"object": "Math.pow"}] */

        /* eslint no-unused-vars: ["error", { "args": "none" }] */


        ($J => {
          // Tap thresholds
          const RADIUS_THRESHOLD = 10;
          const TIME_THRESHOLD = 200;

          class Tap extends $J.Events.Custom {
            constructor(e, target) {
              super(e);
              const touch = e.primaryTouch;
              this.type = 'tap';
              this.id = touch.pointerId || touch.identifier;
              this.x = touch.pageX;
              this.y = touch.pageY;
              this.pageX = touch.pageX;
              this.pageY = touch.pageY;
              this.clientX = touch.clientX;
              this.clientY = touch.clientY;
              this._target = target.node;
              this.pushToEvents(e);
            } // eslint-disable-next-line class-methods-use-this


            get button() {
              return 0;
            }

          }

          const onClick = function (e) {
            e.stopDefaults();
          };

          const onTouchStart = function (e) {
            if (!e.isPrimaryTouch()) {
              this.del('event:tap:event');
              return;
            }

            this.store('event:tap:event', new Tap(e, this)); // Prevent btnclick event

            this.store('event:btnclick:ignore', true);
          };

          const onTouchEnd = function (e) {
            const event = this.fetch('event:tap:event'); // let options = this.fetch('event:tap:options');

            if (!event || !e.isPrimaryTouch()) {
              return;
            }

            this.del('event:tap:event');

            if (event.id === e.primaryTouchId && e.timeStamp - event.timeStamp <= TIME_THRESHOLD && Math.sqrt(Math.pow(e.primaryTouch.pageX - event.x, 2) + Math.pow(e.primaryTouch.pageY - event.y, 2)) <= RADIUS_THRESHOLD) {
              this.del('event:btnclick:btnclickEvent');
              e.stop();
              event.pushToEvents(e);
              this.callEvent('tap', event);
            }
          };

          const handler = {
            add: function (options) {
              this.addEvent(['touchstart', 'pointerdown'], onTouchStart, 1).addEvent(['touchend', 'pointerup'], onTouchEnd, 1).addEvent('click', onClick, 1);
            },
            remove: function () {
              this.removeEvent(['touchstart', 'pointerdown'], onTouchStart).removeEvent(['touchend', 'pointerup'], onTouchEnd).removeEvent('click', onClick);
            }
          };
          $J.Events.handlers.tap = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* global magicJS */


        ($J => {
          class Dbltap extends $J.Events.Custom {
            constructor(e, target) {
              super(e);
              this.type = 'dbltap';
              this.x = e.x;
              this.y = e.y;
              this.clientX = e.clientX;
              this.clientY = e.clientY;
              this._target = target.node;
              this.timedout = false;
              this.tm = null;
              this.pushToEvents(e);
            }

          }

          const _options = {
            threshold: 300
          };

          const handle = function (e) {
            let event = this.fetch('event:dbltap:event');

            if (!event) {
              // first tap
              const options = this.fetch('event:dbltap:options');
              event = new Dbltap(e, this);
              event.tm = setTimeout(() => {
                event.timedout = true;
                e.isQueueStopped = $J.$false;
                this.callEvent('tap', e);
              }, options.threshold + 10);
              this.store('event:dbltap:event', event);
              e.stopQueue();
            } else {
              clearTimeout(event.tm);
              this.del('event:dbltap:event');

              if (!event.timedout) {
                // double tap detected within threshold timeout
                event.pushToEvents(e);
                e.stopQueue().stop();
                this.callEvent('dbltap', event);
              } else {// double tap timed out
              }
            }
          };

          const handler = {
            add: function (options) {
              this.store('event:dbltap:options', Object.assign($J.detach(_options), options || {}));
              this.addEvent('tap', handle, 1); // we should be first handler in queue or this wont work
            },
            remove: function () {
              this.removeEvent('tap', handle);
            }
          };
          $J.Events.handlers.dbltap = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* eslint no-restricted-properties: [2, {"object": "Math.pow"}] */

        /* global magicJS, DOC */


        ($J => {
          const RADIUS_THRESHOLD = 10;

          class Touchdrag extends $J.Events.Custom {
            constructor(e, target, state) {
              super(e);
              const touch = e.primaryTouch;
              this.type = 'touchdrag';
              this.id = touch.pointerId || touch.identifier;
              this.clientX = touch.clientX;
              this.clientY = touch.clientY;
              this.pageX = touch.pageX;
              this.pageY = touch.pageY;
              this.x = touch.pageX;
              this.y = touch.pageY;
              this._target = target.node;
              this.state = state; // dragmove / dragend

              this.dragged = false;
              this.pushToEvents(e);
            } // eslint-disable-next-line class-methods-use-this


            get button() {
              return 0;
            }

          }

          const onTouchStart = function (e) {
            if (!e.isPrimaryTouch()) {
              return;
            }

            const dragEvent = new Touchdrag(e, this, 'dragstart');
            this.store('event:touchdrag:dragstart', dragEvent);
          };

          const onTouchEnd = function (e) {
            let dragEvent = this.fetch('event:touchdrag:dragstart');

            if (!dragEvent || !dragEvent.dragged || dragEvent.id !== e.primaryTouchId) {
              return;
            }

            dragEvent = new Touchdrag(e, this, 'dragend');
            this.del('event:touchdrag:dragstart');
            this.callEvent('touchdrag', dragEvent);
          };

          const onTouchMove = function (e) {
            let dragEvent = this.fetch('event:touchdrag:dragstart');

            if (!dragEvent || !e.isPrimaryTouch()) {
              return;
            }

            if (dragEvent.id !== e.primaryTouchId) {
              this.del('event:touchdrag:dragstart');
              return;
            }

            if (!dragEvent.dragged && Math.sqrt(Math.pow(e.primaryTouch.pageX - dragEvent.x, 2) + Math.pow(e.primaryTouch.pageY - dragEvent.y, 2)) > RADIUS_THRESHOLD) {
              dragEvent.dragged = true;
              this.callEvent('touchdrag', dragEvent); // send dragstart
            }

            if (!dragEvent.dragged) {
              return;
            }

            dragEvent = new Touchdrag(e, this, 'dragmove');
            this.callEvent('touchdrag', dragEvent);
          };

          const handler = {
            add: function () {
              const move = onTouchMove.bind(this);
              const end = onTouchEnd.bind(this);
              this.addEvent(['touchstart', 'pointerdown'], onTouchStart, 1).addEvent(['touchend', 'pointerup'], onTouchEnd, 1).addEvent(['touchmove', 'pointermove'], onTouchMove, 1);
              this.store('event:touchdrag:listeners:document:move', move);
              this.store('event:touchdrag:listeners:document:end', end);
              $(DOC).addEvent('pointermove', move, 1).addEvent('pointerup', end, 1);
            },
            remove: function () {
              const f = () => {};

              this.removeEvent(['touchstart', 'pointerdown'], onTouchStart).removeEvent(['touchend', 'pointerup'], onTouchEnd).removeEvent(['touchmove', 'pointermove'], onTouchMove);
              $(DOC).removeEvent('pointermove', this.fetch('event:touchdrag:listeners:document:move') || f, 1).removeEvent('pointerup', this.fetch('event:touchdrag:listeners:document:end') || f, 1);
              this.del('event:touchdrag:listeners:document:move').del('event:touchdrag:listeners:document:end');
            }
          };
          $J.Events.handlers.touchdrag = handler;
        })(magicJS);
        /* global DOC, magicJS */

        /* eslint-disable indent */

        /* eslint-disable dot-notation */

        /* eslint no-unused-vars: ["error", { "args": "none" }] */

        /* eslint no-restricted-properties: [2, {"object": "Math.pow"}] */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


        ($J => {
          let baseSpace = null;
          const $ = $J.$;

          const distance = (point1, point2) => {
            const x = point2.x - point1.x;
            const y = point2.y - point1.y;
            return Math.sqrt(x * x + y * y);
          };

          const getSpace = (targetTouches, variables) => {
            const ts = Array.prototype.slice.call(targetTouches);
            const diffX = Math.abs(ts[1].pageX - ts[0].pageX);
            const diffY = Math.abs(ts[1].pageY - ts[0].pageY);

            const _x = Math.min(ts[1].pageX, ts[0].pageX) + diffX / 2;

            const _y = Math.min(ts[1].pageY, ts[0].pageY) + diffY / 2;

            let result = 0;
            variables.points = [ts[0], ts[1]]; // result = Math.PI * Math.pow(distance({ x: ts[0].pageX, y: ts[1].pageX }, { x: ts[0].pageY, y: ts[1].pageY }) / 2, 2);
            // result = Math.pow(Math.max(diffX, diffY), 2);

            result = Math.pow(distance({
              x: ts[0].pageX,
              y: ts[0].pageY
            }, {
              x: ts[1].pageX,
              y: ts[1].pageY
            }), 2); // result = (Math.abs(ts[0].pageX - ts[1].pageX) || 1) * (Math.abs(ts[0].pageY - ts[1].pageY) || 1);

            variables.centerPoint = {
              x: _x,
              y: _y
            };
            variables.x = variables.centerPoint.x;
            variables.y = variables.centerPoint.y;
            return result;
          };

          const getScale = space => {
            return space / baseSpace;
          };

          const getTouches = (e, cache) => {
            let result;
            const originEvent = e.originEvent;

            if (originEvent.targetTouches && originEvent.changedTouches) {
              if (originEvent.targetTouches) {
                result = originEvent.targetTouches;
              } else {
                result = originEvent.changedTouches;
              }

              result = Array.prototype.slice.call(result);
            } else {
              // fucking ie 11 does not support Array.from()
              result = [];

              if (cache) {
                cache.forEach(v => {
                  result.push(v);
                });
              }
            }

            return result;
          };

          const cacheEvent = (e, cache, justSame) => {
            if (e.pointerId && e.pointerType === 'touch' && (!justSame || cache.has(e.pointerId))) {
              cache.set(e.pointerId, e);
              return true;
            }

            return false;
          };

          const removeCache = (e, cache) => {
            if (e.pointerId && e.pointerType === 'touch' && cache && cache.has(e.pointerId)) {
              // compressor does not want to compress
              cache['delete'](e.pointerId);
            }
          };

          const getEventId = e => {
            return e.pointerId && e.pointerType === 'touch' ? e.pointerId : e.identifier;
          };

          const addActivePoints = (targetTouches, container) => {
            let result = false;

            for (let i = 0; i < targetTouches.length; i++) {
              if (container.length === 2) {
                break;
              } else {
                const id = getEventId(targetTouches[i]);

                if (!container.includes(id)) {
                  container.push(id);
                  result = true;
                }
              }
            }

            return result;
          };

          const getIds = targetTouches => {
            return targetTouches.map(value => getEventId(value));
          };

          const removeActivePoint = (targetTouches, container) => {
            let result = false;

            if (container) {
              const ids = getIds(targetTouches);

              for (let i = 0; i < container.length; i++) {
                if (!ids.includes(container[i])) {
                  container.splice(i, 1);
                  result = true;
                  break;
                }
              }
            }

            return result;
          };

          const getActivePoints = (targetTouches, container) => {
            const result = [];

            for (let i = 0; i < targetTouches.length; i++) {
              if (container.includes(getEventId(targetTouches[i]))) {
                result.push(targetTouches[i]);

                if (result.length === 2) {
                  break;
                }
              }
            }

            return result;
          };

          const removePinchEnd = el => {
            const target = el.fetch('event:pinch:target');

            if (target) {
              target.removeEvent(['touchend'], el.fetch('event:pinch:listeners:document:end'));
            }

            el.del('event:pinch:target');
          };

          const clearCache = el => {
            const cache = el.fetch('event:pinch:cache');

            if (cache) {
              cache.clear();
            }

            el.del('event:pinch:cache');
          };

          class Pinch extends $J.Events.Custom {
            constructor(e, target, state, variables) {
              super(e);
              this.type = 'pinch';
              this._target = target.node;
              this.state = state; // pinchmove / pinchend / pinchresize

              this.x = variables.x;
              this.y = variables.y;
              this.scale = variables.scale;
              this.space = variables.space;
              this.zoom = variables.zoom;
              this.state = state;
              this.centerPoint = variables.centerPoint;
              this.points = variables.points;
              this.pushToEvents(e);
            }

          }

          const _variables = {
            x: 0,
            y: 0,
            space: 0,
            scale: 1,
            zoom: 0,
            startSpace: 0,
            startScale: 1,
            started: false,
            dragged: false,
            points: [],
            centerPoint: {
              x: 0,
              y: 0
            }
          };

          const setVariables = (targetTouches, variables) => {
            const lastSpace = variables.space;

            if (targetTouches.length > 1) {
              variables.space = getSpace(targetTouches, variables);

              if (!variables.startSpace) {
                variables.startSpace = variables.space;
              }

              if (lastSpace > variables.space) {
                variables.zoom = -1;
              } else if (lastSpace < variables.space) {
                variables.zoom = 1;
              } else {
                variables.zoom = 0;
              }

              variables.scale = getScale(variables.space);
            } else {
              variables.points = [];
            }
          }; // const onClick = function (e) { e.stop(); };


          const onTouchMove = function (e) {
            let pinchEvent;
            let variables = this.fetch('event:pinch:variables');
            const cache = this.fetch('event:pinch:cache');
            const currentActivePoints = this.fetch('event:pinch:activepoints');

            if (!variables) {
              variables = Object.assign({}, $J.detach(_variables));
            }

            if (variables.started) {
              if (e.pointerId && !cacheEvent(e, cache, true)) {
                return;
              }

              e.stop();
              setVariables(getActivePoints(getTouches(e, cache), currentActivePoints), variables);
              pinchEvent = new Pinch(e, this, 'pinchmove', variables);
              this.callEvent('pinch', pinchEvent);
            }
          };

          const onTouchStart = function (e) {
            let pinchEventStart;
            let variables;
            let cache = this.fetch('event:pinch:cache');
            let currentActivePoints = this.fetch('event:pinch:activepoints');

            if (e.pointerType === 'mouse') {
              return;
            }

            if (!currentActivePoints) {
              currentActivePoints = [];
              this.store('event:pinch:activepoints', currentActivePoints);
            }

            if (!cache) {
              cache = new Map();
              this.store('event:pinch:cache', cache);
            }

            if (!this.fetch('event:pinch:target')) {
              this.store('event:pinch:target', $(e.target));
              $(e.target).addEvent(['touchend'], this.fetch('event:pinch:listeners:document:end'), 1);
            }

            cacheEvent(e, cache);
            const targetTouches = getTouches(e, cache);
            addActivePoints(targetTouches, currentActivePoints);

            if (targetTouches.length === 2) {
              pinchEventStart = this.fetch('event:pinch:pinchstart');
              variables = this.fetch('event:pinch:variables');

              if (!variables) {
                variables = Object.assign({}, $J.detach(_variables));
              }

              setVariables(getActivePoints(targetTouches, currentActivePoints), variables);

              if (!pinchEventStart) {
                pinchEventStart = new Pinch(e, this, 'pinchstart', variables);
                this.store('event:pinch:pinchstart', pinchEventStart);
                this.store('event:pinch:variables', variables);
                baseSpace = variables.space;
                this.callEvent('pinch', pinchEventStart);
                variables.started = true;
              }
            }
          };

          const onTouchEnd = function (e) {
            const cache = this.fetch('event:pinch:cache');

            if (e.pointerType === 'mouse' || e.pointerId && (!cache || !cache.has(e.pointerId))) {
              return;
            }

            let pinchEvent = this.fetch('event:pinch:pinchstart');
            const variables = this.fetch('event:pinch:variables');
            const currentActivePoints = this.fetch('event:pinch:activepoints');
            const targetTouches = getTouches(e, cache);
            removeCache(e, cache);
            const removingResult = removeActivePoint(targetTouches, currentActivePoints);

            if (!pinchEvent || !variables || !variables.started || !removingResult || !currentActivePoints) {
              return;
            }

            if (removingResult) {
              addActivePoints(targetTouches, currentActivePoints);
            }

            let _event = 'pinchend';

            if (targetTouches.length > 1) {
              _event = 'pinchresize';
            } else {
              this.del('event:pinch:pinchstart').del('event:pinch:variables').del('event:pinch:activepoints');
              clearCache(this);
              removePinchEnd(this);
            }

            setVariables(getActivePoints(targetTouches, currentActivePoints), variables);
            pinchEvent = new Pinch(e, this, _event, variables);
            this.callEvent('pinch', pinchEvent);
          };

          const handler = {
            add: function (options) {
              if (!baseSpace) {
                baseSpace = (() => {
                  const s = $J.W.size;
                  s.width = Math.min(s.width, s.height);
                  s.height = s.width; // var s = { width: 375, height: 812 };

                  return Math.pow(distance({
                    x: 0,
                    y: 0
                  }, {
                    x: s.width,
                    y: s.height
                  }), 2);
                })();
              }

              const move = onTouchMove.bind(this);
              const end = onTouchEnd.bind(this);
              this.addEvent(['touchstart', 'pointerdown'], onTouchStart, 1).addEvent(['pointerup'], onTouchEnd, 1).addEvent(['touchmove', 'pointermove'], onTouchMove, 1);
              this.store('event:pinch:listeners:document:move', move);
              this.store('event:pinch:listeners:document:end', end);
              $(DOC).addEvent('pointermove', move, 1).addEvent('pointerup', end, 1);
            },
            remove: function () {
              this.removeEvent(['touchstart', 'pointerdown'], onTouchStart).removeEvent(['pointerup'], onTouchEnd).removeEvent(['touchmove', 'pointermove'], onTouchMove);

              const f = () => {};

              $(DOC).removeEvent('pointermove', this.fetch('event:pinch:listeners:document:move') || f, 1).removeEvent('pointerup', this.fetch('event:pinch:listeners:document:end') || f, 1);
              this.del('event:pinch:listeners:document:move').del('event:pinch:listeners:document:end');
              removePinchEnd(this);
              clearCache(this);
              this.del('event:pinch:variables').del('event:pinch:activepoints').del('event:pinch:pinchstart');
            }
          };
          $J.Events.handlers.pinch = handler;
        })(magicJS);
        /* eslint-env es6 */

        /* global magicJS, DOC, UND */


        ($J => {
          let eventType = 'wheel';

          if (!('onwheel' in DOC || $J.browser.ieMode > 8)) {
            eventType = 'mousewheel';
          }

          class Mousescroll extends $J.Events.Custom {
            constructor(e, target, delta, deltaX, deltaY, deltaZ, deltaFactor) {
              super(e);
              const r = e.pageXY;
              this.x = r.x;
              this.y = r.y;
              this.type = 'mousescroll'; // this.timeStamp = e.timeStamp;

              this._target = target.node;
              this.delta = delta || 0;
              this.deltaX = deltaX || 0;
              this.deltaY = deltaY || 0;
              this.deltaZ = deltaZ || 0;
              this.deltaFactor = deltaFactor || 0;
              this.deltaMode = e.deltaMode || 0;
              this.isMouse = false;
              this.pushToEvents(e);
            }

          }

          let lowestDelta;
          let resetDeltaTimer;

          const resetDelta = () => {
            lowestDelta = null;
          };

          const isMouse = (deltaFactor, deltaMode) => {
            return deltaFactor > 50 || deltaMode === 1 && !($J.browser.platform === 'win' && deltaFactor < 1) // Firefox
            || deltaFactor % 12 === 0 // Safari
            || deltaFactor % 4.000244140625 === 0; // Chrome on OS X
          };

          const handle = function (e) {
            let deltaX = 0;
            let deltaY = 0;
            const originEvent = e.originEvent; // DomMouseScroll event

            if (originEvent.detail) {
              deltaY = e.detail * -1;
            } // mousewheel event


            if (originEvent.wheelDelta !== UND) {
              deltaY = originEvent.wheelDelta;
            }

            if (originEvent.wheelDeltaY !== UND) {
              deltaY = originEvent.wheelDeltaY;
            }

            if (originEvent.wheelDeltaX !== UND) {
              deltaX = originEvent.wheelDeltaX * -1;
            } // wheel event


            if (originEvent.deltaY) {
              deltaY = -1 * originEvent.deltaY;
            }

            if (originEvent.deltaX) {
              deltaX = originEvent.deltaX;
            }

            if (deltaY === 0 && deltaX === 0) {
              return;
            }

            let delta = deltaY === 0 ? deltaX : deltaY;
            const absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

            if (!lowestDelta || absDelta < lowestDelta) {
              lowestDelta = absDelta;
            }

            const calc = delta > 0 ? 'floor' : 'ceil';
            delta = Math[calc](delta / lowestDelta);
            deltaX = Math[calc](deltaX / lowestDelta);
            deltaY = Math[calc](deltaY / lowestDelta);

            if (resetDeltaTimer) {
              clearTimeout(resetDeltaTimer);
            }

            resetDeltaTimer = setTimeout(resetDelta, 200);

            const _event = new Mousescroll(e, this, delta, deltaX, deltaY, 0, lowestDelta);

            _event.isMouse = isMouse(lowestDelta, originEvent.deltaMode || 0);
            this.callEvent('mousescroll', _event);
          };

          const handler = {
            add: function () {
              this.addEvent(eventType, handle, 1);
            },
            remove: function () {
              this.removeEvent(eventType, handle, 1);
            }
          };
          $J.Events.handlers.mousescroll = handler;
        })(magicJS);
        /**
         * Do the last things. Extend window, document, etc.
         */


        $J.W = $J.$(WIN);
        $J.D = $J.$(DOC);
        $J.U = UND;
        $J.DPPX = window.devicePixelRatio >= 2 ? 2 : 1; // Dots per px. 2 - is equal to Retina.;

        return magicJS;
      }();
      /* eslint no-throw-literal: "off"*/

      /* eslint no-restricted-properties: "off" */

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint consistent-return: "off"*/

      /* eslint class-methods-use-this: "off"*/

      /* eslint no-unused-expressions: "off"*/

      /* eslint no-undef: "off"*/

      /* eslint no-shadow: ["error", { "allow": ["t", duration] }]*/

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint-env es6*/


      ($J => {
        const $ = $J.$;
        /**
         * Basic transition effects
         * @class
         * @constant
         * @static
         */

        const TRANSITION = {
          linear: 'linear',
          sineIn: 'easeInSine',
          sineOut: 'easeOutSine',
          expoIn: 'easeInExpo',
          expoOut: 'easeOutExpo',
          quadIn: 'easeInQuad',
          quadOut: 'easeOutQuad',
          cubicIn: 'easeInCubic',
          cubicOut: 'easeOutCubic',
          backIn: 'easeInBack',
          backOut: 'easeOutBack',
          elasticIn: (p, x) => {
            x = x || [];
            return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x[0] || 1) / 3);
          },
          elasticOut: (p, x) => {
            return 1 - TRANSITION.elasticIn(1 - p, x);
          },
          bounceIn: p => {
            for (let a = 0, b = 1; 1; a += b, b /= 2) {
              if (p >= (7 - 4 * a) / 11) {
                return b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
              }
            }
          },
          bounceOut: p => {
            return 1 - TRANSITION.bounceIn(1 - p);
          },
          none: x => {
            return 0;
          }
        };
        const STATES = {
          INIT: 0,
          STARTED: 1,
          PLAYING: 2,
          ENDED: 3
        }; // 0 - init,  1 - started, 2 - started, 3 - ended

        /**
         * @class
         * Class that applies animation to an element
         * @example
         * simple usage:
         * new $J.FX(el1), {
         *  'duration': 400
         * }).start({width:[startWidth, endWidth]});
         * @constructs
         * @param {String|Element} el Element to applied an effect
         * @param [opt] Options
         * @param {Number} opt.fps FPS
         * @param {Number} opt.duration Effect duration in miliseconds
         * @param {Function|String} opt.transition  Easing function
         * @param {Function|String} opt.cycles  The number of times the animation should repeat. Default is 1
         * @param {String} opt.direction  Indicates how the animation should play each cycle. Possible values:
         *                  normal - Default. The animation should play forward each cycle.
         *                  alternate - The animation should reverse direction each cycle.
         *                  reverse - The animation plays backward each cycle.
         *                  alternate-reverse - The animation starts backward, then continues to alternate.
         *                  continuous - The animation plays forward continuously (w/o cycles)
         *                  continuous-reverse - The animation plays backward continuously (w/o cycles)
         * @param {Function} opt.onStart Callback called when animation starts
         * @param {Function} opt.onComplete Callback called when animation completes
         * @param {Function} opt.onBeforeRender Callback called before each step of changing CSS properties
         * @param {Function} opt.onAfterRender Callback called after each step of changing CSS properties
         * @param {Boolean} opt.roundCss Use Math.round() when calculating css steps values
         */

        class FX {
          constructor(el
          /* can be array */
          , opt) {
            this.styles = null;
            this.cubicBezier = null;
            this.easeFn = null;
            this.state = STATES.INIT;
            this.pStyles = []; // styles set in percent

            this.alternate = false;
            this.continuous = false;
            this.startTime = null;
            this.finishTime = null;
            this.options = {
              fps: 60,
              duration: 600,
              // transition: function(x) {return  -(Math.cos(Math.PI * x) - 1) / 2},
              transition: 'ease',
              cycles: 1,
              direction: 'normal',
              // normal | reverse | alternate | alternate-reverse | continuous | continuous-reverse
              onStart: () => {},
              onComplete: () => {},
              onBeforeRender: () => {},
              onAfterRender: () => {},
              forceAnimation: false,
              roundCss: false // use Math.round() when calculating css steps values

            };
            this.els = [];

            if (!Array.isArray(el)) {
              el = [el];
            }

            el.forEach(_el => {
              if (_el) {
                this.els.push($(_el));
              }
            });
            this.options = Object.assign(this.options, opt);
            this.timer = false;
            this.setTransition(this.options.transition);

            if ($J.typeOf(this.options.cycles) === 'string') {
              this.options.cycles = this.options.cycles === 'infinite' ? Infinity : parseInt(this.options.cycles, 10) || 1;
            }
          }

          static getTransition() {
            return TRANSITION;
          }

          setTransition(easing) {
            this.options.transition = easing; // this.easeFn = this.cubicBezierAtTime;

            this.easeFn = FX.cubicBezierAtTime;

            const _easing = TRANSITION[this.options.transition] || this.options.transition;

            if ($J.typeOf(_easing) === 'function') {
              this.easeFn = _easing;
            } else {
              this.cubicBezier = this.parseCubicBezier(_easing) || this.parseCubicBezier('ease');
            }
          }
          /**
           * Start animation
           */


          start(styles
          /**Hash*/
          ) {
            const runits = /\%$/;

            if (this.state === STATES.PLAYING) {
              return this;
            }

            this.state = STATES.STARTED;
            this.cycle = 0;
            this.alternate = ['alternate', 'alternate-reverse'].includes(this.options.direction);
            this.continuous = ['continuous', 'continuous-reverse'].includes(this.options.direction);

            if (!styles) {
              styles = {};
            }

            if (!Array.isArray(styles)) {
              styles = [styles];
            }

            this.styles = styles;
            const l = this.styles.length;
            this.pStyles = new Array(l);

            for (let i = 0; i < l; i++) {
              this.pStyles[i] = {};

              for (const s in this.styles[i]) {
                if (runits.test(this.styles[i][s][0])) {
                  this.pStyles[s] = true;
                }

                if (['reverse', 'alternate-reverse', 'continuous-reverse'].includes(this.options.direction)) {
                  this.styles[i][s].reverse();
                }
              }
            }

            this.startTime = +new Date();
            this.finishTime = this.startTime + this.options.duration;
            this.options.onStart();

            if (this.options.duration === 0) {
              // apply all styles immediately
              this.render(1.0);
              this.options.onComplete(this.els.length < 2 ? this.els[0] : this.els);
            } else {
              this.state = STATES.PLAYING;

              if (!this.options.forceAnimation) {
                this.timer = $J.W.node.requestAnimationFrame.call($J.W.node, this.loop.bind(this));
              } else {
                this.timer = setInterval(() => {
                  this.loop();
                }, Math.round(1000 / this.options.fps));
              }
            }

            return this;
          }

          stopAnimation() {
            if (this.timer) {
              if (!this.options.forceAnimation) {
                $J.W.node.cancelAnimationFrame.call($J.W.node, this.timer);
              } else {
                clearInterval(this.timer);
              }

              this.timer = false;
            }
          }
          /**
           * Stop animation
           */


          stop(complete
          /** Boolean*/
          ) {
            if ([STATES.INIT, STATES.ENDED].includes(this.state)) {
              return this;
            }

            if (!$J.defined(complete)) {
              complete = false;
            }

            this.stopAnimation();
            this.state = STATES.ENDED;

            if (complete) {
              this.render(1.0); // clearTimeout(this._completeTimer);
              // this._completeTimer = setTimeout(() => {

              this.options.onComplete(this.els.length < 2 ? this.els[0] : this.els); // }, 10);
            }

            return this;
          }
          /**
           * @ignore
           */


          loop() {
            const _now = +new Date();

            const dx = (_now - this.startTime) / this.options.duration;
            const cycle = Math.floor(dx);

            if (_now >= this.finishTime && cycle >= this.options.cycles) {
              this.stopAnimation();
              this.render(1.0); // clearTimeout(this._completeTimer);
              // this._completeTimer = setTimeout(() => {

              this.options.onComplete(this.els.length < 2 ? this.els[0] : this.els); // }, 10);

              return this;
            }

            if (this.alternate && this.cycle < cycle) {
              for (let i = 0; i < this.styles.length; i++) {
                for (const s in this.styles[i]) {
                  this.styles[i][s].reverse();
                }
              }
            }

            this.cycle = cycle;

            if (!this.options.forceAnimation) {
              this.timer = $J.W.node.requestAnimationFrame.call($J.W.node, this.loop.bind(this));
            }

            this.render((this.continuous ? cycle : 0) + this.easeFn(dx % 1, this.options.duration, this.cubicBezier));
          }
          /**
           * ignore
           */


          render(dx) {
            const css = [];
            const l = this.els.length;

            for (let i = 0; i < l; i++) {
              css.push(this.renderOverLoad(dx, this.els[i], this.styles[i], this.pStyles[i]));
            }

            let _el = this.els;
            let _css = css;

            if (l < 2) {
              _el = this.els[0];
              _css = css[0];
            }

            this.options.onBeforeRender(_css, _el);
            this.set(css);
            this.options.onAfterRender(_css, _el);
          }
          /**
           * ignore
           */


          renderOverLoad(dx, el, styles, pStyles) {
            const css = {};
            Object.entries(styles).forEach(values => {
              const [key, value] = values;

              if (key === 'opacity') {
                css[key] = Math.round(this.calc(value[0], value[1], dx) * 100) / 100;
              } else {
                css[key] = this.calc(value[0], value[1], dx); // if (this.options.roundCss) { css[key] = Math.round(css[key]); } // если двигать кубиком базье в процентах - то без округления лучше двигает
                // Styles defined in percent. Ap

                pStyles[key] && (css[key] += '%');
              }
            });
            return css;
          }
          /**
           * @ignore
           */


          calc(from, to, dx) {
            from = parseFloat(from);
            to = parseFloat(to);
            return (to - from) * dx + from;
          }
          /**
           * @ignore
          */


          set(css) {
            for (let i = 0, l = this.els.length; i < l; i++) {
              this.els[i].setCss(css[i]);
            }

            return this;
          }
          /**
           *
           * Parse timing function string
           *
           * @ignore
           * @example
           * 'cubic-bezier(.0,1.0,.34,.1)'
           * 'ease-in-out'
           */


          parseCubicBezier(cubicbezier) {
            let points = null;

            if ($J.typeOf(cubicbezier) !== 'string') {
              return null;
            }

            switch (cubicbezier) {
              // Standard
              case 'linear':
                points = [0.000, 0.000, 1.000, 1.000];
                break;

              case 'ease':
                points = [0.250, 0.100, 0.250, 1.000];
                break;

              case 'ease-in':
                points = [0.420, 0.000, 1.000, 1.000];
                break;

              case 'ease-out':
                points = [0.000, 0.000, 0.580, 1.000];
                break;

              case 'ease-in-out':
                points = [0.420, 0.000, 0.580, 1.000];
                break;
              // Sine
              // case 'easeInSine':
              //     points = [0.470, 0.000, 0.745, 0.715];
              //     break;
              // case 'easeOutSine':
              //     points = [0.39, 0.575, 0.565, 1.000];
              //     break;
              // case 'easeInOutSine':
              //     points = [0.445, 0.050, 0.550, 0.950];
              //     break;
              // Quad
              // case 'easeInQuad':
              //     points = [0.550, 0.085, 0.680, 0.530];
              //     break;
              // case 'easeOutQuad':
              //     points = [0.250, 0.460, 0.450, 0.940];
              //     break;
              // case 'easeInOutQuad':
              //     points = [0.455, 0.030, 0.515, 0.955];
              //     break;
              // Cubic
              // case 'easeInCubic':
              //     points = [0.550, 0.055, 0.675, 0.190];
              //     break;
              // case 'easeOutCubic':
              //     points = [0.215, 0.610, 0.355, 1.000];
              //     break;
              // case 'easeInOutCubic':
              //     points = [0.645, 0.045, 0.355, 1.000];
              //     break;
              // Quart
              // case 'easeInQuart':
              //     points = [0.895, 0.030, 0.685, 0.220];
              //     break;
              // case 'easeOutQuart':
              //     points = [0.165, 0.840, 0.440, 1.000];
              //     break;
              // case 'easeInOutQuart':
              //     points = [0.770, 0.000, 0.175, 1.000];
              //     break;
              // Quint
              // case 'easeInQuint':
              //     points = [0.755, 0.050, 0.855, 0.060];
              //     break;
              // case 'easeOutQuint':
              //     points = [0.230, 1.000, 0.320, 1.000];
              //     break;
              // case 'easeInOutQuint':
              //     points = [0.860, 0.000, 0.070, 1.000];
              //     break;
              // Expo
              // case 'easeInExpo':
              //     points = [0.950, 0.050, 0.795, 0.035];
              //     break;
              // case 'easeOutExpo':
              //     points = [0.190, 1.000, 0.220, 1.000];
              //     break;
              // case 'easeInOutExpo':
              //     points = [1.000, 0.000, 0.000, 1.000];
              //     break;
              // Circ
              // case 'easeInCirc':
              //     points = [0.600, 0.040, 0.980, 0.335];
              //     break;
              // case 'easeOutCirc':
              //     points = [0.075, 0.820, 0.165, 1.000];
              //     break;
              // case 'easeInOutCirc':
              //     points = [0.785, 0.135, 0.150, 0.860];
              //     break;
              // Back
              // case 'easeInBack':
              //     points = [0.600, -0.280, 0.735, 0.045];
              //     break;
              // case 'easeOutBack':
              //     points = [0.175, 0.885, 0.320, 1.275];
              //     break;
              // case 'easeInOutBack':
              //     points = [0.680, -0.550, 0.265, 1.550];
              //     break;

              default:
                cubicbezier = cubicbezier.replace(/\s/g, '');

                if (cubicbezier.match(/^cubic-bezier\((?:-?[0-9\.]{0,}[0-9]{1,},){3}(?:-?[0-9\.]{0,}[0-9]{1,})\)$/)) {
                  points = cubicbezier.replace(/^cubic-bezier\s*\(|\)$/g, '').split(',');

                  for (let i = points.length - 1; i >= 0; i--) {
                    points[i] = parseFloat(points[i]);
                  }
                }

            }

            return $(points);
          } // From: http://www.netzgesta.de/dev/cubic-bezier-timing-function.html
          // 1:1 conversion to js from webkit source files
          // UnitBezier.h, WebCore_animation_AnimationBase.cpp


          static cubicBezierAtTime(t, duration, cubicBezier) {
            let ax = 0;
            let bx = 0;
            let cx = 0;
            let ay = 0;
            let by = 0;
            let cy = 0; // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.

            const sampleCurveX = t => {
              return ((ax * t + bx) * t + cx) * t;
            };

            const sampleCurveY = t => {
              return ((ay * t + by) * t + cy) * t;
            };

            const sampleCurveDerivativeX = t => {
              return (3.0 * ax * t + 2.0 * bx) * t + cx;
            }; // The epsilon value to pass given that the animation is going to run over |dur| seconds. The longer the
            // animation, the more precision is needed in the timing function result to avoid ugly discontinuities.


            const solveEpsilon = duration => {
              return 1.0 / (200.0 * duration);
            }; // const solve = (x, epsilon) => {
            //     return sampleCurveY(solveCurveX(x, epsilon));
            // };
            // Given an x value, find a parametric value it came from.


            const solveCurveX = (x, epsilon) => {
              let t0;
              let t1;
              let t2;
              let x2;
              let d2;
              let i;

              const fabs = n => {
                if (n >= 0) {
                  return n;
                }

                return 0 - n;
              }; // First try a few iterations of Newton's method -- normally very fast.


              for (t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;

                if (fabs(x2) < epsilon) {
                  return t2;
                }

                d2 = sampleCurveDerivativeX(t2);

                if (fabs(d2) < 1e-6) {
                  break;
                }

                t2 -= x2 / d2;
              } // Fall back to the bisection method for reliability.


              t0 = 0.0;
              t1 = 1.0;
              t2 = x;

              if (t2 < t0) {
                return t0;
              }

              if (t2 > t1) {
                return t1;
              }

              while (t0 < t1) {
                x2 = sampleCurveX(t2);

                if (fabs(x2 - x) < epsilon) {
                  return t2;
                }

                if (x > x2) {
                  t0 = t2;
                } else {
                  t1 = t2;
                }

                t2 = (t1 - t0) * 0.5 + t0;
              }

              return t2; // Failure.
            };

            const solve = (x, epsilon) => {
              return sampleCurveY(solveCurveX(x, epsilon));
            }; // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).


            cx = 3.0 * cubicBezier[0];
            bx = 3.0 * (cubicBezier[2] - cubicBezier[0]) - cx;
            ax = 1.0 - cx - bx;
            cy = 3.0 * cubicBezier[1];
            by = 3.0 * (cubicBezier[3] - cubicBezier[1]) - cy;
            ay = 1.0 - cy - by; // Convert from input time to parametric value in curve, then from that to output time.

            return solve(t, solveEpsilon(duration));
          }

        }

        $J.FX = FX;
      })(magicJS);
      /*eslint no-throw-literal: "off"*/

      /*eslint quote-props: ["off"]*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /*eslint guard-for-in: "off"*/

      /*eslint no-continue: "off"*/

      /*eslint no-else-return: "off"*/

      /*eslint no-undef: "off"*/

      /*eslint consistent-return: "off"*/

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /*eslint no-prototype-builtins: "off"*/

      /*eslint dot-notation: ["off"]*/

      /*eslint-env es6*/


      ($J => {
        let globalValue = null;
        const dataTypes = {
          'boolean': 1,
          'array': 2,
          'number': 3,
          'function': 4,
          'url': 5,
          'string': 100
        };

        const isAbsoluteUrl = v => {
          return /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/i.test(v);
        };

        const typeValidators = {
          'boolean': (option, v, strict) => {
            if ($J.typeOf(v) !== 'boolean') {
              if (strict || $J.typeOf(v) !== 'string') {
                return false;
              } else if (!/^(true|false)$/.test(v)) {
                return false;
              } else {
                v = !v.replace(/true/i, '').trim();
              }
            }

            if (option.hasOwnProperty('enum') && !option['enum'].includes(v)) {
              return false;
            }

            globalValue = v;
            return true;
          },
          'url': (option, v, strict) => {
            let result = false;

            if ($J.typeOf(v) === 'string' && isAbsoluteUrl(v)) {
              if (option.hasOwnProperty('enum')) {
                if (option['enum'].includes(v)) {
                  result = true;
                }
              } else {
                result = true;
              }
            }

            return result;
          },
          'string': (option, v, strict) => {
            if ($J.typeOf(v) !== 'string') {
              return false;
            } else if (option.hasOwnProperty('enum') && !option['enum'].includes(v)) {
              return false;
            } else {
              globalValue = '' + v;
              return true;
            }
          },
          'number': (option, v, strict) => {
            const r = /%$/;
            const percent = $J.typeOf(v) === 'string' && r.test(v); // if (strict && typeof(v) !== 'number') {

            if (strict && !'number' === typeof v) {
              // eslint-disable-line valid-typeof
              return false;
            }

            v = parseFloat(v);

            if (isNaN(v)) {
              return false;
            }

            if (isNaN(option.minimum)) {
              option.minimum = Number.NEGATIVE_INFINITY;
            }

            if (isNaN(option.maximum)) {
              option.maximum = Number.POSITIVE_INFINITY;
            }

            if (option.hasOwnProperty('enum') && !option['enum'].includes(v)) {
              return false;
            }

            if (option.minimum > v || v > option.maximum) {
              return false;
            }

            globalValue = percent ? v + '%' : v;
            return true;
          },
          'array': (option, v, strict) => {
            if ($J.typeOf(v) === 'string') {
              try {
                v = v.replace(/'/g, '"');
                v = $J.W.node.JSON.parse(v);
              } catch (ex) {
                return false;
              }
            }

            if ($J.typeOf(v) === 'array') {
              globalValue = v;
              return true;
            } else {
              return false;
            }
          },
          'function': (option, v, strict) => {
            if ($J.typeOf(v) === 'function') {
              globalValue = v;
              return true;
            }

            return false;
          }
        };
        /**
         * Validate parameter value
         * @param  {object} param  parameter definition
         * @param  {mixed} value  [description]
         * @param  {boolean} strict Should stict validation be applied
         * @return {boolean}        [description]
         */

        const validateParamValue = (param, value, strict) => {
          const opts = param.hasOwnProperty('oneOf') ? param.oneOf : [param];

          if ($J.typeOf(opts) !== 'array') {
            return false;
          }

          for (let i = 0, l = opts.length - 1; i <= l; i++) {
            if (typeValidators[opts[i].type](opts[i], value, strict)) {
              return true;
            }
          }

          return false;
        };
        /**
         * Normalize schema parameter definition
         * @param  {object} param parameter defition
         * @return {object} normalized parameter definition
         */


        const normalizeParam = param => {
          if (param.hasOwnProperty('oneOf')) {
            const l = param.oneOf.length;

            for (let i = 0; i < l; i++) {
              for (let j = i + 1; j < l; j++) {
                if (dataTypes[param.oneOf[i]['type']] > dataTypes[param.oneOf[j].type]) {
                  const temp = param.oneOf[i];
                  param.oneOf[i] = param.oneOf[j];
                  param.oneOf[j] = temp;
                }
              }
            }
          }

          return param;
        };
        /**
         * Validate parameter definition
         * @param  {object} param parameter definition
         * @return {boolean}     [description]
         */


        const validateSchemaParam = param => {
          // validate types
          const opts = param.hasOwnProperty('oneOf') ? param.oneOf : [param];

          if ($J.typeOf(opts) !== 'array') {
            return false;
          }

          for (let i = opts.length - 1; i >= 0; i--) {
            if (!opts[i].type || !dataTypes.hasOwnProperty(opts[i].type)) {
              return false;
            } // validate enum option if present


            if ($J.defined(opts[i]['enum'])) {
              if ($J.typeOf(opts[i]['enum']) !== 'array') {
                return false;
              }

              for (let j = opts[i]['enum'].length - 1; j >= 0; j--) {
                if (!typeValidators[opts[i].type]({
                  'type': opts[i].type
                }, opts[i]['enum'][j], true)) {
                  return false;
                }
              }
            }
          } // validate default value


          if (param.hasOwnProperty('defaults') && !validateParamValue(param, param['defaults'], true)) {
            return false;
          }

          return true;
        };

        const isDefaults = obj => {
          return Object.keys(obj).some(v => v === 'defaults');
        };

        const parseObj = obj => {
          const result = {};

          const parseVars = (map, pathTo) => {
            Object.entries(map).forEach(values => {
              const [prop, value] = values;

              const _pathTo = pathTo.slice(0);

              if ($J.typeOf(value) !== 'object' || isDefaults(value)) {
                _pathTo.push(prop);

                result[_pathTo.join('.')] = value;
              } else {
                _pathTo.push(prop);

                parseVars(value, _pathTo);
              }
            });
          };

          parseVars(obj, []);
          return result;
        };

        const convertToDeepObj = obj => {
          const result = {};

          const setObjValue = (arr, value) => {
            let tmp = result;
            const l = arr.length;

            if (arr[l - 1].trim() === '') {
              arr.splice(l - 1, 1);
            }

            arr.forEach((v, index) => {
              if (index === l - 1) {
                tmp[v] = value;
              } else {
                if (!tmp[v]) {
                  tmp[v] = {};
                }

                tmp = tmp[v];
              }
            });
          };

          Object.entries(obj).forEach(values => {
            setObjValue(values[0].split('.'), values[1]);
          });
          return result;
        };

        const normalizeString = str => {
          return $J.camelize((str + '').trim());
        };

        class Options {
          constructor(schema) {
            this.schema = {};
            this.options = {};
            this.parseSchema(schema);
          }

          parseSchema(schema, force) {
            schema = parseObj(schema);
            Object.entries(schema).forEach(values => {
              const [key, value] = values;
              const newKey = normalizeString(key);

              if (!this.schema.hasOwnProperty(newKey) || force) {
                this.schema[newKey] = normalizeParam(value);

                if (!validateSchemaParam(this.schema[newKey])) {
                  throw 'Incorrect definition of the \'' + i + '\' parameter in ' + schema;
                } // Preserve existing option value


                if ($J.defined(this.options[newKey])) {
                  if (!this.checkValue(newKey, this.options[newKey])) {
                    this.options[newKey] = $J.U;
                  }
                } else {
                  this.options[newKey] = $J.U;
                }
              }
            });
          }

          set(id, value) {
            id = normalizeString(id);

            if ($J.typeOf(value) === 'string') {
              value = value.trim();
            }

            if (this.schema.hasOwnProperty(id)) {
              globalValue = value;

              if (validateParamValue(this.schema[id], value)) {
                this.options[id] = globalValue;
              }

              globalValue = null;
            }
          }

          get(id) {
            id = normalizeString(id);

            if (this.schema.hasOwnProperty(id)) {
              return $J.defined(this.options[id]) ? this.options[id] : this.schema[id]['defaults'];
            }
          }

          fromJSON(obj) {
            obj = parseObj(obj);

            for (const i in obj) {
              this.set(i, obj[i]);
            }
          }

          getJSON() {
            const json = Object.assign({}, this.options);
            Object.keys(json).forEach(key => {
              if (json[key] === $J.U && this.schema[key]['defaults'] !== $J.U) {
                json[key] = this.schema[key]['defaults'];
              }
            });
            return convertToDeepObj(json);
          }
          /**
           * Set options from string
           * @param    str     {String} String with options. Example - "param1:value1;param2:value2;param3:value3; ...."
           * @param    exclude {Object} Object with regexps for options which we want to exclude. Example - { nameOfRegExp1: new RegExp('param2', 'g') }
           * @returns          {Object} Object with options which were excluded. Example - { nameOfRegExp1: 'param2:value2;' }
           */


          fromString(str, exclude) {
            const result = {};

            if (!exclude) {
              exclude = {};
            }

            const check = substr => {
              substr = substr.trim();
              return !Object.entries(exclude).find(([key, value]) => {
                if (value.test && value.test(substr)) {
                  if (!result[key]) {
                    result[key] = '';
                  }

                  result[key] += substr + ';';
                  return true;
                }

                return false;
              });
            };

            str.split(';').forEach(chunk => {
              if (check(chunk)) {
                chunk = chunk.split(':');
                this.set(chunk.shift().trim(), chunk.join(':'));
              }
            });
            return result;
          }

          checkValue(id, value) {
            let result = false;
            id = normalizeString(id);

            if ($J.typeOf(value) === 'string') {
              value = value.trim();
            }

            if (this.schema.hasOwnProperty(id)) {
              globalValue = value;

              if (validateParamValue(this.schema[id], value)) {
                result = true;
              }

              globalValue = null;
            }

            return result;
          }

          exists(id) {
            id = normalizeString(id);
            return this.schema.hasOwnProperty(id);
          }

          isset(id) {
            id = normalizeString(id);
            return this.exists(id) && $J.defined(this.options[id]);
          }

          remove(id) {
            id = normalizeString(id);

            if (this.exists(id)) {
              delete this.options[id];
              delete this.schema[id];
            }
          }

        }

        $J.Options = Options;
      })(magicJS);

      return magicJS;
    });
    Sirv.define('globalVariables', ['bHelpers', 'magicJS'], (bHelpers, magicJS) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global $J, $ */

      /* eslint-disable no-lonely-if */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "GLOBAL_VARIABLES" }] */

      const SIRV_PREFIX = 'smv';
      let SIRV_HTTP_PROTOCOL = 'https:';
      let SIRV_ASSETS_URL = '';
      let SIRV_BASE_URL = '';

      const getAbsoluteURL = (() => {
        let a;
        return url => {
          if (!a) a = document.createElement('a');
          a.setAttribute('href', url);
          return ('!!' + a.href).replace('!!', '');
        };
      })();

      const scripts = document.getElementsByTagName('script');

      for (let i = 0, l = scripts.length; i < l; i++) {
        const src = scripts[i].getAttribute('src') || '';
        const isTestJs = scripts[i].getAttribute('data-sirvjs-test') !== null;

        if (isTestJs) {
          SIRV_ASSETS_URL = getAbsoluteURL(src).replace(/([^#?]+)\/.*$/, '$1/');
        } else {
          if (/sirv\.(com|localhost(:\d+)?)\/(([^#?]+)\/)?sirv(_.+)?\.js([?#].*)?$/i.test(src)) {
            SIRV_BASE_URL = getAbsoluteURL(src).replace(/(^https?:\/\/[^/]*).*/, '$1/');
            SIRV_ASSETS_URL = getAbsoluteURL(src).replace(/([^#?]+)\/.*$/, '$1/');

            if (/sirv\.localhost(:\d+)?\/(([^#?]+)\/)?sirv(_.+)?\.js([?#].*)?$/i.test(src)) {
              // dev env on localhost
              SIRV_HTTP_PROTOCOL = 'http:';
            }

            break;
          }
        }
      }

      const GLOBAL_VARIABLES = {
        SIRV_PREFIX: SIRV_PREFIX,
        CSS_RULES_ID: 'sirv-core-css-reset',
        SIRV_BASE_URL,
        CSS_CURSOR_ZOOM_IN: SIRV_PREFIX + '-cursor-zoom-in',
        CSS_CURSOR_FULSCREEN_ALWAYS: SIRV_PREFIX + '-cursor-fullscreen-always',
        // eslint-disable-next-line
        REG_URL_QUERY_STRING: /([^\?]+)\??([^\?]+)?/,
        FULLSCREEN_VIEWERS_IDs_ARRAY: [],
        CUSTOM_DEPENDENCIES: null,
        MIN_RATIO: 1.2,
        SIRV_HTTP_PROTOCOL,
        SIRV_ASSETS_URL,

        /**
         * slideShownBy
         * 0 - state of hiden slide
         * 1 - slider wants the slide
         * 2 - custumer wants the slide
         * 3 - first slide
         * 4 - disable or enable slide
         */
        SLIDE_SHOWN_BY: {
          NONE: 0,
          AUTOPLAY: 1,
          USER: 2,
          INIT: 3,
          ENABLE: 4
        },
        VIDEO: {
          NONE: 0,
          PLAY: 1,
          PAUSE: 2,
          PLAYING: 3
        },
        FULLSCREEN: {
          CLOSED: 0,
          OPENING: 1,
          OPENED: 2,
          CLOSING: 3
        },
        APPEARANCE: {
          HIDDEN: 0,
          SHOWING: 1,
          SHOWN: 2,
          HIDING: 3
        },
        SLIDE: {
          TYPES: {
            NONE: 0,
            HTML: 1,
            IMAGE: 2,
            PANZOOM: 3,
            ZOOM: 4,
            SPIN: 5,
            VIDEO: 6
          },
          NAMES: ['none', 'html', 'image', 'panzoom', 'zoom', 'spin', 'video']
        }
      };
      return GLOBAL_VARIABLES;
    });
    Sirv.define('globalFunctions', ['bHelpers', 'magicJS', 'globalVariables', 'helper'], (bHelpers, magicJS, globalVariables, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global $ */

      /* global $J */

      /* global globalVariables */

      /* global helper */

      /* eslint-disable no-restricted-syntax */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint-disable no-unused-vars */
      // const SIRV_CSS = {
      //     src: 'viewer.css',
      //     state: -1
      // };

      const fileCache = {};

      const loadJSFile = (src, parent) => {
        return new Promise((resolve, reject) => {
          const script = $J.$new('script');
          script.attr('type', 'text/javascript');
          script.node.onload = resolve;
          script.node.onerror = reject;
          script.attr('src', src);
          script.appendTo(parent || $J.D.node.head);
        });
      };

      const adjustURLProto = url => {
        let result = url.replace(/^(https?:)?/, 'https:');

        if (/^(http(s)?:)?\/\/[^/]+?sirv\.localhost(:\d+)?\/.*$/i.test(url)) {
          // dev env on localhost
          result = url.replace(/^(https?:)?/, 'http:');
        }

        return result;
      };

      const sanitizeURLComponent = str => {
        try {
          str = decodeURIComponent(str);
        } catch (ex) {
          /* empty */
        }

        return encodeURIComponent(str);
      };

      const sanitizeURL = url => {
        return url.replace(/^((?:https?:)?\/\/)([^/].*)/, function (match, proto, uri) {
          return proto + uri.split('/').map(function (str, index) {
            if (index === 0) {
              return str;
            }

            return sanitizeURLComponent(str);
          }).join('/');
        });
      };

      class RootDOM {
        constructor() {
          this.CSSMap = {};
          this.sirvNodesMap = new WeakMap();
          this.rootNodesMap = new Map();
          this.rootNodes = []; // ie11 does not support this.rootNodesCollection.keys()

          this.sirvCSSSrc = 'viewer.css';
          this.mainCSSID = 'sirv-stylesheet-sirv';
        }

        static getShadowDOM(node
        /* Element which has 'Sirv' class name */
        ) {
          node = $(node).node;
          let result = false;
          const parent = node.parentNode;

          if (parent && window.ShadowRoot) {
            if (parent instanceof window.ShadowRoot) {
              result = parent;
            } else {
              result = RootDOM.getShadowDOM(parent);
            }
          }

          return result;
        }

        rootContains(node) {
          return this.rootNodes.some(root => {
            if (root === $J.D.node) {
              root = $J.D.node.body;
            }

            if (root) {
              return root.contains(node);
            }

            return false;
          });
        }

        addModuleCSSByName(moduleName, functionOfCssString, id, position) {
          if (!this.CSSMap[moduleName]) {
            this.CSSMap[moduleName] = {
              functionOfCssString: functionOfCssString,
              id: id,
              position: position
            };
          }
        }

        getRootNode(node
        /* Element which has 'Sirv' class name */
        ) {
          node = $(node).node;
          const shadowDOM = RootDOM.getShadowDOM(node);
          const rootNode = shadowDOM || $J.D.node;

          if (!this.rootNodesMap.has(rootNode)) {
            this.rootNodesMap.set(rootNode, {
              isResetCSSAdded: false,
              isVideoCSSAdded: false,
              isSirvAdAdded: false,
              styles: {},
              modulesCss: {},
              isShadowDOM: !!shadowDOM
            });
            this.rootNodes.push(rootNode);
          }

          return rootNode;
        }
        /*
            Attach node to root node
        */


        attachNode(node
        /* Element which has 'Sirv' class name */
        ) {
          node = $(node).node;

          if (!this.sirvNodesMap.has(node)) {
            const rootNode = this.getRootNode(node);
            this.sirvNodesMap.set(node, rootNode);
          }
        }
        /*
            Detach node from root node
        */


        detachNode(node
        /* Element which has 'Sirv' class name */
        ) {
          node = $(node).node;
          return this.sirvNodesMap.delete(node);
        }

        addCSSStringToHtml() {
          this.addCSSString($J.D.node.head || $J.D.node.body);
        }

        addCSSString(node
        /* Element which has 'Sirv' class name */
        ) {
          if (!node) {
            node = $J.D.node.head || $J.D.node.body;
          }

          node = $(node).node;
          const root = this.sirvNodesMap.get(node);
          const rootObject = this.rootNodesMap.get(root);
          let shadowRoot = null;

          if (rootObject.isShadowDOM) {
            shadowRoot = root;
          }

          Object.entries(this.CSSMap).forEach(([cssmapKey, cssmapValue]) => {
            if (!rootObject.modulesCss[cssmapKey]) {
              rootObject.modulesCss[cssmapKey] = 1;
              helper.addCss(cssmapValue.functionOfCssString(), cssmapValue.id, cssmapValue.position, shadowRoot, '#' + this.mainCSSID);
            }
          });
        }

        addMainStyleToHtml() {
          this.resetGlobalCSS($J.D.node.head || $J.D.node.body);
          this.addStyle($J.D.node.head || $J.D.node.body, globalVariables.SIRV_ASSETS_URL + this.sirvCSSSrc, this.mainCSSID, '#' + globalVariables.CSS_RULES_ID);
        }

        addMainStyle(node
        /* Element which has 'Sirv' class name */
        ) {
          this.addMainStyleToHtml();
          this.resetGlobalCSS(node);
          return this.addStyle(node, globalVariables.SIRV_ASSETS_URL + this.sirvCSSSrc, this.mainCSSID, '#' + globalVariables.CSS_RULES_ID);
        }

        addStyle(node
        /* Element which has 'Sirv' class name */
        , url, id, querySelector) {
          node = $(node).node;
          const root = this.sirvNodesMap.get(node);
          const rootObject = this.rootNodesMap.get(root);

          if (!rootObject.styles[id]) {
            rootObject.styles[id] = new Promise((resolve, reject) => {
              let _shadowRoot = null;

              if (rootObject.isShadowDOM) {
                _shadowRoot = root;
              }

              helper.loadStylesheet(url, id, _shadowRoot, querySelector).then(resolve).catch(reject);
            });
          }

          return rootObject.styles[id];
        }

        resetGlobalCSS(node
        /* Element which has 'Sirv' class name */
        ) {
          if (!node) {
            node = $J.D.node.head || $J.D.node.body;
          }

          node = $(node).node;
          const root = this.sirvNodesMap.get(node);
          const rootObject = this.rootNodesMap.get(root);

          if (rootObject.isResetCSSAdded) {
            return;
          }

          rootObject.isResetCSSAdded = true;
          let shadowRoot = null;

          if (rootObject.isShadowDOM) {
            shadowRoot = root;
          }

          $J.addCSS('.smv', {
            display: 'flex !important'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.smv.smv-selectors-top', {
            'flex-direction': 'column-reverse'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.smv.smv-selectors-left', {
            'flex-direction': 'row-reverse'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.smv.smv-selectors-right', {
            'flex-direction': 'row'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.smv.smv-selectors-bottom', {
            'flex-direction': 'column'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.smv-slides-box', {
            'flex-grow': 1,
            'flex-shrink': 1
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('figure > .Sirv', {
            'vertical-align': 'top'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv > iframe, .Sirv > video', {
            'display': 'none'
          }, globalVariables.CSS_RULES_ID, shadowRoot); // Hide custom thumbnail content until the viewer initialized.

          $J.addCSS(':not(.smv) smv-thumbnail', {
            'display': 'none'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv, .Sirv .smv-component', {
            '-webkit-box-sizing': 'border-box !important',
            '-moz-box-sizing': 'border-box !important',
            'box-sizing': 'border-box !important'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('div.Sirv, div.Sirv div.smv-component, figure.Sirv, div.smv-component', {
            width: '100%',
            height: '100%',
            margin: 0,
            'text-align': 'center'
          }, globalVariables.CSS_RULES_ID, shadowRoot); // It was added in 'fix video empty height' commit
          // I do not know why I added it, but it break Sirv if block where Sirv is has height. See test/zoom-test.html
          // $J.addCSS('div.Sirv', {
          //     'block-size': 'auto'
          // }, globalVariables.CSS_RULES_ID, shadowRoot);

          $J.addCSS('div.Sirv', {
            'max-height': '100%',
            'block-size': 'inherit'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv img', {
            'width': '100%',
            'height': '100%'
          }, globalVariables.CSS_RULES_ID, shadowRoot); // ResponsiveImage

          $J.addCSS('img.Sirv, .Sirv img', {
            'max-width': '100%'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('img.Sirv:not([width]):not([height])', {
            'width': '100%'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('img.Sirv', {
            'display': 'inline-block',
            'font-size': 0,
            'line-height': 0
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv.smv-bg-image.smv-bg-contain, .Sirv.smv-bg-image.smv-bg-cover', {
            'background-repeat': 'no-repeat',
            'background-position': 'center'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv.smv-bg-image.smv-bg-contain', {
            'background-size': 'contain'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('.Sirv.smv-bg-image.smv-bg-cover', {
            'background-size': 'cover'
          }, globalVariables.CSS_RULES_ID, shadowRoot); // $J.addCSS('img.Sirv[width], .Sirv img[width], img.Sirv[height], .Sirv img[height]', {
          //     'max-width': 'none'
          // }, globalVariables.CSS_RULES_ID, shadowRoot);

          $J.addCSS('img.Sirv:not([src]), img.Sirv.sirv-image-loading:not([src])', {
            'opacity': '0' // 'transition': 'opacity 0.5s linear'

          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('img.Sirv.sirv-image-loaded', {
            'opacity': '1',
            'transition': 'opacity 0.5s linear'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
        }

        showSirvAd(node
        /* Element which has 'Sirv' class name */
        , targetNode, landing, desc) {
          if (/^my.sirv.(com|localhost)$/i.test($J.D.node.location.hostname)) {
            // do not show Ad inside web app
            return;
          }

          if (!node) {
            node = $J.D.node.head || $J.D.node.body;
          }

          node = $(node).node;
          const root = this.sirvNodesMap.get(node);
          const rootObject = this.rootNodesMap.get(root);
          let shadowRoot = null;

          if (rootObject.isShadowDOM) {
            shadowRoot = root;
          }

          const crId = 'sirvCR' + Math.floor(Math.random() * +new Date());
          const BRAND_LOGO = {
            width: 90,
            height: 18,
            src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAAkCAYAAAAgqxBxAAAMJ0lEQVR4nO1ce5AUxRnv4yH4wCfREogIqFHOI94uVoSNMnFvZ6e/30+TGB/BRFPRUomWRiMKd2tUTKEWKlGSCBKCxtJSSKkxKLhnKqaiJvgOYjSAAhdQ8EDkIYgm8fLH9hzNZGZn9+68o8r5VU3V7fbXX389+5vu79FzSiVIkCBBggQJegiu6w4DMIlkkeRKklsBbCG5EsAzJKeJyCnldDiOs5/neaO6y+YECUJBciaAz0i2xV0AFmut+wV1iMhoAK1GZqnjOAN7Yi4JvsDQWu9PckkIaTcBWAbgHZI7Am1vKqV6BXUBWBzQ87MemFKCLzJIvhIg671a63Gu6+7ryziOMxBAA4DpADYDuDRC14qArl9130wSfOEhIpcFCPjduD75fP5gx3H2C2sDcJal62MAx3W91QkShKMGwDqL0DO7QimAsQAubGhoOKIr9CVIUBHy+XxtYHUe3tM2JUjQYWitT7PI/EFP25MgQadA8kxrhd7mOE6fnrYpk8kMEJHRnud9padtSRADkm0NDQ0HRLU3NDQcAWBzd9njed7XbZdDa31SZ3WKSB2AR80133GcA+1213W/bLXf5H+fzWYPATAHwAdmx1jjt+Xz+YMBPALgIZIPxxV2gkhNLp6TamqeV18oPlxfKM7p7BwTGOxphM5kMgNI/tdyO57urE7bjTHXYLsdwHFW2/umz5BAcNoGYIvfx3GcPradJP9cjU2pQnFdqtDclio0t9UXis93do4JDPY0QiulFIB7AkS6Kb5XNLTWp1r6Pslms4fZ7SQHW+RcaL5bGXgI/gNgmVKqxu8nIj+xZTKZzIBK7Plq45PH+GROFZrbUpOL6c7ML4GFPZHQjuMcCODfAUI9lsvlBnVEXxyhXdc9lOQnfgGHZKP1MP0GwNhcLjcon88frqxKZD6fPzzgHp1TiT31heYpu1bn5tWVTqKfiAw1N6EmTh7AQQCGl/txuwqmwjU87NxBEFrrfp7nHWl+hOA8anK53CARGVpB8FRDcrCIDLXHrZbQ/n0123bsfe0oAJwccl5jB8lpWush1eiKI3Q2mz3EKqOvB7DTkPkHFdj5nKV7QSX2pJqKS9tX56ZiIcrokQCeBnAQybnGsKUAVgFYJyITwvp5npcl+aI5vLKE5EZzyCVjGV0AMCOsP8lbSD4c0fZrABf6n0UkZ8ZoIfmqGWt2Op3ex+4H4HXHcfqIyDUkN5JcYUq7x1kyFwNYTfKfJJcAaAXQpEJIJiJXkHwXwCqSb5B8n+TMdDq9D4CdlRDacZz9ANxN8n1zX1cDeE9ErvLHBPAQgO9H6TIrWktwvlEwxZDWEGJ/AuC+Sit+cYQ2nNkecHNmVaKb5EVWn521tbV7lZOvb1w40nY3aictCC/0iEgdyQ0A/iIil6TT6b5W2wkkV4jINYE+3zE/rqhdROhtSqUbtNauUu2Rd0vIsDWGVOtDyq41ANb5qR6t9bcArNFaj/MFMpnMAADzADxlja9ItgC4EsDvABwUHBTATwG8TPJo/zsTxLwAYGpAdgrJN0Skzv/OcZz+ACaSXEByaxyhzcOwSEQm2DuByR68TvIW8/lsAM9E6SJ5LYD7otrDYDINs0JI7V932b91GCohNICPLJntjuP0r9S+atyOVFOx0O5uNBWfixQ0hG4jeWNYu+d5o0hu9yeTTqf3IblRa31qmDzJMwGsMU9cbwCbXdc91pbRWmdIPgtgnoicbbcBON5/CMzq1gpgbHAcQ67V/sNjxm4B8HrY0661HklyY/BHMfdgKMkdxtdTnucdSXK71npE2ByNvxjrcvjEidAxnOQO13WH1dbW7kVyg+u6wyJk3wRwctRY5SAiJwCYjdI56OAJvGX5fL42qm+1hAYwrxrbAPze6ju/nGyqqfiWRegLyk24zvw4kbV6AM8DuMDIjwfwUoyhy0WE5u/5InJFYMw7jVtwUdDtMCvsHCN3HoDIpxHA7SR/6X82hL48Yp53AvhFGV3NvptjVuHHomSNu1URoT3PO7HMmE8AmGj+niEiNwRltNYnAViuOul3mxXxRpJbg25I1IPbAUJfXY1NZqdvLwZFxUappkWjdvnOzZ8edfnC6BjKbH8flRsYwAwA083f0wH8PEZ+Ns3ZWQAXAHjCau4FYC3Jo3O53CAAmwPB1gKYU2IA7gFwa9Q4JC8ybof/uSWqoADghXLbGoC7ReRm8/dDACZFyWaz2cMqJXS5ABbAFN+V0FrXk1ypAsQFMEtEJkfpqBau6x4K4NHASr1GKdU7KNsBQp9RjS2O4/Qnuc3vLyLfDJOzsxuppubyu4Ah9JoYmetI3q+UUiQfjLvBAG4CMFsppXK53CD76UMpCn/Fkn1Oa32aUkql0+m+JpAaaNoeB/ABgHfCLuPHP+vrItli+7wBm9YanzZK14cA7jZ6/ogykbopDlSS5fi43H0yxz3bI3yWAl7H/zxmzJi9WQpuB4cq6AQAzAmQ+sqgTLWE1lrrDtjxgEXo34bJpArFt31CnzB5kVNWoSF0a8yg15Oc6xuAUlagnPxUWIfBAfwdwDfM3zNINlrjX+Xr1lpnALxs9XtcRK4xNy70spPyMYReo7V2y+nyswgA/kTy/Kj5pdPpvhUSeme5+0Tyx7ZrA+ByAPda92Z8YHfrUgBYbhH67WB7tYT23cxqICJeIKjcLY1a11g81vKdy/LUV1gH4NNy+VgAs/3tWERu9lffKARXcZZSdD9TpZzuu7SyDCYgW6+U6iUik20XA6Uo/ZbYSewapxyhXwBwViV6AMwjeW1Uu18YqMTlKJdqA3Cbvyso1e7nbrQerCeq3carQcgLAbsdOe0OQiulFMkPfR2e52XttlSheJuVe55WyaTqSLbl8/lUmQFXWEFeA4BVKuQdNKXat+P1dj5aRE4h+azWuh7AayH6X/Q870SSf7AnJCLjSb4aO4ldeiIJTXKaH2zGwQSskUEhAFThQ4+LkgHwkoicF/huvoic6zjOQJLvxuVnOwOTlrVTZ67d3l2ENjFXqNtR3/TUivYVunHhyEomVYfS28FzI9rPBbDayln2YqkgEfoeGoBJxm1oD27MFr3e+OKNwT4s5VmvN25BexA1ZsyYvY3v+73YiajyhNZajzC+fH2cHq31EJJbtdahNxDAkwA+q4TQiEhHkRSSG4N5eK21NoHxpSTviLO1MzDpSTvjIQFbuoXQIvI1a5wdjqPavYX6QnGOIXRlC5sh9FIAj5C8S0SOUUrVmGN+l7JUKBkX7GMIeoPrusPS6XTffD5/FIBbAaxFSCUKpWLHWtvd8GH6rgWwKNhm/OpWAFO01iMcx+njOE5/z/NGAZgoIqN92XKENnb/EECriEwwgVZNJpMZYFJjU13XPdSSnQBgDYAzDOl6marqAyYF+I8KfOjnSc4FMMcUino1NDQcgFLmp9UPhgPobYLUJQCOj9LfFRCR0Tahg7t0dxHa6HrP13O6m835348qPHNSqtDclmpsjnQBg5OqA7DKlIyvMpH2BgDvoVT4iFrxhgCYhVIpd5MJMO7yixNBkPw2ylS7ANwXtRKb1W4mgOVmrLUk/yoi12mtv2SN8WBUccIaJ43SWdwWAJtYKqcXReSyYIoNQN6sxuvMQ7UYpkRtHoB9w0cppcdMhbWGpfTiYuu+PgIg8qQYgNsBLC43j64AgIJF2K3BymE3E/rWMLfjsInFfeubiu+OaipW9nCb1TasPJ2ghwDgSRG55PMcw8Q6G6yA8N6gTHcS2vbnAWyy21JNi0aps+b/X548SlFC6D0IxlXZorXev5p+psQ93XabomCyKX8LuBtHBeW6k9BG37JdAaoberQiFgmh9yyQvCMuLRoGa8veZty38wEcr7XeX2vdz8REYwFMZalYY6frQkvW3U1olkrzJZt4etX3QCmVEHpPgO+7m8LP5rDAOQ4mHgg7VbeVpYrq9rB2BE4ZBuw61ZL7NO74aGcJ7bruMGu8dR1SkhC654HSwagtJP8F4PSO6NBanwbg6QhSh12vRGRZdtMZ6LNbCd7kytssQo/viO02ALy5y+1gWfui0Ls73jZJEIvKgp4YaK1HAPgRyftReivkDZJvAXgNwFMicnOlb1obf34igKsBXBmsejqO019ErjAyE9EF/9wGwMVmV9nGzzkPnyBBggQJugP/A94x91x//ZrKAAAAAElFTkSuQmCC'
          };
          $J.addCSS('#' + crId, {
            display: 'inline-block !important;',
            visibility: 'visible !important;',
            'z-index': '2147483647 !important;',
            width: 'auto !important;',
            height: 'auto !important;',
            'max-width': 'none !important;',
            'max-height': 'none !important;',
            transform: 'none !important;',
            left: 'auto !important;',
            top: 'auto !important;',
            bottom: '8 !important;',
            right: '8 !important;',
            margin: 'auto !important',
            padding: '0 !important',
            opacity: '1 !important;'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          $J.addCSS('#crSirv' + crId + ' > img', {
            display: 'inline-block !important;',
            visibility: 'visible !important;',
            position: 'static !important;',
            width: '90px !important;',
            height: '18px !important;',
            'max-width': 'none !important;',
            'max-height': 'none !important;',
            transform: 'none !important;',
            margin: '0 !important',
            padding: '0 !important'
          }, globalVariables.CSS_RULES_ID, shadowRoot);
          const el = $J.$new('a', {
            id: crId,
            href: landing,
            target: '_blank'
          });
          el.attr('style', 'position: absolute !important; opacity: 1 !important');
          el.setCss({
            display: 'inline-block',
            overflow: 'hidden',
            visibility: 'visible',
            'font-size': 0,
            'font-weight': 'normal',
            'font-family': 'sans-serif',
            bottom: 8,
            right: 8,
            margin: 'auto',
            width: 'auto',
            height: 'auto',
            transform: 'none',
            'z-index': 2147483647
          }).appendTo(targetNode).addEvent(['tap', 'btnclick'], e => {
            e.stopDistribution();
            $J.W.node.open(el.attr('href'));
          }).append($J.$new('img', BRAND_LOGO).setProps({
            alt: desc
          }));
        }

      }

      const rootDOM = new RootDOM();
      const GLOBAL_FUNCTIONS = {
        rootDOM,
        loadJsFile: (src, parent) => {
          if (!fileCache[src]) {
            fileCache[src] = loadJSFile(src, parent);
          }

          return fileCache[src];
        },
        loadCssFile: (rootNode, src, id, stylesheet) => {
          if (!fileCache[src]) {
            fileCache[src] = rootDOM.addStyle(rootNode, src, id, stylesheet);
          }

          return fileCache[src];
        },
        viewerFilters: [],
        getNodeWithSirvClassName: node => {
          let result = null;

          if (node) {
            node = $(node);

            if (node.hasClass('Sirv')) {
              result = node.node;
            } else {
              result = GLOBAL_FUNCTIONS.getNodeWithSirvClassName(node.node.parentNode);
            }
          }

          return result;
        },
        iconsHash: {
          nodes: [],
          elements: [[{
            classes: ['smv-arrow-control']
          }, {
            classes: ['smv-arrow']
          }, {
            classes: ['smv-icon']
          }], [{
            classes: ['smv-button-fullscreen-open']
          }, {
            classes: ['smv-icon']
          }], [{
            classes: ['smv-button-fullscreen-close']
          }, {
            classes: ['smv-icon']
          }], [{
            classes: ['smv-thumbnails']
          }, {
            classes: ['smv-selector'],
            attrs: [{
              name: 'data-type',
              value: 'spin'
            }]
          }]],
          waitBody: () => {
            return new Promise((resolve, reject) => {
              const body = document.body;

              if (body) {
                resolve(body);
              } else {
                setTimeout(function () {
                  GLOBAL_FUNCTIONS.iconsHash.waitBody().then(resolve);
                }, 16);
              }
            });
          },
          make: () => {
            GLOBAL_FUNCTIONS.iconsHash.elements.forEach(data => {
              const elements = [];
              data.reverse().forEach(el => {
                const node = $J.$new('div');

                if (el.classes) {
                  el.classes.forEach(className => {
                    node.addClass(className);
                  });
                }

                if (el.attrs) {
                  el.attrs.forEach(attr => {
                    node.attr(attr.name, attr.value);
                  });
                }

                elements.push(node);
              });

              for (let i = 1, l = elements.length; i < l; i++) {
                elements[i].append(elements[i - 1]);
              }

              GLOBAL_FUNCTIONS.iconsHash.nodes.push(elements[elements.length - 1]);
            });
            GLOBAL_FUNCTIONS.iconsHash.nodes.forEach(el => {
              el.setCss({
                top: '-10000px',
                left: '-10000px',
                width: '10px',
                height: '10px',
                position: 'absolute',
                visibility: 'hodden',
                opacity: 0
              });
              GLOBAL_FUNCTIONS.iconsHash.waitBody().finally(() => {
                $J.$($J.D.node.body).append(el);
              });
            });
          },
          remove: () => {
            if (GLOBAL_FUNCTIONS.iconsHash.nodes.length) {
              GLOBAL_FUNCTIONS.iconsHash.nodes.forEach(el => {
                el.remove();
              });
              GLOBAL_FUNCTIONS.iconsHash.nodes = [];
            }
          }
        },
        adjustURL: url => {
          if (!/^(http(s)?:)?\/\//.test(url)) {
            url = globalVariables.SIRV_BASE_URL + url;
          }

          return adjustURLProto(url).replace(/([^:])\/+/g, '$1/');
        },

        normalizeURL(url) {
          return sanitizeURL(adjustURLProto(url));
        }

      };
      GLOBAL_FUNCTIONS.rootDOM.attachNode($J.D.node.head || $J.D.node.body);
      return GLOBAL_FUNCTIONS;
    });
    Sirv.define('helper', ['bHelpers', 'magicJS', 'globalVariables'], (bHelpers, magicJS, globalVariables) => {
      const $J = magicJS;
      const $ = $J.$;
      const helper = {};
      /* global $J, helper */

      /* eslint-env es6 */

      class WaitToStart {
        constructor() {
          this.started = false;
          this.callbacks = [];
        }

        wait(cb) {
          if (this.started) {
            cb();
          } else {
            this.callbacks.push(cb);
          }
        }

        start() {
          if (!this.started) {
            this.started = true;
            this.callbacks.forEach(cb => cb());
          }
        }

        destroy() {
          this.callbacks = [];
        }

      }

      helper.WaitToStart = WaitToStart;
      /* global $J, helper */

      /* eslint-env es6 */
      // helper.addCss = (css, id, position) => {
      //     if (!position) { position = 'top'; }
      //     const stl = $J.$new('style', { id: (id || 'sirv-module-' + helper.generateUUID()), type: 'text/css' }).appendTo((document.head || document.body), position);
      //     stl.node.innerHTML = css;
      //     return stl;
      // };

      helper.addCss = (css, id, position, root, selector) => {
        let rootNode = document.head || document.body;
        const stl = $J.$new('style', {
          type: 'text/css'
        });
        stl.attr('id', id || 'sirv-module-' + stl.$J_UUID);

        if (!position) {
          position = 'top';
        }

        if (root) {
          rootNode = $(root).node || root;
        }

        let nextSibling;

        if (position === 'top') {
          nextSibling = rootNode.firstChild;
        }

        const addAfter = rootNode.querySelector(selector);

        if (addAfter && addAfter.nextSibling) {
          nextSibling = addAfter.nextSibling;
        }

        rootNode.insertBefore(stl.node, nextSibling);
        stl.node.innerHTML = css;
        return stl;
      };
      /* eslint-env es6 */

      /* global helper */


      helper.cleanQueryString = str => {
        str = str.replace(/&+/g, '&');
        str = str.replace(/&$/, '');
        str = str.replace(/\?&/, '?');
        str = str.replace(/profile=&|profile=$/g, '');
        str = str.replace(/image=&/g, 'image&');
        str = str.replace(/image=$/g, 'image');
        return str;
      };
      /* eslint-env es6 */

      /* global helper */


      helper.createReadOnlyProp = (obj, name, value) => {
        Object.defineProperty(obj, name, {
          value: value,
          writable: false
        });
      };
      /* global $J, helper */

      /* eslint-env es6 */
      // Returns if a value is an object


      const isObject = value => {
        return value && typeof value === 'object' && value.constructor === Object;
      };
      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked, or until the next browser frame is drawn. The debounced function
       * comes with a `cancel` method to cancel delayed `func` invocations and a
       * `flush` method to immediately invoke them. Provide `options` to indicate
       * whether `func` should be invoked on the leading and/or trailing edge of the
       * `wait` timeout. The `func` is invoked with the last arguments provided to the
       * debounced function. Subsequent calls to the debounced function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
       * invocation will be deferred until the next frame is drawn (typically about
       * 16ms).
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `debounce` and `throttle`.
       *
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0]
       *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is
       *  used (if available).
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', debounce(calculateLayout, 150))
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }))
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })
       * const source = new EventSource('/stream')
       * jQuery(source).on('message', debounced)
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel)
       *
       * // Check for pending invocations.
       * const status = debounced.pending() ? "Pending..." : "Ready"
       */


      helper.debounce = (func, wait, options) => {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
        // const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function');

        const useRAF = !wait && wait !== 0 && $J.browser.features.requestAnimationFrame;

        if (typeof func !== 'function') {
          throw new TypeError('Expected a function');
        }

        wait = +wait || 0;

        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        const invokeFunc = time => {
          const args = lastArgs;
          const thisArg = lastThis;
          lastArgs = $J.U;
          lastThis = lastArgs;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        };

        const startTimer = (pendingFunc, _wait) => {
          if (useRAF) {
            $J.browser.cancelAnimationFrame(timerId);
            return $J.browser.requestAnimationFrame(pendingFunc);
          }

          return setTimeout(pendingFunc, _wait);
        };

        const cancelTimer = id => {
          if (useRAF) {
            $J.browser.cancelAnimationFrame(id);
          } else {
            clearTimeout(id);
          }
        };

        const remainingWait = time => {
          const timeSinceLastCall = time - lastCallTime;
          const timeSinceLastInvoke = time - lastInvokeTime;
          const timeWaiting = wait - timeSinceLastCall;
          return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        };

        const shouldInvoke = time => {
          const timeSinceLastCall = time - lastCallTime;
          const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.

          return lastCallTime === $J.U || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        };

        const trailingEdge = time => {
          timerId = $J.U; // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.

          if (trailing && lastArgs) {
            return invokeFunc(time);
          }

          lastArgs = $J.U;
          lastThis = lastArgs;
          return result;
        };

        const timerExpired = () => {
          const time = Date.now();

          if (shouldInvoke(time)) {
            return trailingEdge(time);
          } // Restart the timer.


          timerId = startTimer(timerExpired, remainingWait(time));
          return $J.U;
        };

        const leadingEdge = time => {
          // Reset any `maxWait` timer.
          lastInvokeTime = time; // Start the timer for the trailing edge.

          timerId = startTimer(timerExpired, wait); // Invoke the leading edge.

          return leading ? invokeFunc(time) : result;
        };

        const cancel = () => {
          if (timerId !== $J.U) {
            cancelTimer(timerId);
          }

          lastInvokeTime = 0;
          lastArgs = $J.U;
          lastCallTime = lastArgs;
          lastThis = lastArgs;
          timerId = lastArgs;
        };

        const flush = () => {
          return timerId === $J.U ? result : trailingEdge(Date.now());
        };

        const pending = () => {
          return timerId !== $J.U;
        };

        const debounced = (...args) => {
          const time = Date.now();
          const isInvoking = shouldInvoke(time);
          lastArgs = args;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === $J.U) {
              return leadingEdge(lastCallTime);
            }

            if (maxing) {
              // Handle invocations in a tight loop.
              timerId = startTimer(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }

          if (timerId === $J.U) {
            timerId = startTimer(timerExpired, wait);
          }

          return result;
        };

        debounced.cancel = cancel;
        debounced.flush = flush;
        debounced.pending = pending;
        return debounced;
      };
      /* global $, $J, helper */

      /* eslint-env es6 */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */


      helper.deepExtend = (() => {
        const extend = (extendingObject, source) => {
          const type = $J.typeOf(source);

          if (!$J.defined(extendingObject)) {
            if (type === 'array') {
              extendingObject = [];
            } else {
              extendingObject = {};
            }
          }

          if (type === 'array') {
            source.forEach((value, index) => {
              const _type = $J.typeOf(value);

              if (_type === 'array' && $J.typeOf(extendingObject[index]) === 'array' || _type === 'object' && $J.typeOf(extendingObject[index]) === 'object') {
                extendingObject[index] = extend(extendingObject[index], value);
              } else {
                extendingObject.push(value);
              }
            });
          } else {
            Object.entries(source).forEach(([key, value]) => {
              const _type = $J.typeOf(value);

              if (_type === 'array' || _type === 'object') {
                extendingObject[key] = extend(extendingObject[key], value);
              } else {
                extendingObject[key] = value;
              }
            });
          }

          return extendingObject;
        };

        return (...args) => {
          let result = null;

          if (args && args.length) {
            result = args.shift();
            args.forEach(value => {
              const _type = $J.typeOf(value);

              if (_type === 'array' || _type === 'object') {
                result = extend(result, value);
              }
            });
          }

          return result;
        };
      })();
      /* global $J, helper */

      /* eslint-env es6 */


      helper.fixSize = (node, size) => {
        node = $(node);

        const checkAuto = (_node, side) => {
          return _node.attr(side) === 'auto';
        };

        const correctSizeValue = value => {
          if (value <= 4) {
            value = 0;
          }

          return value;
        };

        ['width', 'height'].forEach(side => {
          if ($J.browser.ieMode && !node.attr('src')) {
            if (checkAuto(node, side)) {
              size[side] = 0;
            }
          }

          if (size[side] === 0) {
            // check "width" / "height" attribute
            size[side] = helper.imageLib.getPartSize(node, side);
          }

          size[side] = correctSizeValue(size[side]);
        });
        return size;
      };
      /* global $J, helper */

      /* eslint-env es6 */


      helper.generateUUID = () => {
        return parseInt(Math.random() * 10000000, 10);
      };
      /* global helper */

      /* eslint-env es6 */


      helper.getArrayIndex = (index, length) => {
        index %= length;

        if (index < 0) {
          index += length;
        }

        return index;
      };
      /* global $J, helper */

      /* eslint-env es6 */


      helper.getDPPX = (value, maxValue, upscale) => {
        let result = maxValue / value;
        const count = 100;

        if (result >= $J.DPPX || upscale) {
          result = $J.DPPX;
        } else {
          result *= count;
          result = Math.ceil(result) / count;
        }

        return result;
      };
      /* global helper */

      /* global $ */

      /* eslint-env es6 */


      helper.getMatrix = node => {
        let result = null;
        let matrix = $(node).getCss('transform') + '';

        const getNumber = str => {
          return parseFloat(str.trim());
        };

        const getTrObj = (arrIndexes, arr) => {
          const _result = {};
          const axises = ['x', 'y', 'z'];
          arrIndexes.forEach(function (v, i) {
            _result[axises[i]] = getNumber(arr[v]);
          });
          return _result;
        };

        if (matrix !== 'none') {
          result = {};
          matrix = matrix.split('(')[1];
          matrix = matrix.split(')')[0];
          matrix = matrix.split(',');
          const is3D = matrix.length > 6;
          result.transform = getTrObj(is3D ? [12, 13, 14] : [4, 5], matrix);
          result.scale = getTrObj(is3D ? [0, 5, 10] : [0, 3], matrix);
        }

        return result;
      };
      /* global $J, helper, Promise */

      /* eslint no-throw-literal: "off" */

      /* eslint-env es6 */


      helper.getRemoteData = (() => {
        const __XMLHttpRequest = url => {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            if (xhr) {
              xhr.onerror = e => {
                reject(e || true);
              };

              xhr.onload = e => {
                try {
                  if (xhr.status === 200) {
                    const value = JSON.parse(xhr.responseText);
                    resolve(value);
                  } else {
                    throw {
                      status: xhr.status,
                      data: e
                    };
                  }
                } catch (_err) {
                  reject(_err);
                }
              };

              xhr.open('GET', url);

              if (undefined !== xhr.responseType) {
                xhr.responseType = 'text';
              }

              xhr.send(null);
            } else {
              reject(true);
            }
          });
        };

        const getByFetch = (url, referrerPolicy) => {
          return fetch(url, {
            referrerPolicy: referrerPolicy || 'no-referrer-when-downgrade'
          }).then(response => {
            if (response.status === 200) {
              return response.json();
            }

            throw {
              status: response.status,
              data: response
            };
          });
        };

        const getData = window.fetch ? getByFetch : __XMLHttpRequest;

        const __jsonp = (url, callbackName) => {
          return new Promise((resolve, reject) => {
            let scriptOk = false;
            const script = document.createElement('script');

            if (!window[callbackName]) {
              window[callbackName] = (...args) => {
                scriptOk = true;
                delete window[callbackName];
                document.body.removeChild(script);
                resolve(args[0]);
              };
            }

            const checkCallback = () => {
              if (scriptOk) return;
              delete window[callbackName];
              document.body.removeChild(script);
              reject(url);
            };

            script.onreadystatechange = () => {
              if (this.readyState === 'complete' || this.readyState === 'loaded') {
                this.onreadystatechange = null;
                setTimeout(checkCallback, 0);
              }
            };

            script.onerror = checkCallback;
            script.onload = checkCallback;
            script.src = url + '&callback=' + callbackName;
            document.body.appendChild(script);
          });
        };

        return (url, callbackName
        /* for jsonp */
        , referrerPolicy) => {
          return new Promise((resolve, reject) => {
            getData(url, referrerPolicy).then(resolve).catch(err => {
              if (err && err.status && [404, 200].includes(err.status)) {
                reject(err);
              } else {
                // eslint-disable-next-line no-console
                console.log('XHR error. Switching to JSONP.');

                if (!callbackName) {
                  callbackName = 'sirv_data_' + helper.generateUUID();
                }

                __jsonp(url, callbackName).then(resolve).catch(reject);
              }
            });
          });
        };
      })();
      /* global helper */

      /* global $ */

      /* eslint-env es6 */


      helper.getSirvType = (() => {
        const isNotEmptyString = str => {
          let result = false;

          if (str) {
            str += '';
            result = str.trim() !== '';
          }

          return result;
        };

        return node => {
          node = $(node);
          let tmp = node.attr('data-type') || node.attr('data-effect');
          const viewContent = node.fetch('view-content');
          let result = null;
          let componentType;
          let imgSrc;

          if (isNotEmptyString(tmp) && tmp !== 'static') {
            const index = globalVariables.SLIDE.NAMES.indexOf(tmp);
            componentType = index >= 0 ? index : globalVariables.SLIDE.TYPES.ZOOM;
            tmp = node.attr('data-src');

            if (isNotEmptyString(tmp)) {
              imgSrc = tmp;
            } else {
              tmp = $(node.node.getElementsByTagName('img')[0]);

              if (tmp.attr) {
                imgSrc = tmp.attr('src') || tmp.attr('data-src');
              }
            }
          } else {
            tmp = node.attr('data-src');

            if (isNotEmptyString(tmp)) {
              if (helper.isSpin(tmp) && node.tagName !== 'img' || viewContent === globalVariables.SLIDE.TYPES.SPIN) {
                componentType = globalVariables.SLIDE.TYPES.SPIN;
              } else if (helper.isVideo(tmp)) {
                componentType = globalVariables.SLIDE.TYPES.VIDEO;
              } else {
                componentType = globalVariables.SLIDE.TYPES.IMAGE;

                if (viewContent) {
                  componentType = viewContent;
                }
              }

              imgSrc = tmp;
            } else {
              tmp = node.attr('src');

              if (isNotEmptyString(tmp) && node.tagName === 'img') {
                imgSrc = tmp;
                componentType = globalVariables.SLIDE.TYPES.IMAGE;
              }
            }
          }

          if (componentType) {
            result = {
              type: componentType,
              imgSrc: imgSrc
            };
          }

          return result;
        };
      })();
      /* global $, $J, helper */

      /* eslint-env es6 */


      helper.imageLib = {
        isNumber: value => {
          return /(px|%)$/.test(value);
        },
        getSize: (node, count) => {
          // eslint-disable-next-line
          return new Promise((resolve, reject) => {
            const size = $(node).getInnerSize();

            if (!count) {
              count = 100;
            }

            count -= 1;

            if (!size.width && !size.height && count > 0) {
              setTimeout(() => {
                helper.imageLib.getSize(node, count).then(resolve);
              }, 16);
            } else {
              resolve(size);
            }
          });
        },
        // just for pixels
        getBackgroundValue: value => {
          if (value && /px$/.test(value)) {
            return parseInt(value, 10);
          }

          return null;
        },
        // just for pixels
        getBackgroundSize: node => {
          let result = null;
          let value = $(node).getCss('background-size');

          if (value) {
            value = value.split(',')[0].split(' ');
            const w = helper.imageLib.getBackgroundValue((value[0] || '').trim());
            const h = helper.imageLib.getBackgroundValue((value[1] || '').trim());

            if (w !== null) {
              result = {
                width: w
              };
            }

            if (h !== null) {
              if (!result) {
                result = {};
              }

              result.height = h;
            }
          }

          return result;
        },
        calcProportionalBackgroundSize: (bgSize, infoSize) => {
          const result = {
            width: infoSize.width,
            height: infoSize.height
          };

          if (bgSize.width && infoSize.width > bgSize.width) {
            result.width = bgSize.width;
            result.height = bgSize.width * infoSize.height / infoSize.width;
          }

          if (bgSize.height && infoSize.height > bgSize.height) {
            result.height = bgSize.height;
            result.width = bgSize.height * infoSize.width / infoSize.height;
          }

          return result;
        },
        getBackgroundPositionValue: value => {
          let result;

          switch (value) {
            case 'top':
            case 'left':
              result = 0;
              break;

            case 'center':
              result = 50;
              break;

            case 'right':
            case 'bottom':
              result = 100;
              break;

            default:
              if (helper.imageLib.isNumber(value)) {
                result = parseInt(value, 10);
              } else {
                result = 0;
              }

          }

          return result;
        },
        getBackgroundPosition: node => {
          const x = {
            side: 'left',
            position: 0,
            sign: '%'
          };
          const y = {
            side: 'top',
            position: 0,
            sign: '%'
          };
          let xIndex = 0;
          let yIndex = 1;
          let value = $(node).getCss('background-position');

          if (value) {
            value = value.replace(/important/, '');
            value = value.replace(/!/g, '');
            value = value.trim();
            value = value.replace(/\s+/g, ' ');
            value = value.split(' ');

            if (value.length > 2) {
              xIndex = 1;
              yIndex = 3;

              if (['left', 'right'].includes(value[0])) {
                x.side = value[0];
              }

              if (['top', 'bottom'].includes(value[2])) {
                y.side = value[2];
              }
            }

            x.position = helper.imageLib.getBackgroundPositionValue(value[xIndex]);
            y.position = helper.imageLib.getBackgroundPositionValue(value[yIndex]);

            if (/px$/.test(value[xIndex])) {
              x.sign = 'px';
            }

            if (/px$/.test(value[yIndex])) {
              y.sign = 'px';
            }
          }

          return {
            x: x,
            y: y
          };
        },
        getPartSize: (node, side) => {
          let result = 0;
          let value;

          if ($J.browser.ieMode) {
            value = (node.currentStyle[side] || '0').replace(/px$/, '');
          } else {
            value = (node.getCss(side) || '0').replace(/px$/, '');
          }

          if (isFinite(value)) {
            result = Math.round(parseFloat(value)) - parseFloat(node.getCss('border-top-width') || 0) - parseFloat(node.getCss('border-bottom-width') || 0) - parseFloat(node.getCss('padding-top') || 0) - parseFloat(node.getCss('padding-bottom') || 0);
          }

          return result;
        },
        checkMaxSize: (size, originSize, dppx) => {
          let firstSide;
          let secondSide;

          if (size.width > originSize.width * dppx || size.height > originSize.height * dppx) {
            if (size.width > originSize.width) {
              firstSide = 'width';
              secondSide = 'height';
            } else {
              firstSide = 'height';
              secondSide = 'width';
            }

            size[firstSide] = originSize[firstSide];

            if (size[secondSide]) {
              size[secondSide] = originSize[secondSide];
            }

            size.round = false;
          }

          return size;
        },
        calcImageProportion: (firstSide, secondSide, proportionSize, baseFirstSize) => {
          const prop = proportionSize[secondSide] / proportionSize[firstSide];
          const result = {};
          result[firstSide] = baseFirstSize;
          result[secondSide] = parseInt(prop * result[firstSide], 10);
          return result;
        },
        contain: (imageSize, containerSize) => {
          let result = {
            width: imageSize.width,
            height: imageSize.height
          };

          if (containerSize.width && result.width > containerSize.width) {
            result = helper.imageLib.calcImageProportion('width', 'height', result, containerSize.width);
          }

          if (containerSize.height && result.height > containerSize.height) {
            result = helper.imageLib.calcImageProportion('height', 'width', result, containerSize.height);
          }

          return result;
        },
        cover: (imageSize, containerSize) => {
          let result = {
            width: imageSize.width,
            height: imageSize.height
          };

          if (containerSize.width && result.width < containerSize.width) {
            result = helper.imageLib.calcImageProportion('width', 'height', result, containerSize.width);
          }

          if (containerSize.height && result.height < containerSize.height) {
            result = helper.imageLib.calcImageProportion('height', 'width', result, containerSize.height);
          }

          return result;
        },
        calcProportionSize: (size, originSize, fitSize) => {
          let result = {};
          let w = originSize.width;
          let h = originSize.height;
          const wh = w / h;
          const hw = h / w;

          const setW = () => {
            result.height = size.height;
            result.width = parseInt(wh * size.height, 10);
          };

          const setH = () => {
            result.width = size.width;
            result.height = parseInt(hw * size.width, 10);
          };

          if (size.width > w || size.height > h) {
            if (size.width > w) {
              size.width = w;

              if (size.height) {
                if (size.height > h) {
                  size.height = h;
                } else {
                  setW();
                }
              }
            } else {
              size.height = h;

              if (size.width) {
                if (size.width > w) {
                  size.width = w;
                } else {
                  setH();
                }
              }
            }
          }

          if (size.width || size.height) {
            if (size.width && size.height) {
              // if (Math.abs(size.width / size.height - wh) <= Math.abs(size.height / size.width - hw)) {
              if (size.width / size.height - wh <= size.height / size.width - hw) {
                setH();
              } else {
                setW();
              }
            } else if (!size.width) {
              setW();
            } else {
              setH();
            }
          }

          if (fitSize) {
            if (helper.imageLib.isNumber(fitSize.width) && helper.imageLib.isNumber(fitSize.height)) {
              w = parseInt(fitSize.width, 10);

              if (/%$/.test(fitSize.width)) {
                w = w / 100 * size.width;
              }

              h = parseInt(fitSize.height, 10);

              if (/%$/.test(fitSize.height)) {
                h = h / 100 * size.height;
              }

              if (w < originSize.width / originSize.height * h) {
                result = helper.imageLib.calcImageProportion('width', 'height', originSize, w);
              } else {
                result = helper.imageLib.calcImageProportion('height', 'width', originSize, h);
              }
            } else {
              if (helper.imageLib.isNumber(fitSize.width)) {
                w = parseInt(fitSize.width, 10);

                if (/%$/.test(fitSize.width)) {
                  w = w / 100 * size.width;
                }

                result = helper.imageLib.calcImageProportion('width', 'height', originSize, w);
              }

              if (helper.imageLib.isNumber(fitSize.height)) {
                h = parseInt(fitSize.height, 10);

                if (/%$/.test(fitSize.height)) {
                  h = h / 100 * size.height;
                }

                result = helper.imageLib.calcImageProportion('height', 'width', originSize, h);
              }

              if ([fitSize.width, fitSize.height].includes('initial')) {
                result.width = originSize.width;
                result.height = originSize.height;
              } else if ([fitSize.width, fitSize.height].includes('cover')) {
                result = helper.imageLib.cover(result, size);
              } else if ([fitSize.width, fitSize.height].includes('contain')) {
                result = helper.imageLib.contain(result, size);
              }
            }
          }

          return result;
        }
      };
      /* eslint-env es6 */

      /* global $, $J, helper */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none"}] */

      /* eslint no-empty: "error"*/

      helper.InViewModule = (() => {
        const elementIsShown = node => {
          let result = true;

          if (node.tagName !== 'body') {
            if (node.getCss('display') === 'none') {
              result = false;
            } else {
              result = elementIsShown($(node.node.parentNode));
            }
          }

          return result;
        };

        class Timer {
          constructor() {
            this.timer = null;
            this.started = false;
            this.list = [];
          }

          _startTimer() {
            if (this.list.length) {
              clearTimeout(this.timer);
              this.timer = setTimeout(() => {
                this._check();

                if (this.started) {
                  this._startTimer();
                }
              }, 500);
            }
          }

          _check() {
            this.list.forEach(obj => {
              const isShown = elementIsShown(obj.obj.node);
              const callCB = isShown !== obj.obj.isShown;
              obj.obj.isShown = isShown;

              if (callCB) {
                obj.callback(obj.obj);
              }
            });
          }

          push(obj, cb) {
            const insideObj = {
              obj: obj,
              callback: cb
            };
            this.list.push(insideObj);

            if (!this.started) {
              this.started = true;

              this._startTimer();
            }
          }

          remove(node) {
            for (let i = 0, l = this.list.length; i < l; i++) {
              if (this.list[i].obj.node.node === node) {
                this.list.splice(i, 1);
                break;
              }
            }

            if (!this.list.length) {
              this.started = false;
            }
          }

        }

        const timerInstance = new Timer();

        const getPercent = (full, current) => {
          let result = 0;

          if (full > 0) {
            result = current / full;
          }

          return result;
        };

        const checkValue = value => {
          let result = null;

          if (value !== null) {
            value = parseFloat(value);

            if (!isNaN(value)) {
              if (value < 0) {
                value = 0;
              }

              if (value > 1) {
                value = 1;
              }

              result = value;
            }
          }

          return result;
        };

        const getRootSize = node => {
          if (!node) {
            node = window;
          }

          return {
            width: node.offsetWidth || node.innerWidth || document.documentElement.clientWidth,
            height: node.offsetHeight || node.innerHeight || document.documentElement.clientHeight
          };
        };

        const getRootData = (node, pos, size) => {
          const result = Object.assign({}, pos);

          try {
            const tmp = $(node).getBoundingClientRect();
            result.top += tmp.top;
            result.left += tmp.left;
          } catch (e) {
            /* empty */
          }

          return Object.assign(result, size);
        }; // px and % only


        const checkRootMargin = value => {
          let result = [];

          const f = () => {
            return 0;
          };

          if (value && !Array.isArray(value)) {
            if ($J.typeOf(value) === 'number') {
              value = [value];
            } else if ($J.typeOf(value) === 'string') {
              value = value.split(' ');
              value = value.map(v => v.trim());
            } else {
              value = null;
            }
          }

          if (Array.isArray(value)) {
            let l = value.length;

            if (l > 4) {
              l = 4;
            }

            value.forEach(v => {
              if (['string', 'number'].includes($J.typeOf(v))) {
                const number = parseInt(v, 10);

                if (/%$/.test(v)) {
                  result.push(width => {
                    return width / 100 * number;
                  });
                } else {
                  result.push(width => {
                    return number;
                  });
                }
              } else {
                result.push(f);
              }
            }); // [top, right, bottom, left]

            switch (l) {
              case 1:
                result.push(result[0]);
                result.push(result[0]);
                result.push(result[0]);
                break;

              case 2:
                result.push(result[0]);
                result.push(result[1]);
                break;

              case 3:
                result.push(result[1]);
                break;
              // no default
            }
          } else {
            result = [f, f, f, f];
          }

          return result;
        };

        const checkThreshold = value => {
          let result = [];

          if (Array.isArray(value)) {
            value.forEach(v => {
              const tmp = checkValue(v);

              if (tmp !== null && !result.includes(tmp)) {
                result.push(tmp);
              }
            });
          } else {
            result = [0];
          }

          return result;
        };

        const getIntersectionRatio = (rect, viewPortSize) => {
          const rw = rect.width || 1;
          const rh = rect.height || 1;
          let width = Math.min(rect.left + rw, viewPortSize.left + viewPortSize.width) - Math.max(rect.left, viewPortSize.left);
          let height = Math.min(rect.top + rh, viewPortSize.top + viewPortSize.height) - Math.max(rect.top, viewPortSize.top);

          if (width < 0) {
            width = 0;
          }

          if (height < 0) {
            height = 0;
          }

          return getPercent(rw * rh, width * height);
        };

        const checkThresholdQueue = (arr, lastIntersectionRatio, currentIntersectionRatio) => {
          let result = false;

          if (lastIntersectionRatio !== currentIntersectionRatio) {
            if (lastIntersectionRatio < currentIntersectionRatio) {
              for (let i = 0, l = arr.length; i < l; i++) {
                if (arr[i] === 0 && lastIntersectionRatio === 0 || lastIntersectionRatio < arr[i] && arr[i] <= currentIntersectionRatio) {
                  result = true;
                  break;
                }
              }
            } else {
              for (let i = 0, l = arr.length; i < l; i++) {
                if (arr[i] === 1 && lastIntersectionRatio === 1 || lastIntersectionRatio > arr[i] && arr[i] >= currentIntersectionRatio) {
                  result = true;
                  break;
                }
              }
            }
          }

          return result;
        };

        class FakeIntersectionObserver {
          constructor(callback, options) {
            this.callback = callback;
            this.options = Object.assign({
              rootMargin: '0px',
              threshold: [0],
              root: null
            }, options || {});
            this.options.rootMargin = checkRootMargin(this.options.rootMargin);
            this.options.threshold = checkThreshold(this.options.threshold);
            this.nodeList = [];
            this.last = [];
            this.viewPortSize = {
              top: 0,
              left: 0,
              width: 0,
              height: 0
            };
            this.correctPosition = {
              top: 0,
              left: 0
            };
            this.eventWasAdded = false;
            this.bindedRender = this._render.bind(this);
            this.bindedResize = this._resize.bind(this);

            this._resize();
          }

          _addEvents(e) {
            if (!this.eventWasAdded) {
              this.eventWasAdded = true;
              $(window).addEvent('resize', this.bindedResize);
              $(this.options.root || window).addEvent('scroll', this.bindedRender);
            }
          }

          _removeEvents(e) {
            if (this.eventWasAdded) {
              this.eventWasAdded = false;
              $(window).removeEvent('resize', this.bindedResize);
              $(this.options.root || window).removeEvent('scroll', this.bindedRender);
            }
          }

          _resize(e) {
            const m = this.options.rootMargin;
            const rootSize = getRootSize(this.options.root); // m.map((v) => {
            //     return v(rootSize.width);
            // });

            this.correctPosition = {
              top: 0 - m[0](rootSize.width),
              left: 0 - m[1](rootSize.width)
            };
            this.viewPortSize = {
              width: rootSize.width + m[1](rootSize.width) + m[3](rootSize.width),
              height: rootSize.height + m[0](rootSize.width) + m[2](rootSize.width)
            };
          }

          _renderElement(nodeObj) {
            let result = null;

            if (nodeObj.isShown) {
              const rootData = getRootData(this.options.root, this.correctPosition, this.viewPortSize);
              const intersectionRatio = getIntersectionRatio(nodeObj.node.node.getBoundingClientRect(), rootData);

              if (checkThresholdQueue(this.options.threshold, nodeObj.intersectionRatio, intersectionRatio)) {
                nodeObj.intersectionRatio = intersectionRatio;
                result = {
                  target: nodeObj.node.node,
                  intersectionRatio: nodeObj.intersectionRatio,
                  isIntersecting: nodeObj.intersectionRatio > 0
                };
              }
            }

            return result;
          }

          _render() {
            const changedNodes = [];
            this.nodeList.forEach(node => {
              const result = this._renderElement(node);

              if (result) {
                changedNodes.push(result);
              }
            });

            if (changedNodes.length) {
              this.last = changedNodes;
              this.callback(changedNodes);
            }
          }

          takeRecords() {
            this._render();

            return this.last;
          }

          observe(node) {
            node = $(node);
            node = {
              node: node,
              isShown: elementIsShown(node),
              intersectionRatio: 0,
              isIntersecting: false
            };
            timerInstance.push(node, _node => {
              const result = this._renderElement(_node);

              if (result) {
                this.last = [result];
                this.callback([result]);
              }
            });
            this.nodeList.push(node);

            this._addEvents();

            let cbData = this._renderElement(node);

            if (!cbData) {
              cbData = {
                target: node.node.node,
                intersectionRatio: 0,
                isIntersecting: false
              };
            }

            this.callback([cbData]);
          }

          unobserve(node) {
            node = $(node);
            const nodes = this.nodeList.map(obj => obj.node.node);
            const index = nodes.indexOf(node.node);
            timerInstance.remove(node.node);

            if (index > -1) {
              this.nodeList.splice(index, 1);
            }

            if (!this.nodeList.length) {
              this._removeEvents();
            }
          }

          disconnect() {
            this.nodeList.forEach(node => {
              timerInstance.remove(node.node);
            });
            this.nodeList = [];

            this._removeEvents();
          }

        }

        class Instance {
          constructor(callback, options) {
            const IntersectionObserverClass = window.IntersectionObserver || FakeIntersectionObserver;
            this.observer = new IntersectionObserverClass(callback, options || {});
          }

          static isInView(node) {
            const rect = $(node).getBoundingClientRect();
            return (rect.top >= 0 || rect.top - rect.bottom < rect.top) && rect.left >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight);
          }

          takeRecords() {
            return this.observer.takeRecords();
          }

          observe(target) {
            if (target.node) {
              target = target.node;
            }

            this.observer.observe(target);
          }

          unobserve(target) {
            this.observer.unobserve(target);
          }

          disconnect() {
            this.observer.disconnect();
          }

        }

        return Instance;
      })();
      /* global helper */

      /* eslint-env es6 */


      helper.isPercentage = value => {
        return /^([-]?[0-9]*\.?[0-9]+)%$/.test('' + value);
      };
      /* global $J, helper */

      /* eslint-env es6 */


      helper.isSVG = url => {
        if (url) {
          url = url.split('?')[0];
          url = url.split('.');
          url = url[url.length - 1];
          return /svg/i.test(url);
        }

        return false;
      };
      /* global helper */

      /* eslint-env es6 */


      helper.isSpin = str => {
        str = (str || '').split('?')[0];
        return /([^#?]+)\/?([^#?]+\.spin)(\?([^#]*))?(#(.*))?$/.test(str);
      };
      /* global helper */

      /* eslint-env es6 */


      helper.isVideo = str => {
        str = (str || '').split('?')[0];
        return /([^#?]+)\/?([^#?]+\.(mp4|mov|avi|m4v|mkv|webm|wmv|ogv|ogg))(\?([^#]*))?(#(.*))?$/i.test(str);
      };
      /* global helper */

      /* global $J */

      /* global $ */

      /* eslint-env es6 */


      helper.loadImage = sources => {
        return new Promise((resolve, reject) => {
          let img;
          let container;
          let createContainer = false;

          if (['array', 'string'].includes($J.typeOf(sources))) {
            if ($J.typeOf(sources) === 'string') {
              sources = [sources];
            }

            img = $J.$new('img').setCss({
              maxWidth: 'none',
              maxHeight: 'none'
            });
            img.attr('referrerpolicy', 'no-referrer-when-downgrade');
            createContainer = true;
          } else {
            img = $(sources);

            if (!img.node.parentNode) {
              createContainer = true;
            }
          }

          if (createContainer) {
            container = $J.$new('div').setCss({
              top: '-10000px',
              left: '-10000px',
              width: '10px',
              height: '10px',
              position: 'absolute',
              overflow: 'hidden'
            });
            container.append(img);
            $($J.D.node.body).append(container);
          } // if (!img.complete || $J.browser.engine === 'gecko') {


          if (!img.node.complete || !img.node.src) {
            const handler = e => {
              img.removeEvent(['load', 'error'], handler);

              if (e.type === 'error') {
                reject({
                  error: e
                });
              } else {
                resolve({
                  image: e,
                  size: {
                    width: img.node.naturalWidth || img.node.width,
                    height: img.node.naturalHeight || img.node.height
                  }
                });
              }

              if (container) {
                container.remove();
              }
            };

            img.addEvent(['load', 'error'], handler);

            if (container && $J.typeOf(sources) === 'array') {
              img.attr('src', sources[0]);

              if (sources[1]) {
                // img.attr('srcset', encodeURI(sources[1]) + ' 2x');
                img.attr('srcset', sources[1] + ' 2x');
              }
            }
          } else {
            if (container) {
              container.remove();
            }

            resolve({
              image: null,
              size: img.size
            });
          }
        });
      };
      /* global $J, helper */

      /* eslint-env es6 */


      helper.loadStylesheet = (url, id, shadowRoot, selector) => {
        return new Promise((resolve, reject) => {
          let alreadyIncluded = false;
          const rootElement = shadowRoot || $J.D.node;
          Array.from(rootElement.querySelectorAll('link')).forEach(link => {
            const href = $(link).attr('href') || '';

            if ($J.getAbsoluteURL(href) === $J.getAbsoluteURL(url)) {
              alreadyIncluded = true;
            }
          });

          if (alreadyIncluded) {
            resolve();
          } else {
            const slink = $J.$new('link');

            if (id !== $J.U) {
              slink.node.id = id;
            }

            slink.node.rel = 'stylesheet';
            slink.node.type = 'text/css';

            slink.node.onload = () => {
              resolve();
            };

            slink.node.onerror = e => {
              reject(e);
            };

            slink.node.href = url;
            let root = $J.D.node.head || $J.D.node.getElementsByTagName('head')[0] || $J.D.node.body || $J.D.node.documentElement;

            if (shadowRoot) {
              root = shadowRoot;
            }

            let nextSibling = root.firstChild;
            const addAfter = root.querySelector(selector);

            if (addAfter && addAfter.nextSibling) {
              nextSibling = addAfter.nextSibling;
            }

            root.insertBefore(slink.node, nextSibling);
          }
        });
      };
      /* global helper */

      /* eslint-env es6 */


      helper.makeQueryblePromise = promise => {
        if (promise.isResolved) {
          return promise;
        }

        let isPending = true;
        let isRejected = false;
        let isFulfilled = false;
        const result = promise.then(res => {
          isPending = false;
          isFulfilled = true;
          return res;
        }, err => {
          isPending = false;
          isRejected = true;
          return err;
        });

        result.isFulfilled = () => {
          return isFulfilled;
        };

        result.isPending = () => {
          return isPending;
        };

        result.isRejected = () => {
          return isRejected;
        };

        return result;
      };
      /* global $, $J, helper */

      /* eslint quote-props: ["off", "always"] */

      /* eslint-env es6 */


      helper.paramsFromQueryString = (() => {
        const IMG_OPTION_ALIAS = {
          w: 'scale.width',
          h: 'scale.height',
          cw: 'crop.width',
          ch: 'crop.height',
          cx: 'crop.x',
          cy: 'crop.y',
          q: 'quality',
          s: 'size',
          // p         : 'profile', // WE SHOULD UPDATE NGINX CONFIGS FOR THIS
          text: 'text.text',
          watermark: 'watermark.image',
          'watermark.w': 'watermark.scale.width',
          'watermark.h': 'watermark.scale.height',
          'watermark.cw': 'watermark.crop.width',
          'watermark.ch': 'watermark.crop.height',
          'watermark.cx': 'watermark.crop.x',
          'watermark.cy': 'watermark.crop.y'
        }; // fix: if the '<meta http-equiv="Content-Type" content="text/html;charset=utf-8">' is absent

        const decodeURIComponentX = str => {
          let out = '';
          const arr = str.split(/(%(?:D0|D1)%.{2})/);

          for (let i = 0, l = arr.length; i < l; i++) {
            let x;

            try {
              x = decodeURIComponent(arr[i]);
            } catch (e) {
              x = arr[i];
            }

            out += x;
          }

          return out;
        };
        /**
         * Converts query string to Object
         * @param  {String} query   Query string
         * @return {Object}
         */


        return query => {
          const params = {};

          if (query) {
            $(query.split('&')).forEach(pair => {
              const setting = pair.split('='); // Convert option alias to a real name

              setting[0] = IMG_OPTION_ALIAS[setting[0]] || setting[0];
              setting[0].trim().split('.').reduce((res, val, ind, col) => {
                if (/^\d$/.test(val)) {
                  // save text.0.text='hello' as object and then convert to array
                  res.__toArray = true;
                }

                if (res[val] === undefined) {
                  if (ind < col.length - 1) {
                    res[val] = {};
                  } else {
                    // res[val] = decodeURIComponent(setting[1] || '');
                    res[val] = decodeURIComponentX(setting[1] || '');
                  }
                }

                return res[val];
              }, params);
            });
            Object.keys(params).forEach(key => {
              if (typeof params[key] === 'object' && params[key].__toArray) {
                delete params[key].__toArray;
                const objKeys = Object.keys(params[key]);
                params[key] = objKeys.map(idx => {
                  return params[key][idx];
                });
              }
            });
          }

          return params;
        };
      })();
      /* global $, $J, helper */

      /* eslint no-restricted-syntax: ["error", "FunctionExpression", "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint no-continue: "off" */

      /* eslint no-loop-func: "off" */

      /* eslint-env es6 */

      /**
       * Convert JSON data to query string
       * @param  {Object} data - JSON data
       * @param  {String} [prefix] Prefix added to parameter name in query string
       * @return {[type]}          Query string.
       */


      helper.paramsToQueryString = (() => {
        const URL_OPTIONS_ALIASES = {
          'scale.width': 'w',
          'scale.height': 'h',
          'crop.width': 'cw',
          'crop.height': 'ch',
          'crop.x': 'cx',
          'crop.y': 'cy',
          'quality': 'q',
          'size': 's',
          'text.text': 'text',
          'watermark.image': 'watermark',
          'watermark.scale.width': 'watermark.w',
          'watermark.scale.height': 'watermark.h',
          'watermark.crop.width': 'watermark.cw',
          'watermark.crop.height': 'watermark.ch',
          'watermark.crop.x': 'watermark.cx',
          'watermark.crop.y': 'watermark.cy'
        };

        const paramsToQueryString = (data, prefix) => {
          const results = [];

          for (const k in data) {
            if (!Object.prototype.hasOwnProperty.call(data, k)) {
              continue;
            }

            if ((k + '').substring(0, 2) === '$J') {
              continue;
            }

            let value = data[k];

            if ($J.typeOf(value) === 'object') {
              value = paramsToQueryString(value, (prefix || '') + k + '.');
              results.push(value);
            } else if ($J.typeOf(value) === 'array') {
              value.forEach((item, idx) => {
                value = paramsToQueryString(item, (prefix || '') + k + '.' + idx + '.');
                results.push(value);
              });
            } else {
              // results.push((prefix || '') + k + '=' + encodeURIComponent(value));
              let paramName = (prefix || '') + k;
              paramName = URL_OPTIONS_ALIASES[paramName] || paramName;
              results.push(paramName + '=' + encodeURIComponent(value));
            }
          }

          return results.join('&');
        };

        return paramsToQueryString;
      })();
      /* global helper */

      /* eslint no-restricted-properties: "off" */

      /* eslint-env es6 */


      helper.round = (value, count, noTail) => {
        if (!count) {
          count = 0;
        }

        let v = Math.pow(10, count);

        if (noTail) {
          v = parseInt(value * v, 10) / v;
        } else {
          v = Math.round(value * v) / v;
        }

        return v;
      };
      /* global helper */

      /* eslint-env es6 */


      helper.roundSize = (value, roundValue) => {
        if (value) {
          if (!roundValue) {
            roundValue = 100;
          }

          value = Math.ceil(value / roundValue) * roundValue;
        }

        return value;
      };
      /* global $J, helper */

      /* global globalVariables */

      /* eslint new-parens: "off" */

      /* eslint-env es6 */


      helper.sendRawStats = (statsData, useBeacon) => {
        try {
          const endpoint = 'https://stats.sirv.com/' + +new Date();

          if (useBeacon === true && navigator.sendBeacon) {
            navigator.sendBeacon(endpoint, helper.paramsToQueryString(statsData));
            return;
          }

          const xhr = new XMLHttpRequest();
          xhr.open('POST', endpoint);

          if (xhr.responseType !== undefined) {
            xhr.responseType = 'text';
          }

          xhr.send(helper.paramsToQueryString(statsData));
        } catch (ex) {//empty
        }
      };
      /* global $J, helper */

      /* eslint-env es6 */


      helper.sliderLib = {
        // getIndexFromDirection: (currentIndex, direction, length, loop) => {
        //     let index = currentIndex;
        //     switch (direction) {
        //         case 'next':
        //             index += 1;
        //             break;
        //         case 'prev':
        //             index -= 1;
        //             break;
        //         default:
        //             return currentIndex;
        //     }
        //     if (loop) {
        //         index = helper.getArrayIndex(index, length);
        //     } else {
        //         if (index < 0) {
        //             index = 0;
        //         } else if (index > length - 1) {
        //             index = length - 1;
        //         }
        //     }
        //     return index;
        // },
        findIndex: (value, currentIndex, l, loop) => {
          let result = null;

          if ($J.typeOf(value) === 'string') {
            switch (value) {
              case 'next':
                value = currentIndex + 1;
                break;

              case 'prev':
                value = currentIndex - 1;
                break;
              // no default
            }
          }

          if ($J.typeOf(value) === 'number') {
            result = value;

            if (result < 0) {
              if (loop) {
                result = helper.getArrayIndex(result, l);
              } else {
                result = 0;
              }
            } else if (value >= l) {
              if (loop) {
                result = helper.getArrayIndex(result, l);
              } else {
                result = l - 1;
              }
            }
          }

          return result;
        },
        // getDirectionFromIndex: function (currentIndex, index, length, loop) {
        //     var direction = 'next', fl, rl;
        //     function getForwardLeft() {
        //         var result;
        //         if (index < currentIndex) {
        //             result = currentIndex - index;
        //         } else {
        //             result = length - index + currentIndex;
        //         }
        //         return result;
        //     }
        //     function getForwardRight() {
        //         var result;
        //         if (currentIndex < index) {
        //             result = index - currentIndex;
        //         } else {
        //             result = length - currentIndex + index;
        //         }
        //         return result;
        //     }
        //     if (loop) {
        //         fl = getForwardLeft();
        //         rl = getForwardRight();
        //         if (fl === rl && currentIndex > index || fl < rl) {
        //             direction = 'prev';
        //         }
        //     } else {
        //         if (index < currentIndex) { direction = 'prev'; }
        //     }
        //     return direction;
        // },
        getSrc: src => {
          if ($J.defined(src) && (src + '').trim() !== '') {
            return src + '';
          }

          return null;
        }
      };
      /* global $, $J, helper */

      /* eslint-env es6 */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      helper.sortSlidesByOrder = (order, slides) => {
        const oldSlidesArr = slides.slice();
        const newSlidesArr = [];

        if (order && order.length) {
          for (let i = 0, l = Math.min(order.length, oldSlidesArr.length); i < l; i++) {
            for (let j = 0, l2 = oldSlidesArr.length; j < l2; j++) {
              if (globalVariables.SLIDE.NAMES.indexOf(order[i]) === oldSlidesArr[j].type && oldSlidesArr[j].enabled) {
                newSlidesArr.push(oldSlidesArr[j]);
                oldSlidesArr.splice(j, 1);
                break;
              }
            }
          }
        }

        oldSlidesArr.forEach(item => {
          newSlidesArr.push(item);
        });
        return newSlidesArr;
      };
      /* global $J, helper */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint-env es6 */

      /* eslint-env es6 */


      helper.spinLib = (() => {
        // eslint-disable-next-line no-unused-vars
        const FULLSCREEN_PERCENT_WITHOUT_ACTION = 15; // 0% - 100%

        const sirvlib = {
          calcProportionSize: (spinSize, originSize, isFullscreen, oldSize) => {
            let width = originSize.width;
            let height = originSize.height; // if (isFullscreen) {
            //     if (spinSize.width > spinSize.height) {
            //         spinSize.height -= 20;
            //     } else {
            //         spinSize.width -= 20;
            //     }
            // }

            if (width > spinSize.width) {
              const tmp = height / width;
              width = spinSize.width;
              height = parseInt(width * tmp, 10);
            }

            if (height > spinSize.height) {
              const tmp = width / height;
              height = spinSize.height;
              width = parseInt(height * tmp, 10);
            }
            /* eslint-disable */
            // if (isFullscreen) {


            if (oldSize) {// if (oldSize.width / (originSize.width / 100) >= 100 - spinLib.FULLSCREEN_PERCENT_WITHOUT_ACTION) {
              //     width = oldSize.width;
              //     height = oldSize.height;
              // }
            } else {
              if (originSize.width < width) {
                width = originSize.width;
                height = originSize.height;
              }
            } // }

            /* eslint-enable */


            return {
              width: width,
              height: height
            };
          },
          reverse: (col, row, arr) => {
            if (col) {
              for (let i = 0, l = arr.length; i < l; i++) {
                arr[i].reverse();
              }
            }

            if (row) {
              arr.reverse();
            }

            return arr;
          },
          getNextIndex: (currentValue, value, direction, length, loop) => {
            let result;

            if (direction) {
              if (direction === 'next') {
                result = currentValue + value;

                if (loop) {
                  result = helper.getArrayIndex(result, length);
                } else if (result >= length) {
                  result = length - 1;
                }
              } else {
                result = currentValue - value;

                if (loop) {
                  result = helper.getArrayIndex(result, length);
                } else if (result < 0) {
                  result = 0;
                }
              }
            } else {
              result = value;

              if (loop) {
                result = helper.getArrayIndex(result, length);
              } else {
                if (result >= length) {
                  result = length - 1;
                }

                if (result < 0) {
                  result = 0;
                }
              }
            }

            return result;
          },
          getUrl: path => {
            let url = path;
            url = url.split('/');
            url.splice(url.length - 1, 1);
            url = url.join('/');
            url = url.replace(/https?:/, '');
            return url;
          },
          swapLayers: (layers, revers) => {
            let result = layers;

            if (revers) {
              result = {};
              Object.entries(layers).forEach(([rowKey, rowValue]) => {
                Object.entries(rowValue).forEach(([colKey, colValue]) => {
                  if (!result[colKey]) {
                    result[colKey] = {};
                  }

                  result[colKey][rowKey] = colValue;
                });
              });
            }

            return result;
          },
          getMaxCount: layers => {
            return Math.max(0, ...Object.values(layers).map(value => Object.keys(value).length));
          },
          correctArray: (keysArray, count) => {
            let result = [];
            let correctCount = count - keysArray.length;

            if (correctCount > 0) {
              const l = keysArray.length;

              for (let i = 0; i < l - 1; i++) {
                const curr = parseInt(keysArray[i], 10);
                const next = parseInt(keysArray[i + 1], 10);
                let diff = next - curr - 1;
                result.push(keysArray[i]);

                if (diff > 0) {
                  if (correctCount > 0) {
                    if (diff > correctCount) {
                      diff = correctCount;
                    }

                    while (diff > 0) {
                      diff -= 1;
                      correctCount -= 1;
                      result.push(keysArray[i]);
                    }
                  }
                }
              }

              result.push(keysArray[l - 1]);

              if (correctCount > 0) {
                let diff = parseInt(keysArray[0], 10) - 1;

                if (diff > 0) {
                  while (diff > 0) {
                    diff -= 1;
                    correctCount -= 1;
                    result.unshift(keysArray[0]);
                  }
                }

                if (correctCount > 0) {
                  while (correctCount > 0) {
                    correctCount -= 1;
                    result.push(keysArray[keysArray.length - 1]);
                  }
                }
              }
            } else {
              result = JSON.parse(JSON.stringify(keysArray));
            }

            return result;
          },
          getFrames: (frames, count) => {
            const result = {};
            const newKeys = sirvlib.correctArray(Object.keys(frames), count);
            $(newKeys).forEach((value, index) => {
              result[index + 1 + ''] = frames[value];
            });
            return result;
          },
          checkLayers: layers => {
            const result = {};
            const count = sirvlib.getMaxCount(layers);
            Object.values(layers).forEach((value, index) => {
              result[index + 1 + ''] = sirvlib.getFrames(value, count);
            });
            return result;
          }
        };
        return sirvlib;
      })();
      /* eslint-env es6 */

      /* global $, $J, helper */

      /* eslint quote-props: ["off", "always"]*/

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /*eslint no-lonely-if: "off"*/

      /* eslint-disable no-multi-spaces */

      /* eslint-disable no-use-before-define */


      helper.videoModule = (() => {
        let vimeoPromise = null;
        let youtubePromise = null;
        const sources = {};
        const youtubeImgs = {
          'thumb1': '1.jpg',
          // 120x90
          'thumb2': '2.jpg',
          // 120x90
          'thumb3': '3.jpg',
          // 120x90
          'def0': '0.jpg',
          // 480x360
          'def1': 'default.jpg',
          // 120x90
          'middleQuality': 'mqdefault.jpg',
          // 320x180
          'highQuality': 'hqdefault.jpg',
          // 480x360
          'maxSize': 'maxresdefault.jpg' // 1920x1080

        };

        const getVimeoJSON = url => {
          return new Promise((resolve, reject) => {
            const xhttp = new XMLHttpRequest();
            xhttp.open('GET', url, true);

            xhttp.onreadystatechange = () => {
              if (xhttp.readyState === 4) {
                if (xhttp.status === 200) {
                  try {
                    const result = JSON.parse(xhttp.responseText)[0];
                    resolve(result);
                  } catch (e) {
                    reject(null);
                  }
                }
              }
            };

            xhttp.send(true);
          });
        };

        const isHtmlVideo = node => {
          node = $(node);
          return node && node.tagName === 'video';
        };

        const getYouTobeId = url => {
          let result = null;
          url = url.replace(/(>|<)/gi, '').split(/(vi\/|v=|\/v\/|youtu\.be\/|\/embed\/)/);

          if (url[2] !== undefined) {
            url = url[2].split(/[^0-9a-z_\-]/i);

            if (url.length && url[0]) {
              result = url[0];
            }
          }

          return result;
        };

        const getVimeoId = url => {
          let result = null;
          url = url.match(/(?:https?:\/\/)?(?:www.)?(?:player.)?vimeo.com\/(?:[a-z]*\/)*([0-9]{6,11})[?]?.*/)[1];

          if (url) {
            result = url;
          }

          return result;
        };

        const getSrc = node => {
          let result = null;

          if ($J.typeOf(node) === 'string') {
            result = node;
          } else {
            node = $(node);

            if (node && $J.typeOf(node.node) === 'element') {
              if (['iframe', 'div'].includes(node.tagName)) {
                result = node.attr('src') || node.attr('data-src');
              } else if (isHtmlVideo(node)) {
                result = node.attr('src') || node.attr('data-src');

                if (!result) {
                  result = null;
                  const children = Array.from(node.node.children);
                  let child;

                  do {
                    child = $(children.shift());

                    if (child && $J.typeOf(child.node) === 'element' && child.tagName === 'source') {
                      result = child.attr('src') || child.attr('data-src');
                    }
                  } while (!result && child);
                }
              }
            }
          }

          return result;
        };

        const getAPI = node => {
          let result = null;

          if (api.isVideo(node)) {
            switch (api.getType(node)) {
              case 'video':
                result = Promise.resolve();
                break;

              case 'vimeo':
                if (!vimeoPromise) {
                  vimeoPromise = new Promise((resolve, reject) => {
                    if ($J.W.node.Vimeo) {
                      resolve($J.W.node.Vimeo);
                    } else if (typeof $J.W.node.define === 'function' && $J.W.node.define.amd && typeof $J.W.node.require === 'function') {
                      $J.W.node.require(['https://player.vimeo.com/api/player.js'], player => {
                        resolve({
                          Player: player
                        });
                      }, reject);
                    } else {
                      const script = $J.$new('script');
                      script.attr('src', 'https://player.vimeo.com/api/player.js');
                      $(script).addEvent('load', () => {
                        resolve($J.W.node.Vimeo);
                      });
                      $(script).addEvent('error', reject);
                      script.appendTo(document.body);
                    }
                  });
                }

                result = vimeoPromise;
                break;

              case 'youtube':
                if (!youtubePromise) {
                  if (!$J.W.node.YT) {
                    youtubePromise = new Promise((resolve, reject) => {
                      const f = () => {};

                      const existingEvent = $J.W.node.onYouTubeIframeAPIReady || f;

                      $J.W.node.onYouTubeIframeAPIReady = () => {
                        existingEvent();
                        resolve($J.W.node.YT);
                      };

                      if (!document.querySelector('script[src$="youtube.com/iframe_api"]')) {
                        $J.$new('script', {
                          src: 'https://www.youtube.com/iframe_api'
                        }).appendTo($J.D.node.body);
                      }
                    });
                  } else {
                    youtubePromise = Promise.resolve($J.W.node.YT);
                  }
                }

                result = youtubePromise;
                break;
              // no default
            }
          } else {
            result = Promise.reject(true
            /*error*/
            );
          }

          return result;
        };

        const api = {
          aspectratio: 9 / 16,
          getAspectRatio: src => {
            return new Promise((resolve, reject) => {
              let id;
              src = getSrc(src);

              if (src) {
                if (sources[src]) {
                  resolve(sources[src].aspectratio);
                }
              }

              const type = api.getType(src);

              if (type === 'vimeo') {
                id = getVimeoId(src);

                if (id) {
                  getVimeoJSON('https://vimeo.com/api/v2/video/' + id + '.json').then(data => {
                    resolve(data ? data.height / data.width : api.aspectratio);
                  }).catch(error => {
                    reject(error);
                  });
                } else {
                  resolve(api.aspectratio);
                }
              } else {
                resolve(api.aspectratio);
              }
            });
          },
          getId: src => {
            let result = null;

            if (api.isVideo(src)) {
              src = getSrc(src);

              switch (api.getType(src)) {
                case 'youtube':
                  result = getYouTobeId(src);
                  break;

                case 'vimeo':
                  result = getVimeoId(src);
                  break;
                // no default
              }
            }

            return result;
          },
          isVideo: src => {
            let result = false;

            if (isHtmlVideo(src)) {
              result = true;
            } else {
              src = getSrc(src);

              if (src) {
                result = ['youtube', 'vimeo'].includes(api.getType(src));
              }
            }

            return result;
          },
          getType: src => {
            let result = null;

            if (isHtmlVideo(src)) {
              result = 'video';
            } else {
              src = getSrc(src);

              if (src) {
                if (/^(https?:)?\/\/((www\.)?youtube\.com|youtu\.be)\//.test(src)) {
                  result = 'youtube';
                } else if (/^(https?:)?\/\/((www|player)\.)?vimeo\.com\//.test(src)) {
                  result = 'vimeo';
                }
              }
            }

            return result;
          },
          getImageSrc: (src, getAll) => {
            return new Promise((resolve, reject) => {
              let node;

              if (src && $(src) && $J.typeOf($(src).node) === 'element') {
                node = src;
              }

              src = getSrc(src);
              let thumbUrl = null;

              if (src) {
                if (sources[src]) {
                  if (getAll) {
                    if (sources[src].all) {
                      resolve(sources[src].all);
                      return;
                    }
                  } else {
                    if (sources[src].url) {
                      resolve(sources[src].url);
                      return;
                    } else if (sources[src].all) {
                      resolve(sources[src].all.thumbnail.url);
                      return;
                    }
                  }
                }

                let id;

                switch (api.getType(node || src)) {
                  case 'youtube':
                    id = getYouTobeId(src);

                    if (id) {
                      if (getAll) {
                        thumbUrl = {
                          thumbnail: {
                            url: 'https://img.youtube.com/vi/' + id + '/' + youtubeImgs.def1,
                            width: 120,
                            height: 90
                          },
                          medium: {
                            url: 'https://img.youtube.com/vi/' + id + '/' + youtubeImgs.def0,
                            width: 480,
                            height: 360
                          }
                        };
                      } else {
                        thumbUrl = 'https://img.youtube.com/vi/' + id + '/' + youtubeImgs.def1;
                      }

                      if (!sources[src]) {
                        sources[src] = {};
                      }

                      sources[src].aspectratio = api.aspectratio;

                      if (getAll) {
                        sources[src].all = thumbUrl;
                      } else {
                        sources[src].url = thumbUrl;
                      }
                    }

                    resolve(thumbUrl);
                    break;

                  case 'vimeo':
                    id = getVimeoId(src);

                    if (id) {
                      thumbUrl = 'https://vimeo.com/api/v2/video/' + id + '.json';
                      getVimeoJSON(thumbUrl).then(data => {
                        let imgUrl = null;

                        if (data) {
                          if (getAll) {
                            imgUrl = {
                              thumbnail: {
                                url: data.thumbnail_small,
                                width: 100,
                                height: 75
                              },
                              medium: {
                                url: data.thumbnail_medium,
                                width: 200,
                                height: 150
                              }
                            };
                          } else {
                            imgUrl = data.thumbnail_small;
                          }
                        }

                        if (imgUrl) {
                          if (!sources[src]) {
                            sources[src] = {};
                          }

                          if (getAll) {
                            sources[src].all = imgUrl;
                          } else {
                            sources[src].url = imgUrl;
                          }

                          sources[src].aspectratio = data.height / data.width;
                        }

                        resolve(imgUrl);
                      }).catch(reject);
                    } else {
                      resolve(thumbUrl);
                    }

                    break;

                  case 'video':
                    if (node) {
                      node = $(node.node.cloneNode(true));

                      if (node.attr) {
                        thumbUrl = node.attr('poster');
                      }

                      if (thumbUrl && thumbUrl.trim() !== '') {
                        if (!sources[src]) {
                          sources[src] = {};
                        }

                        sources[src].aspectratio = api.aspectratio;

                        if (getAll) {
                          sources[src].all = {
                            thumbnail: {
                              url: thumbUrl,
                              width: 200,
                              height: 150
                            },
                            medium: {
                              url: thumbUrl,
                              width: 200,
                              height: 150
                            }
                          };
                          resolve(sources[src].all);
                        } else {
                          sources[src].url = thumbUrl;
                          resolve(thumbUrl);
                        }
                      } else {
                        const timeOfPoster = 0;
                        const canvas = $J.$new('canvas');
                        const context = canvas.node.getContext('2d');

                        const clear = () => {
                          // Array.from(node.node.children).forEach(function (child) {
                          //     child = $(child)
                          //     if (child && child.tagName === 'source') {
                          //         child.removeEvent(['abort', 'error']);
                          //     }
                          // });
                          node.removeEvent(['loadedmetadata', 'loadeddata', 'abort', 'error', 'stalled']);
                          node.remove();
                        };

                        const addSrc = () => {
                          let _src = node.attr('data-src');

                          if (_src) {
                            node.attr('src', _src);
                          }

                          Array.from(node.node.children).forEach(child => {
                            child = $(child);

                            if (child && child.tagName === 'source') {
                              _src = child.attr('data-src');

                              if (_src) {
                                child.attr('src', _src);
                              }
                            }
                          });
                        };

                        addSrc();
                        node.setCss({
                          top: -100000,
                          left: -100000,
                          width: 200,
                          height: 150,
                          position: 'absolute'
                        });
                        node.muted = true;
                        node.addEvent('loadedmetadata', e => {
                          const size = node.size;

                          if (!size.width || !size.height) {
                            size.width = 200;
                            size.height = 150;
                          }

                          node.setCss({
                            width: size.width,
                            height: size.height
                          });
                          canvas.node.width = size.width;
                          canvas.node.height = size.height;

                          if (timeOfPoster < node.node.duration) {
                            node.node.currentTime = timeOfPoster;
                          }
                        }); // Array.from(node.node.children).forEach(function (child) {
                        //     child = $(child);
                        //     if (child && child.tagName === 'source') {
                        //         child.addEvent(['abort', 'error'], function (e) {
                        //             clear();
                        //             callback(null);
                        //         });
                        //     }
                        // });

                        node.addEvent('loadeddata', e => {
                          node.currentTime = timeOfPoster;
                        });
                        node.addEvent(['abort', 'error', 'stalled'], e => {
                          clear();
                          reject(null);
                        });
                        node.addEvent('seeked', e => {
                          context.drawImage(node.node, 0, 0, canvas.node.width, canvas.node.height);
                          clear();

                          try {
                            thumbUrl = canvas.node.toDataURL();
                          } catch (ex) {// empty
                          }

                          if (thumbUrl) {
                            if (!sources[src]) {
                              sources[src] = {};
                            }

                            sources[src].aspectratio = api.aspectratio;

                            if (getAll) {
                              sources[src].all = {
                                thumbnail: {
                                  url: thumbUrl,
                                  width: 200,
                                  height: 150
                                },
                                medium: {
                                  url: thumbUrl,
                                  width: 200,
                                  height: 150
                                }
                              };
                              resolve(sources[src].all);
                            } else {
                              sources[src].url = thumbUrl;
                              resolve(thumbUrl);
                            }
                          } else {
                            resolve(thumbUrl);
                          }
                        });
                        node.appendTo($J.D.node.body);
                        node.node.load();
                      }
                    } else {
                      resolve(thumbUrl);
                    }

                    break;

                  default:
                    resolve(thumbUrl);
                }
              } else {
                resolve(thumbUrl);
              }
            });
          },
          getSrc: getSrc,
          getAPI: getAPI
        };
        return api;
      })();

      return helper;
    });
    Sirv.define('EventEmitter', ['bHelpers', 'magicJS', 'helper'], (bHelpers, magicJS, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global helper */

      /* eslint-disable indent */

      /* eslint-disable no-console */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars

      class EventObject {
        constructor(type, direction, data) {
          this.type = type;
          this._direction = direction;
          this.propagation = true;
          this.nextCalls = true;
          this.emptyEvent = true;
          this.data = Object.assign(data, {
            eventType: this.type,
            eventDirection: this._direction,
            stopEmptyEvent: this.stopEmptyEvent.bind(this),
            stopPropagation: this.stopPropagation.bind(this),
            stopNextCalls: this.stopNextCalls.bind(this),
            stop: this.stop.bind(this),
            stopAll: this.stopAll.bind(this)
          });
        }

        copyData() {
          const result = Object.assign({}, this.data);
          delete result.eventDirection;
          delete result.stopEmptyEvent;
          delete result.stopPropagation;
          delete result.stopNextCalls;
          delete result.stop;
          delete result.stopAll;
          return result;
        }

        get customData() {
          return this.data;
        }

        get direction() {
          return this._direction;
        }

        get emptyEventStopped() {
          return !this.emptyEvent;
        }

        get propagationStopped() {
          return !this.propagation;
        }

        get nextCallsStopped() {
          return !this.nextCalls;
        }

        stopEmptyEvent() {
          this.emptyEvent = false;
        }

        stopPropagation() {
          this.propagation = false;
        }

        stopNextCalls() {
          this.nextCalls = false;
        }

        stop() {
          this.stopPropagation();
          this.stopEmptyEvent();
        }

        stopAll() {
          this.stop();
          this.stopNextCalls();
        }

      }
      /* eslint-env es6 */

      /* global EventObject */

      /* eslint-disable indent */

      /* eslint-disable no-console */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


      const correctName = (name, defaultName) => {
        if ($J.typeOf(name) === 'string') {
          name = name.trim();

          if (name === '') {
            name = defaultName;
          }
        } else {
          name = defaultName;
        }

        return name;
      }; // eslint-disable-next-line no-unused-vars


      class EmitterInstance {
        constructor() {
          this.__parent = null;
          this.__childs = $([]);
          this.__subscribers = {};
          this.__NAME_OF_EMPTY_EVENT = '__empty__';
        }

        __setChild(child) {
          this.__childs.push(child);
        }

        __removeChild(child) {
          const idx = this.__childs.indexOf(child);

          if (idx !== -1) {
            this.__childs.splice(idx, 1);
          }
        }

        set parentClass(parent) {
          this.__parent = parent;

          this.__parent.__setChild(this);
        }

        __removeParent() {
          if (this.__parent) {
            this.__parent.__removeChild(this);

            this.__parent = null;
          }
        }

        __callNext(event) {
          if (!event.propagationStopped) {
            if (event.direction === 'up') {
              if (this.__parent) {
                this.__parent.__next(event);
              }
            } else {
              this.__childs.forEach(child => {
                child.__next(event);
              });
            }
          }
        }

        __next(event) {
          const callbacks = this.__subscribers[event.type];
          event = new EventObject(event.type, event.direction, event.copyData());

          if (callbacks) {
            for (let i = 0; i < callbacks.length; i++) {
              callbacks[i](event.customData, event, this);

              if (event.nextCallsStopped) {
                break;
              }
            }
          }

          if (Object.prototype.hasOwnProperty.call(this.__subscribers, this.__NAME_OF_EMPTY_EVENT) && !event.emptyEventStopped) {
            for (let i = 0; i < this.__subscribers[this.__NAME_OF_EMPTY_EVENT].length; i++) {
              this.__subscribers[this.__NAME_OF_EMPTY_EVENT][i](event.customData);
            }
          }

          this.__callNext(event);
        }

        emit(type, data) {
          // up
          if (!data || $J.typeOf(data) !== 'object') {
            if ($J.typeOf(type) === 'object') {
              data = type;
              type = null;
            } else {
              data = {};
            }
          }

          type = correctName(type, this.__NAME_OF_EMPTY_EVENT);

          this.__callNext(new EventObject(type, 'up', data));
        }

        broadcast(type, data) {
          // down
          if (!data || $J.typeOf(data) !== 'object') {
            if ($J.typeOf(type) === 'object') {
              data = type;
              type = null;
            } else {
              data = {};
            }
          }

          type = correctName(type, this.__NAME_OF_EMPTY_EVENT);

          this.__callNext(new EventObject(type, 'down', data));
        }

        on(type, fn) {
          const self = this;

          if ($J.typeOf(type) === 'function') {
            fn = type;
            type = null;
          }

          if (!fn) {
            return null;
          }

          type = correctName(type, this.__NAME_OF_EMPTY_EVENT);

          if (!this.__subscribers[type]) {
            this.__subscribers[type] = [];
          }

          this.__subscribers[type].push(fn);

          return () => {
            return self.off(type, fn);
          };
        }

        off(type, fn) {
          let idx;

          if ($J.typeOf(type) === 'function') {
            fn = type;
            type = null;
          }

          type = correctName(type, this.__NAME_OF_EMPTY_EVENT);

          if (!fn) {
            delete this.__subscribers[type];
          } else if (Object.prototype.hasOwnProperty.call(this.__subscribers, type)) {
            idx = this.__subscribers[type].indexOf(fn);

            if (idx !== -1) {
              this.__subscribers[type].splice(idx, 1);
            }
          }
        }

        destroy() {
          this.__removeParent();

          this.__childs = $([]);
          this.__subscribers = {};
        }

      }

      return EmitterInstance;
    });
    Sirv.define('EventManager', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'EventEmitter', 'helper'], (bHelpers, magicJS, globalVariables, globalFunctions, EventEmitter, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* global $, $J, EventEmitter, helper */

      /* eslint-env es6 */
      // eslint-disable-next-line no-unused-vars

      class EventManager extends EventEmitter {
        constructor(items) {
          super();
          this.items = items;
          this.events = {
            lazyimage: {},
            viewer: {},
            spin: {},
            // viewer component
            zoom: {},
            // viewer component
            image: {},
            // viewer component
            video: {} // viewer component

          };
          this.reversedEvents = [];
          this.addEvents();
        }

        static eventsNameParser(eventName) {
          let result = null;

          if (eventName && $J.typeOf(eventName) === 'string') {
            result = eventName.split(':').map(v => {
              return v.trim();
            }).filter(v => {
              return v !== '';
            });

            if (/sirv/i.test(result[0])) {
              result.shift();
            }

            if (result.length < 2) {
              result = null;
            }
          }

          return result;
        }
        /**
         * Trigger a DOM event
         * @param {String} eventType A name of the event.
         * @param {DOM Element} element The targe DOM element.
         * @param {Object} [detail] Additional event details.
         * @param {Boolean} [bubbles] Defines whether the event should bubble up through the event chain or not.
         * @param {Boolean} [cancelable] Defines whether the event can be canceled.
         */


        static triggerCustomEvent(eventType, element, detail, bubbles, cancelable) {
          if (bubbles === $J.U) {
            bubbles = true;
          }

          if (cancelable === $J.U) {
            cancelable = true;
          }

          let event;

          try {
            event = new CustomEvent(eventType, {
              bubbles: bubbles,
              cancelable: cancelable,
              detail: detail
            });
          } catch (e) {
            try {
              event = $J.D.createEvent('Event');
              event.initEvent(eventType, bubbles, cancelable);
              event.detail = detail;
            } catch (ex) {
              /* empty */
            }
          }

          if (event) {
            element.node.dispatchEvent(event);
          }
        }

        addReverseEvent(eventName, callback, componentName) {
          this.reversedEvents.push({
            eventName: eventName,
            componentName: componentName,
            callback: callback
          });
        }

        callReverseCallback(componentName, eventName, eventData) {
          let result = false;

          for (let i = 0, l = this.reversedEvents.length; i < l; i++) {
            if (this.reversedEvents[i].componentName === componentName && this.reversedEvents[i].eventName === eventName) {
              this.reversedEvents[i].callback(eventData);
              this.reversedEvents.splice(i, 1);
              result = true;
              break;
            }
          }

          return result;
        }

        addEvents() {
          this.on('destroy', e => {
            e.stopAll();
            globalFunctions.stop(e.data.node, 'viewer');
          });
          /*
              'onLoad'
          */

          this.on('imagePublicEvent', e => {
            e.stopAll();
            const isReversed = this.callReverseCallback('lazyimage', e.data.type, e.data.image);

            if (!isReversed) {
              EventManager.triggerCustomEvent('sirv:lazyimage:' + e.data.type, e.data.node, Object.assign({}, e.data.image));
              const evs = this.events.lazyimage[e.data.type];

              if (evs) {
                evs.forEach(callback => {
                  callback(e.data.image);
                });
              }
            }
          });
          /*
              viewer events
              'ready', 'fullscreenIn', 'fullscreenOut', 'beforeSlideIn', 'beforeSlideOut', 'afterSlideIn', 'afterSlideOut', 'enableItem', 'disableItem'
          */

          this.on('viewerPublicEvent', e => {
            e.stopAll();
            let node;
            let type;
            let eventData;
            let componentName = 'viewer';

            if (e.data.slider.type === 'componentEvent') {
              type = e.data.type;
              eventData = Object.assign({}, e.data.slide[e.data.slide.component]);
              componentName = e.data.slide.component;

              if (e.data.node) {
                node = e.data.componentEventData.node;
              }

              Object.entries(e.data.componentEventData).forEach(([key, value]) => {
                if (key === 'node') {
                  if (e.data.node) {
                    eventData[key] = value.node;
                  }
                } else if (key !== 'type') {
                  eventData[key] = value;
                }
              });
            } else {
              type = e.data.slider.type;

              if (type === 'ready') {
                globalFunctions.iconsHash.remove();
              }

              if (e.data.node) {
                node = e.data.node;
              }

              if (e.data.slider) {
                eventData = e.data.slider;

                if (type === 'sendStats') {
                  eventData.statsData = e.data.event;
                }
              }

              if (['beforeSlideIn', 'beforeSlideOut', 'afterSlideIn', 'afterSlideOut', 'enableItem', 'disableItem', 'thumbnailClick'].includes(type)) {
                eventData = e.data.slide;
              }
            }

            const isReversed = this.callReverseCallback(componentName, type, eventData);

            if (!isReversed) {
              if (node) {
                EventManager.triggerCustomEvent('sirv:' + componentName + ':' + type, node, Object.assign({}, eventData));
              }

              const evs = this.events[componentName][type];

              if (evs) {
                evs.forEach(callback => {
                  callback(eventData);
                });
              }
            }
          });
          this.on(e => {
            e.stopAll();
          });
        }

        addEvent(eventName, callback) {
          let result = () => {
            return false;
          };

          const events = EventManager.eventsNameParser(eventName);

          if (events && this.events[events[0]] && callback) {
            if (!this.events[events[0]][events[1]]) {
              this.events[events[0]][events[1]] = [];
            }

            this.events[events[0]][events[1]].push(callback);

            if (['ready', 'init', 'onLoad'].includes(events[1])) {
              const itemName = events[0] === 'lazyimage' ? 'image' : 'viewer';

              if (itemName === 'viewer' && events[1] !== 'onLoad' || events[1] === 'onLoad' && itemName === 'image') {
                /*
                    we need the timeout because every event returns function which can remove this event
                     for example:
                    if event 'ready' already was
                    and we set new one
                    the variable 'removeReadyEvent' will be undefined
                     const removeReadyEvent = Sirv.on('viewer:ready', (e) => {
                        removeReadyEvent();
                    });
                */
                setTimeout(() => {
                  const items = this.items[itemName];
                  items.forEach(item => {
                    if (item.checkReadiness(events[1], events[0])) {
                      this.addReverseEvent(events[1], callback, events[0]);
                      item.sendEvent(events[1], events[0]);
                    }
                  });
                }, 0);
              }
            }

            result = () => {
              return this.removeEvent(eventName, callback);
            };
          }

          return result;
        }

        removeEvent(eventName, callback) {
          const events = EventManager.eventsNameParser(eventName);

          if (events && this.events[events[0]] && this.events[events[0]][events[1]]) {
            if (callback) {
              const index = this.events[events[0]][events[1]].indexOf(callback);

              if (index >= 0) {
                this.events[events[0]][events[1]].splice(index, 1);
                return true;
              }
            } else {
              delete this.events[events[0]][events[1]];
              return true;
            }
          }

          return false;
        }

      }

      return EventManager;
    });
    Sirv.define('ContextMenu', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions'], (bHelpers, magicJS, globalVariables, globalFunctions) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const getViewPort = pad => {
        const size = $J.W.size;
        const scroll = $J.W.scroll;
        pad = pad || 0;
        return {
          left: pad,
          right: size.width - pad,
          top: pad,
          bottom: size.height - pad,
          x: scroll.x,
          y: scroll.y
        };
      }; // eslint-disable-next-line no-unused-vars


      class ContextmenuInstance {
        constructor(target, data, cssPrefix) {
          if (undefined === cssPrefix) {
            cssPrefix = 'magic';
          }

          this.CSS_CLASS = cssPrefix + '-contextmenu';
          this.target = target; // Menu container

          this.conext = null;
          this.overlay = null;
          this.items = {}; // this.data = data;

          this.active = false;
          this.showBind = null;
          this.hideBind = null;
          this.hideOnScrollBind = null;
          this.context = null;
          this._canShow = true;
          this._position = {
            top: null,
            left: null
          };
          this._fullScreenBox = null;
          this.setup(data || []);
        }

        get position() {
          return {
            top: this._position.top,
            left: this._position.left
          };
        }

        isExist(idOfItem) {
          return !!this.items[idOfItem];
        }

        setup(data) {
          this.context = $J.$new('ul').addClass(this.CSS_CLASS).addEvent(['contextmenu', 'dragstart', 'selectstart'], e => {
            e.stop();
          });
          data.forEach(item => {
            this.addItem(item);
          });
          this.hideFX = new $J.FX(this.context, {
            duration: 200,
            onComplete: () => {
              this.context.remove();
            }
          });
          this.target.addEvent('contextmenu', this.showBind = this.show.bind(this)); // this.overlay = $J.$new('div').setCss({
          //     'background-image': 'url(\'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=\')',
          //     display: 'block',
          //     overflow: 'hidden',
          //     'z-index': '2147483647',
          //     position: 'fixed',
          //     top: 0, bottom: 0, left: 0, right: 0,
          //     width: 'auto', height: 'auto'
          // })

          this.overlay = $J.$new('div').addClass(this.CSS_CLASS + '-overlay').addEvent('click contextmenu', this.hide.bind(this)) // .addEvent('', this.hideBind = this.hide.bind(this))
          .addEvent('mousescroll', e => {
            e.stop(); // this.hide();

            $(e).events[0].stop().stopQueue();
          });
          this.hideBind = $(e => {
            if (!this.active) {
              return;
            }

            e.stop();

            if (e.originEvent.keyCode === 27) {
              // Esc
              this.hide();
            }
          }).bind(this);
          $J.W.addEvent('keydown', this.hideBind, 1); // eslint-disable-next-line no-unused-vars

          this.hideOnScrollBind = $(e => {
            if (!this.active) {
              return;
            }

            this.hide();
          }).bind(this);
          $J.W.addEvent('scroll', this.hideOnScrollBind);
        }

        addItem(data) {
          const _ = this;

          const item = $J.$new('li').appendTo(this.context);

          if ($J.defined(data.separator)) {
            item.addClass('menu-separator');
          } else if ($J.defined(data.label)) {
            item.append($J.D.node.createTextNode(data.label));

            if ($J.defined(data.disabled) && data.disabled === true) {
              item.attr('disabled', true);
            }

            if ($J.typeOf(data.action) === 'function') {
              // item.addEvent('click', (e) {
              item.addEvent('btnclick', e => {
                e.stop();

                if (!item.attr('disabled')) {
                  _.hide();

                  data.action.call(data.action, _.position);
                }
              });
            }
          }

          if ($J.defined(data.hidden) && data.hidden === true) {
            item.setCss({
              display: 'none'
            });
          }

          const id = data.id || 'item-' + Math.floor(Math.random() * +new Date());
          this.items[id] = item;
          return id;
        }

        hideItem(id) {
          if (this.items[id]) {
            $(this.items[id]).setCss({
              display: 'none'
            });
          }
        }

        showItem(id) {
          if (this.items[id]) {
            $(this.items[id]).setCss({
              display: ''
            });
          }
        }

        disableItem(id) {
          if (this.items[id]) {
            $(this.items[id]).attr('disabled', true);
          }
        }

        enableItem(id) {
          if (this.items[id]) {
            $(this.items[id]).removeAttr('disabled');
          }
        }

        show(e) {
          let _parent = $J.D.node.body;

          if (!this._canShow) {
            return;
          }

          this.hideFX.stop();

          if ($J.browser.fullScreen.enabled()) {
            if (this._fullScreenBox || $J.D.msFullscreenElement) {
              _parent = this._fullScreenBox || $J.D.msFullscreenElement;
            }
          }

          this.overlay.appendTo(_parent);
          this.context.setCss({
            top: -10000
          }).appendTo(_parent); // this.context.setCss({ top: -10000 }).appendTo(this.overlay);

          const pos = e.clientXY;
          let left = pos.x;
          let top = pos.y;
          const page = e.pageXY;
          this._position.top = page.y;
          this._position.left = page.x;
          const viewport = getViewPort(5);
          const size = this.context.size;

          if (viewport.right < left + size.width) {
            left -= size.width;
          }

          if (viewport.bottom < top + size.height) {
            top = viewport.bottom - size.height;
          }

          this.context.setCss({
            top: top,
            left: left,
            display: 'block',
            opacity: 1
          });
          this.active = true;
        }

        hide(e) {
          if (!this.active) {
            return;
          }

          this.overlay.remove();
          this.hideFX.start({
            'opacity': [1, 0]
          });
          this.active = false;

          if (e) {
            e.stopDefaults();

            if (e.type === 'contextmenu') {
              const p = e.pageXY;
              const r = this.target.rect;

              if (r.left <= p.x && r.right >= p.x && r.top <= p.y && r.bottom >= p.y) {
                this.show(e);
              }
            }
          }
        }
        /**
         * @param {boolean} canShow
         */


        set canShow(canShow) {
          this._canShow = canShow;
        }
        /**
         * @param {HTMLElement} fullScreenBox
         */


        set fullScreenBox(fullScreenBox) {
          this._fullScreenBox = fullScreenBox;
        }

        destroy() {
          this.target.removeEvent('contextmenu', this.showBind);
          $J.W.removeEvent('keydown', this.hideBind).removeEvent('scroll', this.hideOnScrollBind);

          try {
            this.context.kill();
          } catch (ex) {// empty
          }

          try {
            this.overlay.kill();
          } catch (ex) {// empty
          }
        }

      }

      return ContextmenuInstance;
    });
    Sirv.define('BaseInstance', ['bHelpers', 'magicJS', 'EventEmitter', 'helper'], (bHelpers, magicJS, EventEmitter, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* global EventEmitter, helper */

      /* eslint-disable class-methods-use-this */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const DEFAULT_PREFIX = 'smv-';

      class BaseInstance extends EventEmitter {
        constructor(node, options, defaultSchema) {
          super();
          this.defaultSchema = defaultSchema;
          this._options = options;
          this.instanceNode = $(node);
          this.instanceUrl = this.instanceNode.attr('data-src') || this.instanceNode.attr('src') || this.instanceNode.attr('data-bg-src');
          this.option = null;
          this.ready = false;
          this.id = null;
          this.isCustomId = false;
          this.isStartedFullInit = false;
          this.isStarted = false;
          this.destroyed = false;
          this.referrerPolicy = this.instanceNode.attr('data-referrerpolicy') || this.instanceNode.attr('referrerpolicy') || 'no-referrer-when-downgrade';
          this.instanceOptions = this.makeOptions();
          this.createOptionFunction();
          const this_ = this;
          this.api = {
            isReady: () => {
              return this_.ready;
            },
            resize: this_.resize,
            getOptions: this_.options
          };
        }

        setOptions(optInstance, common, local, attr) {
          optInstance.fromJSON(common);
          optInstance.fromString(local);
          optInstance.fromString(attr);
          return optInstance;
        }

        makeGlobalOptions(optionsInstance) {
          const o = this._options.options;
          return this.setOptions(optionsInstance, o.common.common, o.local.common, this.instanceNode.attr('data-options') || '');
        }

        makeMobileOptions(optionsInstance) {
          const o = this._options.options;
          return this.setOptions(optionsInstance, o.common.mobile, o.local.mobile, this.instanceNode.attr('data-mobile-options') || '');
        }

        makeOptions() {
          let options = new $J.Options(this.defaultSchema);
          options = this.makeGlobalOptions(options);

          if ($J.browser.touchScreen && $J.browser.mobile) {
            options = this.makeMobileOptions(options);
          }

          return options;
        }

        getOptionsForStartFullInit(options) {
          if (options) {
            this._options.options = options;
            this.instanceOptions = this.makeOptions();
            this.createOptionFunction();
          }
        }

        get options() {
          return this.instanceOptions.getJSON();
        }

        resize() {
          if (this.ready) {
            return this.onResize();
          }

          return false;
        }

        onResize() {
          return true;
        }

        get imageClassContainer() {
          return {};
        }

        checkImage(setts, dontLoad) {
          let result;
          const imageClass = this.imageClassContainer;

          if (dontLoad) {
            result = imageClass.isExist(setts); // because we do not load images with imageclass
          } else {
            result = imageClass.isLoaded(setts);
          }

          return result;
        }

        getId(idPrefix, df) {
          this.id = this.instanceNode.attr('id');

          if (!this.id) {
            this.isCustomId = true;

            if (!idPrefix) {
              idPrefix = 'component-';
            }

            if (!df) {
              df = DEFAULT_PREFIX;
            }

            this.id = df + idPrefix + helper.generateUUID();
            this.id = this.id.trim();
            this.instanceNode.attr('id', this.id);
          }
        }

        createOptionFunction() {
          this.option = (...args) => {
            if (args.length > 1) {
              return this.instanceOptions.set(args[0], args[1]);
            }

            return this.instanceOptions.get(args[0]);
          };
        }

        startFullInit(options) {
          if (this.destroyed || this.isStartedFullInit) {
            return;
          }

          this.isStartedFullInit = true;
          this.getOptionsForStartFullInit(options);
        }

        get originImageUrl() {
          return null;
        } // instance 'start' metod rename to 'run'


        run() {
          if (!this.isStarted) {
            this.isStarted = true;
            return true;
          }

          return false;
        }

        done() {
          this.ready = true;
        }

        destroy() {
          this.destroyed = true;
          this.isStarted = false;
          this.ready = false;
          this.isStartedFullInit = false;

          if (this.isCustomId) {
            this.instanceNode.removeAttr('id');
            this.isCustomId = false;
          }

          this.instanceNode = null;
          super.destroy();
        }

      }

      return BaseInstance;
    });
    Sirv.define('Instance', ['bHelpers', 'magicJS', 'globalVariables', 'BaseInstance', 'helper'], (bHelpers, magicJS, globalVariables, BaseInstance, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* global BaseInstance */

      /* global helper */

      /* eslint-disable class-methods-use-this */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars

      const createError = name => {
        return new Error('This method \'' + name + '\' is not implemented.');
      };

      class Instance extends BaseInstance {
        constructor(node, options, defaultSchema) {
          super(node, options, defaultSchema);
          this.type = globalVariables.SLIDE.TYPES.NONE;
          this.always = options.always;
          this.quality = options.quality;
          this.hdQuality = options.hdQuality;
          this.isHDQualitySet = options.isHDQualitySet;
          this.isFullscreenEnabled = options.isFullscreen;
          this.dataAlt = null;
          this.isSlideShown = false;
          this.isInView = false;
          this.preload = false;
          this.firstSlideAhead = false;
          this.infoSize = null;
          this.pinchCloud = null;
          this.onLoad = false;
          this.waitToStart = new helper.WaitToStart();
          this.waitGettingInfo = new helper.WaitToStart();
          this.gettingInfoPromise = null;
          this.fullscreenState = globalVariables.FULLSCREEN.CLOSED;
          this.on('stats', e => {
            e.data.component = globalVariables.SLIDE.NAMES[this.type];
          });
        }

        sendEvent(typeOfEvent, data) {
          if (!data) {
            data = {};
          }

          if (!data.event) {
            data.event = {};
          }

          data.id = this.id;
          data.url = this.instanceUrl;
          data.event.timestamp = +new Date();
          data.event.type = globalVariables.SLIDE.NAMES[this.type] + ':' + typeOfEvent;
          this.emit('componentEvent', {
            data: {
              type: typeOfEvent,
              data: data
            }
          });
        }

        onStartActions() {}

        onStopActions() {}

        onInView(value) {}

        onBeforeFullscreenIn(data) {}

        onAfterFullscreenIn(data) {}

        onBeforeFullscreenOut(data) {}

        onAfterFullscreenOut(data) {}

        onMouseAction(type) {}

        onSecondSelectorClick() {}

        onStopContext() {}

        loadContent() {
          return true;
        }

        loadThumbnail() {
          if (!this.destroyed) {
            this.waitToStart.start();
            return true;
          }

          return false;
        }

        startGettingInfo() {
          if (!this.destroyed) {
            this.waitGettingInfo.start();
            return true;
          }

          return false;
        }

        startFullInit(options) {
          if (this.isStartedFullInit) {
            return;
          }

          super.startFullInit(options);

          if (options) {
            this.always = options.always;
          }

          this.dataAlt = this.instanceNode.attr('data-alt');
          this.on('startActions', e => {
            e.stop();
            this.isSlideShown = true;
            this.onStartActions(e.who);
          });
          this.on('stopActions', e => {
            e.stop();
            this.isSlideShown = false;
            this.onStopActions();
          });
          this.on('inView', e => {
            e.stop();
            const iv = e.data;
            this.onInView(iv);
            this.isInView = iv;
          });
          this.setEvents();
        }

        isFullscreenActionEnded() {
          return [globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState);
        }

        setEvents() {
          this.on('beforeFullscreenIn', e => {
            e.stop();

            if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || this.destroyed) {
              return;
            }

            this.fullscreenState = globalVariables.FULLSCREEN.OPENING;
            this.onBeforeFullscreenIn(e.data);
          });
          this.on('afterFullscreenIn', e => {
            e.stop();

            if (!this.destroyed) {
              this.fullscreenState = globalVariables.FULLSCREEN.OPENED;
              this.onAfterFullscreenIn(e.data);
            }
          });
          this.on('beforeFullscreenOut', e => {
            e.stop();

            if (this.fullscreenState === globalVariables.FULLSCREEN.CLOSED || this.destroyed) {
              return;
            }

            this.fullscreenState = globalVariables.FULLSCREEN.CLOSING;
            this.onBeforeFullscreenOut(e.data);
          });
          this.on('afterFullscreenOut', e => {
            e.stop();

            if (!this.destroyed) {
              this.fullscreenState = globalVariables.FULLSCREEN.CLOSED;
              this.onAfterFullscreenOut(e.data);
            }
          });
        }

        getSelectorImgUrl(data) {
          return Promise.reject(createError('getSelectorImgUrl'));
        }

        getInfoSize() {
          return Promise.reject(createError('getInfoSize'));
        }

        run(isShown, preload, firstSlideAhead) {
          const result = super.run();

          if (result) {
            this.isSlideShown = isShown;
            this.preload = preload;
            this.firstSlideAhead = firstSlideAhead;

            if (!this.firstSlideAhead) {
              this.waitToStart.start();
            }
          }

          return result;
        }

        getThumbnailData() {
          return {
            src: null
          };
        }

        getSocialButtonData(data) {
          const opt = data;

          if (this.infoSize.width < data.width || this.infoSize.height < data.height) {
            opt.width = this.infoSize.width;
            opt.height = this.infoSize.height;
          }

          const thumbnailData = this.getThumbnailData(opt);
          return thumbnailData.src;
        }

        createPinchEvent(node) {
          const pinchCloud = {
            isAdded: false,
            pinch: false,
            scale: 0,
            block: false,
            onPinchStart: e => {},
            onPinchResize: e => {},
            onPinchMove: e => {},
            onPinchEnd: e => {
              if (pinchCloud.pinch) {
                pinchCloud.pinch = false;
                this.sendEvent('pinchEnd');
              }

              pinchCloud.block = false;
            },
            handler: e => {
              switch (e.state) {
                case 'pinchstart':
                  pinchCloud.onPinchStart(e);
                  break;

                case 'pinchresize':
                  pinchCloud.onPinchResize(e);
                  break;

                case 'pinchmove':
                  pinchCloud.onPinchMove(e);
                  break;

                case 'pinchend':
                  pinchCloud.onPinchEnd(e);
                  break;

                default:
              }

              if (pinchCloud.pinch) {
                e.stop();
              }
            },
            addEvent: () => {
              if (!pinchCloud.isAdded && $J.browser.touchScreen) {
                node.addEvent('pinch', pinchCloud.handler);
                pinchCloud.isAdded = true;
              }
            },
            removeEvent: () => {
              if (pinchCloud.isAdded) {
                node.removeEvent('pinch', pinchCloud.handler);
                pinchCloud.isAdded = false;
                pinchCloud.block = false;
                pinchCloud.pinch = false;
              }
            }
          };
          pinchCloud.addEvent();
          this.pinchCloud = pinchCloud;
        }

        done() {
          super.done();
          this.createPinchEvent();
          this.on('resize', e => {
            e.stop();
            this.onResize();
          });
          this.on('stopContext', e => {
            e.stop();
            this.onStopContext();
          });
          this.on('secondSelectorClick', e => {
            e.stopAll();
            this.onSecondSelectorClick();
          });
          this.on('mouseAction', e => {
            e.stop();
            this.onMouseAction(e.data.type);
          });
          this.on('dragEvent', e => {
            e.stop();

            if (this.pinchCloud) {
              if (e.data.type === 'dragstart') {
                this.pinchCloud.removeEvent();
              } else if (e.data.type === 'dragend') {
                this.pinchCloud.addEvent();
              }
            }
          });
          this.sendEvent('ready');
        }

        sendContentLoadedEvent() {
          if (!this.onLoad) {
            this.onLoad = true;
            this.sendEvent('contentLoaded');
          }
        }

        destroy() {
          this.off('stats');
          this.off('startActions');
          this.off('stopActions');
          this.off('inView');
          this.off('resize');
          this.off('stopContext');
          this.off('secondSelectorClick');
          this.off('mouseAction');
          this.off('dragEvent');
          this.off('beforeFullscreenIn');
          this.off('afterFullscreenIn');
          this.off('beforeFullscreenOut');
          this.off('afterFullscreenOut');
          this.pinchCloud = null;
          this.isSlideShown = false;
          super.destroy();
          this.waitGettingInfo.destroy();
          this.waitGettingInfo = null;
          this.waitToStart.destroy();
          this.waitToStart = null;
          this.gettingInfoPromise = null;
        }

      }

      return Instance;
    });
    Sirv.define('HotspotInstance', ['bHelpers', 'magicJS', 'Instance'], (bHelpers, magicJS, Instance) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* global Instance */

      /* eslint-disable class-methods-use-this */

      /* eslint-disable no-unused-vars */

      /* eslint no-console: ["error", { allow: ["warn"] }] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const warn = (v1, v2) => {
        console.warn('sirv.js: The ' + v1 + ' method is deprecated and will be removed. \r\n           Use ' + v2 + ' instead.');
      }; // eslint-disable-next-line no-unused-vars


      class HotspotInstance extends Instance {
        constructor(node, options, defaultSchema) {
          super(node, options, defaultSchema); // this variable is usin in spin, zoom and image component

          this.hotspots = null; // API

          const this_ = this;
          this.api = Object.assign(this.api, {
            addHotspot: hotspotsData => {
              warn('.addHotspot()', '.hotspots.add()');
              this_.hotspots.api.add(hotspotsData);

              if (this_.isInView && this_.isSlideShown) {
                this_.hotspots.showNeededElements();
              }
            },
            removeHotspot: index => {
              warn('.removeHotspot()', '.hotspots.remove()');
              this_.hotspots.api.remove(index);
            },
            removeAllHotspots: () => {
              warn('.removeAllHotspots()', '.hotspots.removeAll()');
              this_.hotspots.api.removeAll();
            },
            getHotspots: () => {
              warn('.getHotspots()', '.hotspots.list()');
              return this_.hotspots.api.list();
            }
          });
        }

        createHotspotsClass(HotspotsClass, hotspotOptions) {
          this.hotspots = new HotspotsClass(hotspotOptions);
          this.hotspots.parentClass = this;
          this.on('hotspotActivate', e => {
            e.stopAll();
            this.onHotspotActivate(e.data);
            this.sendEvent('hotspotOpened');
          });
          this.on('hotspotDeactivate', e => {
            e.stopAll();
            this.onHotspotDeactivate(e.data);
            this.sendEvent('hotspotClosed');
          });
          this.api = Object.assign(this.api, {
            hotspots: this.hotspots.api
          });
          const this_ = this;

          this.api.hotspots.add = hsData => {
            if (hsData) {
              let clientRect = null;

              if (!this_.hotspots.api.list().length) {
                const parentContainer = this.getParentContainer();
                clientRect = this_.hotspots.getRightBoundengClientRect(this.getContainerForBoundengClientRect());
                this_.hotspots.appendTo(parentContainer);
              }

              this_.hotspots.addHotspot(hsData);
              this_.hotspots.containerSize = clientRect;
              this_.hotspots.showAll();

              if (this_.isInView && this_.isSlideShown) {
                this_.hotspots.showNeededElements();
              }
            }
          };
        }

        getContainerForBoundengClientRect() {
          return this.getParentContainer();
        }

        done() {
          if (!this.ready && !this.destroyed && this.hotspots) {
            let parentContainer = this.instanceNode;

            if (parentContainer.tagName === 'img') {
              parentContainer = $(parentContainer.node.parentNode);
            }

            this.hotspots.appendTo(parentContainer);
            this.hotspots.createHotspots(this.hotspotsData);

            if (this.nativeFullscreen) {
              this.hotspots.changeBoxContainerParent(true);
            }

            this.hotspots.showAll();
          }

          super.done();
        }

        getParentContainer() {
          let parentContainer = this.instanceNode;

          if (parentContainer.tagName === 'img') {
            parentContainer = $(parentContainer.node.parentNode);
          }

          return parentContainer;
        }

        onHotspotActivate(data) {}

        onHotspotDeactivate(data) {}

        onStartActions() {
          if (this.hotspots && this.isInView && this.isSlideShown) {
            this.hotspots.showNeededElements();
          }

          super.onStartActions();
        }

        onStopActions() {
          if (this.hotspots) {
            this.hotspots.hideActiveHotspotBox(true);
          }

          super.onStopActions();
        }

        onBeforeFullscreenIn(data) {
          if (this.hotspots) {
            this.hotspots.hideActiveHotspotBox();

            if (this.nativeFullscreen) {
              this.hotspots.changeBoxContainerParent(true);
            }
          }
        }

        onBeforeFullscreenOut(data) {
          if (this.hotspots) {
            this.hotspots.hideActiveHotspotBox();

            if (this.nativeFullscreen) {
              this.hotspots.changeBoxContainerParent();
            }
          }
        }

        onAfterFullscreenOut(data) {
          if (this.hotspots && this.isInView && this.isSlideShown) {
            this.hotspots.showNeededElements();
          }
        }

        destroy() {
          if (this.hotspots) {
            this.hotspots.destroy();
          }

          this.hotspots = null;
          this.off('hotspotActivate');
          this.off('hotspotDeactivate');
          super.destroy();
        }

      }

      return HotspotInstance;
    });
    Sirv.define('Loader', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global EventEmitter */

      /* global $J */

      /* global $ */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint dot-notation: ["error", { "allowKeywords": false }]*/
      // eslint-disable-next-line no-unused-vars

      class Loader extends EventEmitter {
        constructor(parent, options) {
          super();
          this.parentNode = $(parent);
          this.options = Object.assign({
            width: null,
            height: null,
            'class': null
          }, options || {});
          this.node = $J.$new('div').addClass('smv-loader');
          this.type = 'simple';
          this.inDoc = false;

          if (this.options['class']) {
            this.node.addClass(this.options['class']);
          }

          if (this.options.width) {
            this.node.setCssProp('width', this.options.width);
          }

          if (this.options.height) {
            this.node.setCssProp('height', this.options.height);
          }
        }

        append() {
          if (!this.inDoc) {
            this.inDoc = true;
            this.parentNode.append(this.node);
          }
        }

        show() {
          this.append();
          this.node.setCss({
            display: '',
            visibility: 'visible'
          });
        }

        hide() {
          this.node.setCss({
            display: 'none',
            visibility: 'hidden'
          });
        }

        destroy() {
          this.hide();
          this.node.remove();
          this.node = null;
          this.inDoc = false;
          super.destroy();
        }

      }

      return Loader;
    });
    Sirv.define('RoundLoader', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'Loader'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, Loader) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global Loader */

      /* global $J */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const SHOW_CLASS = 'smv-show'; // eslint-disable-next-line no-unused-vars

      class RoundLoader extends Loader {
        constructor(parent, options) {
          super(parent, options);
          this.type = 'round';
          this.state = globalVariables.APPEARANCE.HIDDEN;
          this.timer = null;
          this.loaderElement = $J.$new('div');
          this.addClass();
          this.node.append(this.loaderElement);
        }

        addClass() {
          this.node.addClass('smv-round-loader');
        }

        isHiding() {
          return this.state === globalVariables.APPEARANCE.HIDING;
        }

        show() {
          if ([globalVariables.APPEARANCE.SHOWING, globalVariables.APPEARANCE.SHOWN].includes(this.state)) {
            return;
          }

          this.state = globalVariables.APPEARANCE.SHOWING;
          this.timer = setTimeout(() => {
            this.timer = null;
            this.append();
            this.node.removeEvent('transitionend');
            this.node.addEvent('transitionend', e => {
              e.stop();
              this.state = globalVariables.APPEARANCE.SHOWN;
            });
            this.node.render();
            this.node.addClass(SHOW_CLASS);
          }, 250);
        }

        hide(force) {
          if (this.state === globalVariables.APPEARANCE.HIDDEN && !force) {
            return;
          }

          clearTimeout(this.timer);
          this.node.removeEvent('transitionend');

          if (this.state !== globalVariables.APPEARANCE.SHOWN) {
            force = true;
          }

          this.state = globalVariables.APPEARANCE.HIDING;

          if (!force) {
            this.node.addEvent('transitionend', e => {
              e.stop();
              this.node.remove();
              this.inDoc = false;
              this.state = globalVariables.APPEARANCE.HIDDEN;
            });
          } else {
            this.node.remove();
            this.inDoc = false;
            this.state = globalVariables.APPEARANCE.HIDDEN;
          }

          this.node.removeClass(SHOW_CLASS);
        }

        destroy() {
          this.hide(true);
          this.state = globalVariables.APPEARANCE.HIDDEN;
          this.node.innerHTML = '';
          super.destroy();
        }

      }

      return RoundLoader;
    });
    Sirv.define('ComponentLoader', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'RoundLoader'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, RoundLoader) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global RoundLoader */

      /* global $J */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const setDefaultOptions = options => {
        if (!options) {
          options = {};
        }

        if (!options.width) {
          options.width = '100%';
        }

        if (!options.height) {
          options.height = '100%';
        }

        return options;
      }; // eslint-disable-next-line no-unused-vars


      class ComponentLoader extends RoundLoader {
        constructor(parent, options) {
          options = setDefaultOptions(options);
          super(parent, options);
          this.type = 'component';
          this.loaderElement.addClass('smv-bounce-wrapper').append($J.$new('div').addClass('smv-bounce1')).append($J.$new('div').addClass('smv-bounce2'));
        }

        addClass() {
          this.node.addClass('smv-component-loader');
        }

        destroy() {
          this.loaderElement.removeClass('smv-bounce-wrapper');
          this.loaderElement.node.innerHTML = '';
          super.destroy();
        }

      }

      return ComponentLoader;
    });
    Sirv.define('ResponsiveImage', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global Promise */

      /* global helper */

      /* eslint-disable indent */

      /* eslint-disable no-lonely-if*/

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /*
          Image class
              params:
                  name - name of image
                  url - image url,
                  srcSettings - settings which has current image
                  srcsetSettings - x2 settings which has current image
      */
      // eslint-disable-next-line no-unused-vars

      const requestCORSIfNotSameOrigin = (img, url) => {
        if (new URL(url).origin !== $J.W.location.origin) {
          img.crossOrigin = '';
        }
      };

      const getUrl = (url, settings) => {
        // let result = url + ('?' + paramsToQueryString(settings).replace(/(?:\?|&)profile\=$/, ''));
        let result = url + ('?' + helper.paramsToQueryString(settings));
        result = helper.cleanQueryString(result);
        return result;
      }; // eslint-disable-next-line no-unused-vars


      class _Image {
        constructor(name, url, srcSettings, srcsetSettings, dontLoad, referrerPolicy) {
          this._name = name;
          this._state = 0; // not-loaded = 0, loading = 1, loaded = 2, error = 3

          this.imageNode = null;
          this._size = {
            width: 0,
            height: 0
          };
          this.loader = null;
          this.callbacks = [];
          this.srcSettings = srcSettings;
          this.srcsetSettings = srcsetSettings;
          this.dontLoad = dontLoad;
          this.dppx = this.srcsetSettings ? this.srcsetSettings.dppx : 1;
          this.referrerPolicy = referrerPolicy;

          if (srcSettings.profile === '') {
            delete srcSettings.profile;
          }

          if (srcsetSettings && srcsetSettings.profile === '') {
            delete srcsetSettings.profile;
          }

          this._src = getUrl(url, srcSettings);
          this._srcset = null;

          if (srcsetSettings) {
            this._srcset = getUrl(url, srcsetSettings.settings);
          }
        }

        get name() {
          return this._name;
        }

        get node() {
          return this.imageNode;
        }

        get size() {
          return this._size;
        }

        get src() {
          return this._src;
        }

        get srcset() {
          return this._srcset;
        }

        get state() {
          return this._state;
        }

        get DPPX() {
          return this.dppx;
        }

        load() {
          return new Promise((resolve, reject) => {
            if (this.dontLoad) {
              resolve(this);
            } else if (!this._state) {
              this._state = 1;
              this.imageNode = $(new Image());
              this.imageNode.attr('referrerpolicy', this.referrerPolicy || 'no-referrer-when-downgrade');
              this.imageNode.addEvent('load', e => {
                e.stop();
                this._state = 2;
                this._size = {
                  width: this.imageNode.node.naturalWidth || this.imageNode.node.width,
                  height: this.imageNode.node.naturalHeight || this.imageNode.node.height
                };

                if ($J.browser.uaName === 'safari') {
                  let correct = false;

                  if (this.srcSettings.scale.width) {
                    if (this._size.width > this.srcSettings.scale.width + 5) {
                      correct = true;
                    }
                  } else {
                    if (this._size.height > this.srcSettings.scale.height + 5) {
                      correct = true;
                    }
                  }

                  if (correct) {
                    this._size.width /= this.dppx;
                    this._size.height /= this.dppx;
                  }
                }

                resolve(this);
              });
              this.imageNode.addEvent('error', e => {
                e.stop();
                this._state = 3;
                this.imageNode = null;
                reject(this);
              }); // requestCORSIfNotSameOrigin(this.imageNode.node, this.src);

              this.addSrc();
              this.addSrcset();
              this.imageNode.node.src = this._src;
            } else {
              resolve(this);
            }
          });
        }

        addSrc() {
          this.imageNode.node.src = this._src;
        }

        addSrcset() {
          if (this._srcset) {
            // TODO because amount of tiles are different between 1x image and 1.5x image
            // this.imageNode.node.srcset = encodeURI(this.srcset) + ' 2x';
            // this.imageNode.node.srcset = this.srcset + ' 2x';
            this.imageNode.node.srcset = this._srcset + ' ' + this.dppx + 'x';
          }
        }

        get loading() {
          return this._state === 1;
        }

        destroy() {
          if (this._state === 1 && this.imageNode) {
            this.imageNode.attr('src', 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=');
          }

          this._state = 0;
        }

      }
      /* eslint-env es6 */

      /* global _Image */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      class _TileImage extends _Image {
        constructor(name, url, srcSettings, srcsetSettings, dontLoad, referrerPolicy, tileName) {
          super(name, url, srcSettings, srcsetSettings, dontLoad, referrerPolicy);
          this._tileName = tileName; // name of tile
        }

        get tileName() {
          return this._tileName;
        }

        addSrc() {
          if (this.dppx === 1) {
            // TODO because amount of tiles are different between 1x image and 1.5x image
            super.addSrc();
          }
        }

      }
      /* eslint-env es6 */

      /* global _Image, _TileImage, helper, EventEmitter */

      /* eslint-disable indent */

      /* eslint-disable no-console */

      /* eslint-disable no-lonely-if */

      /* eslint no-prototype-builtins: "off" */

      /* eslint no-useless-escape: "off" */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint class-methods-use-this: ["off", { "_createImageData": ["error"] }] */

      /*
          RImage class
          params:
              source - sirv image url
              o - options
              infoId - id for info object (to save in global object IMAGE_INFO) or will be generated automatically
      
          public functions:
              getClearSizeWithoutProcessingSettings
              isExist
              isLoaded
              ready
              originSize
              sendLoad
              cancelLoadingImage
              generateImageName
              getImage
              originUrl
              getProcessingSettings
              getThumbnail
              destroy
      
          public events:
              'imageOnload' - fire when the image was loaded
      
          example:
          this.images = {
              '123234345456' (it is name of image): {
                  serverWidth: 150,
                  serverHeight: 150,
                  image: _Image class
              },
          };
      
      */


      const splitOptions = (imageSettings, dppx) => {
        const src = Object.assign({}, imageSettings);
        delete src.src;
        delete src.srcset;
        src.imageSettings = Object.assign({}, imageSettings?.imageSettings || {});
        let srcset;

        if (dppx > 1) {
          srcset = JSON.parse(JSON.stringify(src));

          if (srcset.width) {
            srcset.width = parseInt(srcset.width * dppx, 10);
          }

          if (srcset.height) {
            srcset.height = parseInt(srcset.height * dppx, 10);
          }

          if (srcset.imageSettings.crop) {
            if (srcset.imageSettings.crop.width) {
              srcset.imageSettings.crop.width = parseInt(srcset.imageSettings.crop.width * dppx, 10);
            }

            if (srcset.imageSettings.crop.height) {
              srcset.imageSettings.crop.height = parseInt(srcset.imageSettings.crop.height * dppx, 10);
            }
          }

          srcset.dppx = dppx;
        }

        src.imageSettings = Object.assign(src.imageSettings, imageSettings.src);

        if (srcset && imageSettings.srcset) {
          srcset.imageSettings = Object.assign(srcset.imageSettings, imageSettings.srcset);
        }

        return {
          src: src,
          srcset: srcset
        };
      };

      const getOriginUrl = source => {
        return source.split('?')[0];
      };

      const toPercentageString = v => {
        return (v * 100).toFixed(4) + '%';
      };

      const generateImageName = url => {
        url = url.replace('\?+', '?').replace('&+', '&').split('?');
        let hash = url[1];
        url = url[0];
        hash = hash.split('&').sort();
        return '' + $J.getHashCode(url + '?' + hash.join('&'));
      };

      const getPropFromCrop = (obj, name) => {
        if (obj && obj.crop && obj.crop[name]) {
          return obj.crop[name];
        }

        return null;
      };

      const mixSettings = (info, defaultImageSettings, imageSettings) => {
        let result = helper.deepExtend({}, defaultImageSettings);

        if (info && info.imageSettings.processingSettings) {
          if (!result.crop) {
            result.crop = {};
          }

          result.crop = helper.deepExtend(result.crop, info.cropSettings); // if (result.crop) {
          //     if (result.crop.width && /100(\.0*)?%/.test(result.crop.width)) {
          //         delete result.crop.width;
          //     }
          //     if (result.crop.height && /100(\.0*)?%/.test(result.crop.height)) {
          //         delete result.crop.height;
          //     }
          // }

          if (!result.canvas) {
            result.canvas = {};
          }

          result.canvas = helper.deepExtend(result.canvas, info.canvasSettings);

          if (!result.frame) {
            result.frame = {};
          }

          result.frame = helper.deepExtend(result.frame, info.frameSettings);

          if (!result.scale) {
            result.scale = {};
          }

          if (!result.scale.option) {
            result.scale.option = 'fill';
          }
        }

        if (imageSettings.width && imageSettings.width !== 'auto') {
          result.scale.width = imageSettings.width;
        }

        if (imageSettings.height && imageSettings.height !== 'auto') {
          result.scale.height = imageSettings.height;
        }

        if (imageSettings.imageSettings) {
          result = helper.deepExtend(result, imageSettings.imageSettings);
        } // if (getPropFromCrop(defaultImageSettings, 'type') === 'focalpoint' || getPropFromCrop(info.imageSettings.processingSettings, 'type') === 'focalpoint') {
        //     const x = getPropFromCrop(defaultImageSettings, 'x') || getPropFromCrop(info.imageSettings.processingSettings, 'x');
        //     if (x) {
        //         result.crop.x = x;
        //     }
        //     const y = getPropFromCrop(defaultImageSettings, 'y') || getPropFromCrop(info.imageSettings.processingSettings, 'y');
        //     if (y) {
        //         result.crop.y = y;
        //     }
        //     result.scale = {};
        // }


        return result;
      };

      const INFO = 'sirv_image_info_';
      const IMAGE_INFO = {}; // eslint-disable-next-line no-unused-vars

      class RImage extends EventEmitter {
        constructor(source, o) {
          super();

          if ($J.typeOf(source) !== 'string') {
            source = $(source).attr('src');
          }

          this.o = Object.assign({
            type: 'main',
            infoId: 'sirv-image-' + helper.generateUUID(),
            imageSettings: {},
            round: true,
            dontLoad: false,
            convertSmallerSideToZero: true,
            referrerPolicy: 'no-referrer-when-downgrade',

            /*
                loadNewImage:
                true - if image is missing - load image
                false - if image is missing but if bigger image is exist give large image else load image
            */
            loadNewImage: false
          }, o);
          this.imageInfoPromise = null;
          this.images = {};
          this._originUrl = getOriginUrl($J.getAbsoluteURL(source));
          this.infoUrl = this._originUrl + '?nometa&info';
          this.imageSettings = Object.assign({}, this.o.imageSettings);
        }

        static roundImageSize(size, originSize) {
          let tmp;

          if (!originSize) {
            originSize = {
              width: Number.MAX_VALUE,
              height: Number.MAX_VALUE
            };
          }

          if (size.width && size.height) {
            if (size.width >= size.height) {
              tmp = helper.roundSize(size.width);

              if (tmp <= originSize.width) {
                size.height = Math.floor(size.height / size.width * tmp);
                size.width = tmp;
              }
            } else {
              tmp = helper.roundSize(size.height);

              if (tmp <= originSize.height) {
                // size.width = Math.round((size.width / size.height) * tmp);
                // firefox
                // fix 'https://github.com/sirv/sirv.js/issues/148'
                // We need to use 'Math.floor' because this image 'https://demo.sirv.com/demo/vax/2759311-g.jpg?scale.option=fill&h=500' has wrong size in zoom
                size.width = Math.floor(size.width / size.height * tmp);
                size.height = tmp;
              }
            }
          } else if (size.width) {
            tmp = helper.roundSize(size.width);

            if (tmp <= originSize.width) {
              size.width = tmp;
            }
          } else if (size.height) {
            tmp = helper.roundSize(size.height);

            if (tmp <= originSize.height) {
              size.height = tmp;
            }
          }

          return size;
        }

        _convertImageSettings(imageSettings) {
          const setSize = (obj, size) => {
            if (size.width) {
              obj.width = size.width;
            }

            if (size.height) {
              obj.height = size.height;
            }
          };

          if (!imageSettings) {
            imageSettings = {};
          }

          imageSettings = Object.assign({}, imageSettings); // correct tile size if we have canvas border

          let tmp = this.getClearSizeWithoutProcessingSettings({
            width: imageSettings.width,
            height: imageSettings.height
          });
          setSize(imageSettings, tmp);
          const result = splitOptions(imageSettings, imageSettings.dppx);

          if (imageSettings.round || !imageSettings.hasOwnProperty('round') && this.o.round) {
            const originSize = this.originSize;
            tmp = RImage.roundImageSize(result.src, originSize);
            setSize(result, tmp);

            if (result.srcset) {
              tmp = RImage.roundImageSize(result.srcset, originSize);
              setSize(result, tmp);
            }
          }

          return result;
        }

        _mixSettings(settings) {
          return mixSettings(IMAGE_INFO[this.o.infoId], this.imageSettings, settings);
        }

        _calcProcessingSettings() {
          let info = IMAGE_INFO[this.o.infoId];
          const cropSettings = {};
          const canvasSettings = {};
          const frameSettings = {};

          if (!info.imageSettings.viewer) {
            info.imageSettings.viewer = {};
          }

          const viewer = info.imageSettings.viewer;
          const originSize = {
            width: info.imageSettings.original.width,
            height: info.imageSettings.original.height,
            widthScale: 1,
            heightScale: 1
          };

          if (viewer.scale) {
            if (viewer.scale.width) {
              originSize.width *= viewer.scale.width;
            }

            if (viewer.scale.height) {
              originSize.height *= viewer.scale.height;
            }
          }

          originSize.widthScale = originSize.width / info.imageSettings.width;
          originSize.heightScale = originSize.height / info.imageSettings.height;

          if (viewer.crop) {
            if (viewer.crop.width) {
              cropSettings.width = toPercentageString(viewer.crop.width);
            }

            if (viewer.crop.height) {
              cropSettings.height = toPercentageString(viewer.crop.height);
            }

            if (viewer.crop.x) {
              cropSettings.x = toPercentageString(viewer.crop.x);
            }

            if (viewer.crop.y) {
              cropSettings.y = toPercentageString(viewer.crop.y);
            }
          }

          if (viewer.canvas) {
            if (viewer.canvas.width) {
              canvasSettings.width = toPercentageString(viewer.canvas.width);
            }

            if (viewer.canvas.height) {
              canvasSettings.height = toPercentageString(viewer.canvas.height);
            }

            if (viewer.canvas.border) {
              canvasSettings.border = {};

              if (viewer.canvas.border.width) {
                canvasSettings.border.width = toPercentageString(viewer.canvas.border.width);
              }

              if (viewer.canvas.border.height) {
                canvasSettings.border.height = toPercentageString(viewer.canvas.border.height);
              }
            }
          }

          if (viewer.frame && viewer.frame.width) {
            frameSettings.width = toPercentageString(viewer.frame.width);
          }

          info = Object.assign(info, {
            cropSettings: cropSettings,
            canvasSettings: canvasSettings,
            frameSettings: frameSettings,
            originSize: originSize
          });
        }

        _addImage(name, imageSettings) {
          const dontLoad = $J.defined(imageSettings.src.dontLoad) ? imageSettings.src.dontLoad : this.o.dontLoad;

          const getSettings = sett => {
            const result = this._mixSettings(sett);

            if (result.scale && result.scale.width && result.scale.height && result.scale.option !== 'ignore') {
              if (result.scale.width >= result.scale.height) {
                if (this.o.convertSmallerSideToZero) {
                  result.scale.height = 0;
                }
              } else {
                if (this.o.convertSmallerSideToZero) {
                  result.scale.width = 0;
                }
              }
            }

            return result;
          };

          const src = getSettings(imageSettings.src);
          let srcset = null;
          let tileName = null;

          if (imageSettings.src.imageSettings && imageSettings.src.imageSettings.tile) {
            const tile = imageSettings.src.imageSettings.tile;
            tileName = tile.number + '';
          }

          if (imageSettings.srcset) {
            srcset = {
              dppx: imageSettings.srcset.dppx,
              settings: getSettings(imageSettings.srcset)
            };
          }

          let imageInstance = null;

          if (tileName === null) {
            imageInstance = new _Image(name, this._originUrl, src, srcset, dontLoad, this.o.referrerPolicy);
          } else {
            imageInstance = new _TileImage(name, this._originUrl, src, srcset, dontLoad, this.o.referrerPolicy, tileName);
          }

          this.images[name] = {
            serverWidth: imageSettings.src.width,
            serverHeight: imageSettings.src.height,
            image: imageInstance
          };
          return this.images[name];
        }

        _load(name, imageSettings) {
          const img = this._addImage(name, imageSettings);

          let eventName;
          let instance;
          img.image.load().then(imgInst => {
            instance = imgInst;
            eventName = 'imageOnload';

            if (instance instanceof _Image) {
              this.someImageIsLoaded = true;
            }
          }).catch(imgInst => {
            instance = imgInst;
            eventName = 'imageOnerror';
          }).finally(() => {
            if (instance instanceof _Image) {
              this.someImageIsComplete = true;
            }

            const image = this.images[instance.name];

            if (image) {
              this.emit(eventName, {
                data: this._createImageData(image, imageSettings.src.callbackData)
              });
            }
          });
        }

        _createImageData(img, callbackData) {
          const obj = img.image;
          const result = {
            callbackData: callbackData,
            name: obj.name,
            tileName: obj.tileName,
            tile: obj instanceof _TileImage,
            node: obj.node,
            serverWidth: img.serverWidth,
            serverHeight: img.serverHeight,
            width: obj.size.width,
            height: obj.size.height,
            src: obj.src,
            srcset: obj.srcset,
            state: obj.state,
            dppx: obj.DPPX || 1
          };
          return result;
        }

        getCropPosition() {
          const info = IMAGE_INFO[this.o.infoId];
          let x = getPropFromCrop(this.imageSettings, 'x');

          if (x && !/%$/.test(x)) {
            x = toPercentageString(x / info.originSize.width);
          }

          let y = getPropFromCrop(this.imageSettings, 'y');

          if (y && !/%$/.test(y)) {
            y = toPercentageString(y / info.originSize.height);
          }

          return {
            x: x || info.cropSettings.x,
            y: y || info.cropSettings.y,
            type: getPropFromCrop(this.imageSettings, 'type') || getPropFromCrop(info.imageSettings.processingSettings, 'type')
          };
        }
        /**
         * Is image exist with current size or more
         *
         * @param {Object}    Image settings object to check
         *
         * @returns {boolean} - Returns true if the image is exist
         */


        isExist(imageSettings) {
          imageSettings = this._convertImageSettings(imageSettings);
          const name = this.generateImageName(imageSettings.src);
          let result = Object.prototype.hasOwnProperty.call(this.images, name);

          if (!result) {
            if (!(imageSettings.src.imageSettings && imageSettings.src.imageSettings.tile) && imageSettings.src.width) {
              const images = Object.entries(this.images).filter(v => v[1].image instanceof _TileImage === false).map(v => v[1]);
              result = this._getBiggerImage(imageSettings.src.width, images);
            }
          }

          return !!result;
        }
        /**
         * Is image exist with current size
         *
         * @param {Object}    Image settings object to check
         *
         * @returns {boolean} - Returns true if the image is loaded
         */


        isLoaded(imageSettings) {
          imageSettings = this._convertImageSettings(imageSettings);
          let result = this.images[this.generateImageName(imageSettings.src)];

          if (result) {
            result = result.image.state === 2;
          }

          return !!result;
        }
        /**
         * Some of image is loaded
         *
         * @returns {boolean} - Returns true if some of image is loaded
         */


        get ready() {
          return this.someImageIsLoaded;
        }

        get complete() {
          return this.someImageIsComplete;
        }
        /**
         * Returns origin size of image from image info
         *
         * @returns {Hash} Size of the image  {width: x, height: x}
         */


        get originSize() {
          let result = null;
          let info = null;

          if (IMAGE_INFO[this.o.infoId]) {
            info = IMAGE_INFO[this.o.infoId].imageSettings;
          }

          if (info) {
            let width;
            let height;

            if (info.processingSettings) {
              width = info.width;
              height = info.height;
            } else {
              width = info.original.width;
              height = info.original.height;
            }

            result = {
              width: width,
              height: height
            };
          }

          return result;
        }

        loadInfo() {
          if (!this.imageInfoPromise) {
            this.imageInfoPromise = new Promise((resolve, reject) => {
              let url = this._originUrl;
              const hash = $J.getHashCode(this.infoUrl.replace(/^http(s)?:\/\//, ''));
              const imageSettings = helper.paramsToQueryString(this.imageSettings);

              if (imageSettings !== '') {
                url += '?' + imageSettings;
                url += '&';
              } else {
                url += '?';
              }

              url += 'nometa&info=' + INFO + hash + '_' + this.o.type;
              url = helper.cleanQueryString(url);
              helper.getRemoteData(url, 'image_info_' + helper.generateUUID(), this.o.referrerPolicy).then(data => {
                if (!data.width || data._isplaceholder) {
                  reject(data);
                } else {
                  IMAGE_INFO[this.o.infoId] = {
                    imageSettings: data
                  };

                  this._calcProcessingSettings();

                  resolve(IMAGE_INFO[this.o.infoId]);
                }
              }).catch(reject);
            });
          }

          return this.imageInfoPromise;
        }

        _getBiggerImage(width, images, dontLoad) {
          if (!width) {
            width = 0;
          }

          if (!images) {
            images = this.images;
          }

          if (dontLoad === $J.U) {
            dontLoad = this.o.dontLoad;
          }

          return Object.entries(images).map(value => value[1]).sort((a, b) => a.serverWidth - b.serverWidth).find(value => width < value.serverWidth && (value.image.state === 2 || dontLoad)) || null;
        }

        sendLoad(imageSettings) {
          imageSettings = this._convertImageSettings(imageSettings);
          let img = this.images[this.generateImageName(imageSettings.src)];

          if (!img) {
            img = this._getBiggerImage(imageSettings.src.width);
          }

          this.emit('imageOnload', {
            data: this._createImageData(img, imageSettings.src.callbackData)
          });
        }
        /**
         * Cancels loading image if it is
         *
         * @param {Object}    Image settings object to cansel
         */


        cancelLoadingImage(imageSettings) {
          imageSettings = this._convertImageSettings(imageSettings);
          const name = this.generateImageName(imageSettings.src);
          const img = this.images[name];

          if (img) {
            if (img.image.loading) {
              img.image.destroy();
              delete this.images[name];
            }
          }
        }
        /**
         * Returns image name
         *
         * @param {Object}    Image settings object
         *
         * @returns {String} name of image
         */


        generateImageName(imageSettings) {
          const result = generateImageName(helper.cleanQueryString(this._originUrl + ('?' + helper.paramsToQueryString(this._mixSettings(imageSettings)))));
          return result;
        }

        getClearSizeWithoutProcessingSettings(size) {
          const result = {};
          const info = IMAGE_INFO[this.o.infoId];

          if (size.width) {
            result.width = Math.round(size.width * info.originSize.widthScale);
          }

          if (size.height) {
            result.height = Math.round(size.height * info.originSize.heightScale);
          }

          return result;
        }
        /*
         * Returns image object if it is exist or load image if it isn't
         *
         * @param {Object}    Image settings object
         *
         * @returns {object or null} Returns image object
             imageOptions {
                width: 42,
                height: 42,
                round: true/false(default false) - round max size to 100
                maxSize: true/false(default true), - if the size of image is not exist send image with bigger size
                 additionalImageSettings = {
                    ...
                    quality: 1,
                    tile: {}
                    ...
                }
            }
        */


        getImage(imageSettings) {
          const options = this._convertImageSettings(imageSettings);

          const dontLoad = $J.defined(options.src.dontLoad) ? options.src.dontLoad : this.o.dontLoad;
          const name = this.generateImageName(options.src);
          let result = this.images[name];

          if (!result) {
            this._load(name, Object.assign({}, options));
          }

          if (result && result.image.state < 2 && !dontLoad) {
            result = null;
          }

          if (!result && (options.src.maxSize || !this.o.loadNewImage)) {
            if (options.src.exactSize) {
              if (dontLoad) {
                result = this.images[name];
              }
            } else {
              result = this._getBiggerImage(null, null, dontLoad);
            }
          }

          if (result) {
            result = this._createImageData(result, options.src.callbackData);
          }

          return result;
        }
        /**
        * Returns origin url of image
        *
        * @returns {String} url
        */


        get originUrl() {
          let result = null;

          if (this._originUrl) {
            result = this._originUrl;
          }

          return result;
        }
        /**
         * Returns current processing settings
         *
         * @returns {object} processing settings
         */


        getProcessingSettings() {
          const info = IMAGE_INFO[this.o.infoId];
          return {
            crop: info.cropSettings,
            cropClear: info.cropSettingsClear,
            canvas: info.canvasSettings,
            canvasClear: info.canvasSettingsClear
          };
        }

        get description() {
          let result = null;
          const info = IMAGE_INFO[this.o.infoId];

          if (info) {
            result = info.imageSettings.original.description || null;
          }

          return result;
        }
        /**
         * Get thambnail urls (src, srcset)
         *
         * @param {Object}    Options for the image
         *
         * @returns {Object}  src, srcset and other datas
         */


        getThumbnail(imageSettings) {
          let result = {
            imageSettings: null,
            size: null,
            src: null,
            srcset: null
          };

          if (IMAGE_INFO[this.o.infoId]) {
            const options = splitOptions(imageSettings, $J.DPPX);
            let srcset = null;
            let convertSmallerSideToZero = this.o.convertSmallerSideToZero;
            const originUrl = imageSettings.originUrl || this._originUrl;

            const getSrc = (_size, _imageSettings) => {
              let settings = {
                scale: {
                  option: 'fill'
                }
              };

              if (_size.width || _size.height) {
                if (_size.width && _size.height) {
                  settings.scale.width = _size.width;
                  settings.scale.height = _size.height;
                } else {
                  const tmp = _size.width || _size.height;
                  settings.scale.width = tmp;
                  settings.scale.height = tmp;
                }
              }

              if (_size.width === _size.height) {
                if (imageSettings.crop) {
                  settings.crop = {
                    x: 'center',
                    y: 'center',
                    width: _size.width,
                    height: _size.height
                  };
                } else {
                  settings.scale.option = 'fit';

                  if (!settings.canvas) {
                    settings.canvas = {};
                  }

                  settings.canvas.width = _size.width;
                  settings.canvas.height = _size.height;
                }
              }

              if (settings.scale) {
                if (imageSettings.width && imageSettings.height) {
                  if (IMAGE_INFO[this.o.infoId].imageSettings.original.width >= IMAGE_INFO[this.o.infoId].imageSettings.original.height) {
                    if (convertSmallerSideToZero) {
                      settings.scale.height = 0;
                    }
                  } else {
                    if (convertSmallerSideToZero) {
                      settings.scale.width = 0;
                    }
                  }
                } else if (imageSettings.width) {
                  if (convertSmallerSideToZero) {
                    settings.scale.height = 0;
                  }
                } else if (imageSettings.height) {
                  if (convertSmallerSideToZero) {
                    settings.scale.width = 0;
                  }
                }
              }

              if (_imageSettings) {
                settings = Object.assign(settings, _imageSettings);
              }

              const tmp = settings;
              settings = {};
              settings.imageSettings = tmp;
              settings = this._mixSettings(settings);

              if (settings.text) {
                delete settings.text;
              }

              if (!imageSettings.watermark && settings.watermark) {
                delete settings.watermark;
              }

              return helper.paramsToQueryString(settings);
            };

            const getSize = is => {
              const r = {};

              if (is.width) {
                r.width = is.width;
              }

              if (is.height) {
                r.height = is.height;
              }

              return r;
            };

            if (options.src.crop || options.src.width && options.src.height) {
              convertSmallerSideToZero = false;
            }

            result = {
              callbackData: imageSettings.callbackData,
              size: getSize(options.src.imageSettings),
              src: helper.cleanQueryString(originUrl + '?' + getSrc(getSize(options.src), options.src.imageSettings))
            };

            if ($J.DPPX > 1) {
              srcset = getSrc(getSize(options.srcset), options.srcset.imageSettings);

              if (srcset) {
                result.srcset = helper.cleanQueryString(originUrl + '?' + srcset);
              }
            }
          }

          return result;
        }

        get accountInfo() {
          const result = {};
          const info = IMAGE_INFO[this.o.infoId];

          if (info) {
            result.account = info.imageSettings.account;
            result.branded = info.imageSettings.branded;
          }

          return result;
        }

        destroy() {
          Object.values(this.images).forEach(img => img.image.destroy());
          this.images = {};
          this.someImageIsLoaded = false;
          this.someImageIsComplete = false;

          if (IMAGE_INFO[this.infoId]) {
            delete IMAGE_INFO[this.infoId];
            this.infoId = null;
          }

          super.destroy();
        }

      }

      return RImage;
    });
    Sirv.define('SliderBuilder', ['bHelpers', 'magicJS', 'EventEmitter', 'helper', 'globalVariables', 'globalFunctions'], (bHelpers, magicJS, EventEmitter, helper, globalVariables, globalFunctions) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global $J, helper, Promise */

      /* eslint-disable no-extra-semi */

      /* eslint-disable no-unused-vars */

      /* eslint class-methods-use-this: ["error", {"exceptMethods": ["loadData"]}] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const SLIDER_BUILDER_CONF_VER = 1;

      const getInfoUrl = (url, callbackName) => {
        return url + ($J.stringHas(url, '?') ? '&' : '?') + 'nometa&info=' + callbackName;
      };

      class SliderBuilder {
        constructor(sirvOption, node) {
          this.mainNode = $(node);
          this.sirvOptions = helper.deepExtend({}, sirvOption || {});
          this.nodes = [];
          this.configURL = null;
          this.dataJSON = null;
          this.configHash = null;
          this.attrbMainNode = null;
          this.cfCallbackName = null;
          this.urlParams = null;
          this.componentsList = [];
          this.referrerPolicy = this.mainNode.attr('data-referrerpolicy') || this.mainNode.attr('referrerpolicy') || 'no-referrer-when-downgrade';
        }

        getOptions() {
          return new Promise((resolve, reject) => {
            if (this.checkNode()) {
              this.buildCallBackName();
              helper.getRemoteData(getInfoUrl(this.configURL, this.cfCallbackName), this.cfCallbackName, this.referrerPolicy).then(result => {
                if (result && result.assets) {
                  this.dataJSON = result;
                  this.buildOptions();
                  resolve({
                    'dataOptions': this.sirvOptions
                  });
                } else {
                  let contentType = globalVariables.SLIDE.TYPES.IMAGE;

                  if (result.layers) {
                    contentType = globalVariables.SLIDE.TYPES.SPIN;
                  }

                  resolve({
                    'content': contentType,
                    'dataOptions': this.sirvOptions
                  });
                }
              }).catch(error => {
                error = this.configURL;
                reject({
                  'error': this.configURL,
                  'dataOptions': this.sirvOptions
                });
              });
            } else {
              resolve({
                'dataOptions': this.sirvOptions
              });
            }
          });
        }

        buildViewer() {
          return new Promise((resolve, reject) => {
            if (this.dataJSON) {
              const parsedURL = /(^https?:\/\/[^/]*)([^#?]*)\/.*$/.exec(this.configURL);
              const pathname = this.dataJSON.dirname || parsedURL[2];
              this.prepareListComponents(this.dataJSON.assets, parsedURL[1], pathname);
              this.generateComponents();
              this.addAllComponents();
            }

            resolve({
              'mainNode': this.mainNode
            });
          });
        }

        prepareListComponents(listComponents, origin, folderPath) {
          listComponents.forEach(component => {
            let path;
            const is3rd = /^(https?:)?\/\/[^/]/.test(component.name);

            if (is3rd) {
              path = component.name;
            } else if (/^\//.test(component.name)) {
              path = origin + component.name;
            } else {
              path = origin + folderPath + '/' + component.name;
            }

            this.componentsList.push({
              'path': is3rd ? path : globalFunctions.normalizeURL(path),
              'type': globalVariables.SLIDE.NAMES.indexOf(component.type),
              'is3rd': is3rd
            });
          });
        }

        checkNode() {
          let result = false;
          const template = /([^#?]+)\/?([^#?]+\.view)(\?([^#]*))?(#(.*))?$/;

          if (this.mainNode) {
            this.attrbMainNode = this.mainNode.attr('data-src');

            if (this.attrbMainNode && template.test(this.attrbMainNode)) {
              result = true;
            }
          }

          return result;
        }

        buildOptions() {
          this.sirvOptions.common = helper.deepExtend(this.sirvOptions.common, this.dataJSON.settings || {});
          this.sirvOptions.mobile = helper.deepExtend(this.sirvOptions.mobile, this.dataJSON.settings || {});
        }

        buildCallBackName() {
          this.configURL = globalFunctions.normalizeURL(this.attrbMainNode.replace(globalVariables.REG_URL_QUERY_STRING, '$1'));
          this.urlParams = this.attrbMainNode.replace(globalVariables.REG_URL_QUERY_STRING, '$2');

          if (this.urlParams) {
            this.configURL += '?' + this.urlParams;
          }

          this.configHash = $J.getHashCode(this.configURL.replace(/^http(s)?:\/\//, ''));
          this.cfCallbackName = 'view-' + SLIDER_BUILDER_CONF_VER + '_' + this.configHash;
        }

        generateComponents() {
          this.componentsList.forEach(item => {
            let node = $J.$new('div');

            if (item.type === globalVariables.SLIDE.TYPES.IMAGE) {
              if (item.is3rd) {
                node = $J.$new('img');
                node.attr('data-type', 'static');
              } else {
                node.attr('data-type', 'zoom');
              }
            }

            let path = item.path;

            if (this.urlParams) {
              path += '?' + this.urlParams;
            }

            node.attr('data-src', path);
            this.nodes.push(node);
          });
        }

        addAllComponents() {
          this.mainNode.node.innerHTML = '';
          this.nodes.forEach(item => {
            this.mainNode.node.appendChild(item.node);
          });
        }

        destroy() {
          this.mainNode = null;
          this.sirvOptions = null;
          this.nodes = [];
          this.configURL = null;
          this.dataJSON = null;
          this.configHash = null;
          this.cfCallbackName = null;
          this.componentsList = [];
        }

      }

      return SliderBuilder;
    });
    Sirv.define('getDPPX', ['bHelpers', 'magicJS', 'helper', 'ResponsiveImage'], (bHelpers, magicJS, helper, ResponsiveImage) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global ResponsiveImage, helper */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "getDPPX" }] */

      const getDPPX = (currentWidth, currentHeight, originWidth, originHeight, round, upscale) => {
        let result = 1;

        if ($J.DPPX > 1) {
          if (currentHeight > currentWidth) {
            const height = round ? ResponsiveImage.roundImageSize({
              height: currentHeight
            }).height : currentHeight;
            result = helper.getDPPX(height, originHeight, upscale);
          } else {
            const width = round ? ResponsiveImage.roundImageSize({
              width: currentWidth
            }).width : currentWidth;
            result = helper.getDPPX(width, originWidth, upscale);
          }
        }

        return result;
      };

      return getDPPX;
    });
    Sirv.define('ViewerImage', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'ResponsiveImage', 'HotspotInstance', 'Hotspots', 'getDPPX'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, ResponsiveImage, HotspotInstance, Hotspots, getDPPX) => {
      const $J = magicJS;
      const $ = $J.$;
      /* global $, $J */

      /* global helper */

      /* global HotspotInstance */

      /* global globalVariables */

      /* global ResponsiveImage */

      /* global Hotspots */

      /* global getDPPX */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint-env es6 */

      const BRAND_LANDING = 'https://sirv.com/about-image/?utm_source=client&utm_medium=sirvembed&utm_content=typeofembed(image)&utm_campaign=branding'; // eslint-disable-next-line no-unused-vars

      class ViewerImage extends HotspotInstance {
        constructor(node, options) {
          super(node, options, {});
          this.type = globalVariables.SLIDE.TYPES.IMAGE;
          this.instanceNode.attr('referrerpolicy', this.referrerPolicy);
          this.image = null;
          this.isInfoLoaded = false;
          this.getImageInfoPromise = null;
          this.loadStaticImagePromise = null;
          this.imageShowPromise = null;
          this.srcWasSetted = false;
          this.lastImageSize = {
            width: 0,
            height: 0
          };
          this.imageIndex = options.imageIndex;
          this.dppx = 1;
          this.upscale = false;
          this.size = {
            width: 0,
            height: 0
          };
          this.dontLoad = true;
          this.accountInfo = {};
          this.countOfTries = 1;
          this.isFullscreen = options.isFullscreen;
          this.nativeFullscreen = options.nativeFullscreen;
          this.infoAlt = null;
          this.originAlt = this.instanceNode.attr('alt');
          this.originTitle = this.instanceNode.attr('title');
          this.src = this.instanceNode.attr('src');
          this.srcset = this.instanceNode.attr('srcset');
          this.startedSrc = this.src;
          this.dataSrc = this.instanceNode.attr('data-src');
          this.isStaticImage = this.src && !this.dataSrc;
          this.imageUrl = this.dataSrc || this.src;
          this.getImageTimer = helper.debounce(() => {
            this.getImage();
          }, 32);
          this.firstSlideAhead = false; // Image URL

          this.src = globalFunctions.normalizeURL(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$1'));
          this.queryParamsQuality = null;
          this.queryParams = helper.paramsFromQueryString(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$2')); // Image default params

          this.getQueryParams();
          this.isNotSirv = false;

          if (helper.isSVG(this.imageUrl)) {
            this.isNotSirv = true;
          } // in order to not search it in different classes
          // this.api = Object.assign(this.api, {
          //     isReady: this.isReady.bind(this), // parent class
          //     resize: this.resize.bind(this), // parent class
          //     getOptions: this.getOptions.bind(this) // parent class
          //     hotspots: {} // parent class, hotspots api
          // });


          this.createHotspotsClass(Hotspots);
          this.createSirvImage();
        }

        sendEvent(typeOfEvent, data) {
          if (!data) {
            data = {};
          }

          data.imageIndex = this.imageIndex;
          super.sendEvent(typeOfEvent, data);
        }

        getInfo() {
          if (!this.gettingInfoPromise) {
            this.gettingInfoPromise = new Promise((resolve, reject) => {
              this.waitGettingInfo.wait(() => {
                this.image.loadInfo().then(info => {
                  if (!this.destroyed) {
                    this.isInfoLoaded = true;
                    this.infoAlt = this.image.description;
                    this.infoSize = this.image.originSize;
                    this.accountInfo = this.image.accountInfo;
                    this.hotspotsData = info.hotspots;

                    if (this.hotspots) {
                      this.hotspots.originImageSize = this.infoSize;
                    }

                    resolve();
                  }
                }).catch(err => {
                  if (!this.destroyed) {
                    this.isInfoLoaded = true;

                    if (!err.status || err.status !== 404) {
                      this.isNotSirv = true;
                    }

                    reject(err);
                  }
                });
              });
            });
          }

          return this.gettingInfoPromise;
        }

        getQueryParams() {
          if (this.imageUrl) {
            if (this.queryParams) {
              const q = parseInt(this.queryParams.quality, 10);

              if (isNaN(q)) {
                delete this.queryParams.quality;
              } else {
                this.queryParams.quality = q;
              }
            }

            this.queryParamsQuality = this.queryParams.quality || null;
          }
        }

        getImageCreateSettings() {
          let setts = {
            src: {},
            srcset: {}
          };

          if (this.quality !== null && this.queryParamsQuality === null) {
            setts.src.quality = this.quality;
          }

          const hdQuality = this.hdQuality;

          if (this.queryParamsQuality === null || this.isHDQualitySet && hdQuality < this.queryParamsQuality) {
            setts.srcset = {
              quality: hdQuality
            };
          }

          setts.width = this.size.width;

          if (this.size.height) {
            setts.height = this.size.height;
          }

          setts = helper.imageLib.checkMaxSize(setts, this.infoSize);

          if (this.infoSize.width === setts.width || this.infoSize.height === setts.height) {
            setts.round = false;
          }

          if ($J.DPPX > 1) {
            setts.dppx = this.dppx;
          }

          return setts;
        }

        setHDQuality(opt) {
          if (opt.dppx > 1 && opt.dppx < 1.5) {
            if (this.queryParamsQuality === null && this.quality !== null) {
              opt.srcset.quality = this.quality;
            } else if (opt.srcset) {
              delete opt.srcset.quality;
            }
          }

          return opt;
        }

        replaceSrc() {
          let img;

          if (this.isNotSirv) {
            if (this.srcWasSetted) {
              return;
            }

            this.srcWasSetted = true;
            img = {
              src: this.imageUrl
            };
          } else {
            let opt = this.getImageCreateSettings();

            if (opt.dppx > 1 && opt.dppx < 1.5) {
              delete opt.srcset.quality;
            }

            opt = this.setHDQuality(opt);
            img = this.image.getImage(opt);
            this.lastImageSize.width = img.width || img.serverWidth;
            this.lastImageSize.height = img.height || img.serverHeight;
          }

          this.instanceNode.attr('src', img.src);

          if (img.srcset) {
            if (!this.isNotSirv && this.dppx > 1) {
              this.instanceNode.attr('srcset', img.srcset + ' ' + this.dppx + 'x');
            }
          } else {
            this.instanceNode.removeAttr('srcset');
          }
        }

        showImage() {
          if (!this.imageShowPromise) {
            // eslint-disable-next-line
            this.imageShowPromise = new Promise((resolve, reject) => {
              if (this.isStaticImage) {
                this.instanceNode.setCssProp('opacity', '');
                resolve();
              } else if (this.isInView && this.isSlideShown) {
                this.instanceNode.addEvent('transitionend', e => {
                  if (e.propertyName === 'opacity') {
                    e.stop();
                    this.instanceNode.removeEvent('transitionend');
                    this.instanceNode.setCss({
                      opacity: '',
                      transition: ''
                    });
                    resolve();
                  }
                });
                this.instanceNode.render();
                this.instanceNode.setCss({
                  opacity: 1,
                  transition: 'opacity 0.3s linear'
                });
              } else {
                this.instanceNode.setCssProp('opacity', '');
                resolve();
              }
            });
          }

          return this.imageShowPromise;
        }

        createSirvImage() {
          if (!this.imageUrl || this.isNotSirv) {
            return;
          }

          this.on('imageOnload', e => {
            e.stopAll();
            this.replaceSrc();

            if (!this.ready) {
              if (e.data.node) {
                this.showImage().finally(() => {
                  this.done();
                });
              } else {
                helper.loadImage(this.instanceNode).finally(() => {
                  this.showImage().finally(() => {
                    this.done();
                    this.sendContentLoadedEvent();
                  });
                });
              }
            }
          });
          this.on('imageOnerror', e => {
            e.stopAll();
            console.log('image error');
          });
          this.image = new ResponsiveImage(this.imageUrl, {
            imageSettings: this.queryParams,
            round: true,
            dontLoad: this.dontLoad,
            referrerPolicy: this.referrerPolicy
          });
          this.image.parentClass = this;
          this.getInfo();
        }

        getInfoSize() {
          if (!this.getImageInfoPromise) {
            this.getImageInfoPromise = new Promise((resolve, reject) => {
              if (this.image) {
                this.getInfo().then(() => {
                  resolve({
                    size: this.infoSize,
                    imageIndex: this.imageIndex
                  });
                }).catch(err => {
                  reject({
                    error: err,
                    isPlaceholder: err._isplaceholder,
                    imageIndex: this.imageIndex
                  });
                });
              } else {
                reject({
                  error: 'nonsirv',
                  isPlaceholder: false,
                  imageIndex: this.imageIndex
                });
              }
            });
          }

          return this.getImageInfoPromise;
        }

        startFullInit(options) {
          if (this.isStartedFullInit) {
            return;
          }

          super.startFullInit(options);
          this.getId('responsive-image-'); // TODO check css

          if (!this.isStaticImage) {
            this.instanceNode.setCssProp('opacity', 0);
          }
        }

        run(isShown, preload, firstSlideAhead, loadContent) {
          this.firstSlideAhead = firstSlideAhead;
          let result = super.run(isShown, preload, firstSlideAhead);

          if (result) {
            if (this.destroyed) {
              result = false;
            } else {
              // Remove ALT to properly calculate image size.
              // Safari and Edge/IE return image size with a height if ALT text is present.
              this.instanceNode.removeAttr('alt'); // Remove TITLE to properly calculate image size.
              // The latest version(s) of Chrome returns image size with a height if TITLE is set.

              this.instanceNode.removeAttr('title'); // This force browsers to re-layout image and recalculate its dimensions.

              this.instanceNode.setCss({
                display: 'inline-flex'
              }).render();
              this.instanceNode.setCss({
                display: ''
              }).render();
              let size = null;
              helper.imageLib.getSize(this.instanceNode.node.parentNode).then(dataSize => {
                size = dataSize;
              }).finally(() => {
                if (!this.destroyed) {
                  // sometimes when we have very slow internet connection and the image is first slide and thumbnails have left position we get wrong height
                  if (size.width && size.height <= 20) {
                    size.height = 0;
                  } // size = helper.fixSize(this.instanceNode, size);


                  this.size = helper.imageLib.calcProportionSize(size, this.infoSize);

                  if (this.originAlt || this.infoAlt) {
                    // Restore ALT text
                    $(this.instanceNode).attr('alt', this.originAlt || this.infoAlt);
                  }

                  if (this.originTitle) {
                    // Restore TITLE text
                    $(this.instanceNode).attr('title', this.originTitle);
                  }

                  if (this.isStaticImage) {
                    this.loadStaticImage().finally(() => {
                      if (this.isInfoLoaded) {
                        this.done();
                      }
                    });
                  } else {
                    if (this.originAlt) {
                      // Restore ALT text
                      $(this.instanceNode).attr('alt', this.originAlt);
                    }

                    if (this.isInView && (this.isSlideShown || this.preload || loadContent)) {
                      this.getImage();
                    }
                  }

                  if (this.dataAlt) {
                    $(this.instanceNode).attr('alt', this.dataAlt);
                  }
                }
              });
              this.startGettingInfo();
            }
          }

          return result;
        }

        loadContent() {
          this.getImage(true);
        }

        loadStaticImage() {
          if (!this.loadStaticImagePromise) {
            this.loadStaticImagePromise = new Promise((resolve, reject) => {
              if (this.isStaticImage) {
                if (this.instanceNode.node.complete) {
                  resolve();
                } else {
                  // eslint-disable-next-line
                  this.instanceNode.addEvent('load', e => {
                    this.sendContentLoadedEvent();
                    resolve();
                  }); // eslint-disable-next-line

                  this.instanceNode.addEvent('error', e => {
                    reject();
                  });
                }
              } else {
                resolve();
              }
            });
          }

          return this.loadStaticImagePromise;
        }

        getImage(loadContent) {
          if (this.isStaticImage) {
            return;
          }

          if (!this.isNotSirv && !this.ready && !this.size.width && !this.size.height) {
            // fix for if the viewer was with display none
            if (this.countOfTries < 100) {
              setTimeout(() => {
                this.countOfTries += 1;
                this.isStarted = false;
                this.run(this.isSlideShown, this.preload, this.firstSlideAhead, loadContent);
              }, 16 * this.countOfTries);
            }

            return;
          }

          this.waitToStart.start();

          if (this.isNotSirv) {
            this.replaceSrc();
          } else {
            this.getSirvImg();
          }
        }

        get imageClassContainer() {
          return this.image;
        }

        getSirvImg() {
          let setts = this.getImageCreateSettings();

          if ($J.DPPX > 1) {
            const originSize = this.image.originSize;
            this.dppx = getDPPX(setts.width, setts.height, originSize.width, originSize.height, !$J.defined(setts.round) || setts.round, this.upscale);
            setts.dppx = this.dppx;
          }

          setts = this.setHDQuality(setts);

          if (this.checkImage(setts, this.dontLoad)) {
            this.replaceSrc();
          } else {
            this.image.getImage(setts);
          }
        }

        get originImageUrl() {
          return this.src;
        }

        done() {
          if (!this.ready) {
            if (this.accountInfo.branded) {
              let n = this.instanceNode;

              if (n.tagName === 'img') {
                n = n.node.parentNode;
              }

              const nodeWithSirvClassName = globalFunctions.getNodeWithSirvClassName(this.instanceNode) || $J.D.node.head || $J.D.node.body;
              globalFunctions.rootDOM.showSirvAd(nodeWithSirvClassName, n, BRAND_LANDING, 'Image viewer by Sirv');
            }

            super.done();

            if (this.hotspots) {
              this.hotspots.containerSize = this.instanceNode.node.getBoundingClientRect();
            }

            if (!this.isFullscreenEnabled) {
              this.pinchCloud.removeEvent();
              this.pinchCloud = null;
            }
          }
        }

        getSelectorImgUrl(data) {
          return new Promise((resolve, reject) => {
            const defOpt = this.getImageCreateSettings();

            if (defOpt.src) {
              data.src = defOpt.src;
            }

            data.srcset = defOpt.srcset;

            if (this.isInfoLoaded) {
              this.waitToStart.wait(() => {
                resolve(Object.assign(this.image.getThumbnail(data), {
                  imageIndex: this.imageIndex,
                  alt: this.dataAlt || this.originAlt || this.infoAlt,
                  'referrerpolicy': this.instanceNode.attr('referrerpolicy')
                }));
              });
            } else {
              this.getInfo().then(() => {
                this.waitToStart.wait(() => {
                  resolve(Object.assign(this.image.getThumbnail(data), {
                    imageIndex: this.imageIndex,
                    alt: this.dataAlt || this.originAlt || this.infoAlt,
                    referrerpolicy: this.instanceNode.attr('referrerpolicy')
                  }));
                });
              }).catch(reject);
            }
          });
        }

        getThumbnailData(opt) {
          return this.image.getThumbnail(opt);
        }

        createPinchEvent() {
          // difference between scale
          const FS_OUT = 0.2;
          const FS_IN = 2;
          super.createPinchEvent(this.instanceNode);

          this.pinchCloud.onPinchStart = e => {
            if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
              return;
            }

            this.pinchCloud.pinch = true;
            this.pinchCloud.scale = e.scale;
            this.sendEvent('pinchStart');
          };

          this.pinchCloud.onPinchMove = e => {
            if (this.pinchCloud.pinch && !this.pinchCloud.block) {
              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                if (e.scale < FS_OUT) {
                  this.pinchCloud.block = true;
                  this.sendEvent('fullscreenOut');
                }
              } else if (e.scale >= FS_IN) {
                this.pinchCloud.block = true;
                this.sendEvent('fullscreenIn');
              }
            }
          };
        }

        onStartActions() {
          if (!this.ready) {
            if (this.isInView && this.isStarted) {
              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                this.onResize();
              }

              if (this.always) {
                /*
                    it can happen when fullscreen always is true and we came to this slide by thumbnail
                    we need timer to clear it in 'onBeforeFullscreenIn' handler and don't if we are in standard mode
                */
                this.getImageTimer();
              } else {
                this.getImage();
              }
            }
          }

          super.onStartActions();
        }

        onStopActions() {
          super.onStopActions();
        }

        onInView(value) {
          if (value && !this.isStaticImage) {
            if (!this.ready && !this.isInView) {
              if (this.isStarted) {
                this.isInView = true;

                if (this.isInfoLoaded && (this.preload || this.isSlideShown)) {
                  this.getImage();
                }
              }
            }
          }
        } // eslint-disable-next-line no-unused-vars


        onBeforeFullscreenIn(data) {
          this.getImageTimer.cancel();

          if (this.ready && !this.isStaticImage) {
            this.instanceNode.setCssProp('visibility', 'hidden');
          }

          super.onBeforeFullscreenIn(data);

          if (this.hotspots) {
            this.hotspots.disableAll();
          }
        } // eslint-disable-next-line no-unused-vars, class-methods-use-this


        onAfterFullscreenIn(data) {
          // if we use it, we do not have pinchend event and touchdrag after that
          // if (this.pinchCloud) {
          //     this.pinchCloud.removeEvent();
          //     this.pinchCloud.addEvent();
          // }
          if (this.always && !this.ready && this.isInView && this.isStarted) {
            this.onResize();
            this.getImage();
          }

          if (this.hotspots) {
            setTimeout(() => {
              // we have to wait a little bit for 'onResize' function
              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                // if we will exit from fullscreen before the timeout end
                this.hotspots.enableAll();

                if (this.isInView && this.isSlideShown) {
                  this.hotspots.showNeededElements();
                }
              }
            }, 100);
          }
        } // eslint-disable-next-line no-unused-vars


        onBeforeFullscreenOut(data) {
          this.instanceNode.setCss({
            width: '',
            height: '',
            visibility: ''
          });
          super.onBeforeFullscreenOut(data);
        } // eslint-disable-next-line no-unused-vars, class-methods-use-this


        onAfterFullscreenOut(data) {
          // if we use it, we do not have pinchend event and touchdrag after that
          // if (this.pinchCloud) {
          //     this.pinchCloud.removeEvent();
          //     this.pinchCloud.addEvent();
          // }
          super.onAfterFullscreenOut(data);
        }

        onResize() {
          if (!this.isStarted || this.isStaticImage || this.isNotSirv) {
            return false;
          }

          if (this.isFullscreenActionEnded()) {
            let size = $(this.instanceNode.node.parentNode).size;
            size = helper.imageLib.calcProportionSize(size, this.infoSize);

            if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
              this.instanceNode.setCss({
                width: size.width + 'px',
                height: size.height + 'px'
              });
              this.instanceNode.setCssProp('visibility', '');
            }

            this.size.width = size.width;

            if (this.size.height) {
              this.size.height = size.height;
            }

            if (this.ready) {
              const upscale = 50;

              if (this.size.width - this.lastImageSize.width > upscale || this.size.height - this.lastImageSize.height > upscale) {
                this.getImage();
              }

              if (this.hotspots) {
                this.hotspots.containerSize = this.instanceNode.node.getBoundingClientRect();

                if (this.isInView && this.isSlideShown) {
                  this.hotspots.showNeededElements();
                }
              }
            }

            return true;
          }

          return false;
        }

        destroy() {
          if (this.image) {
            this.off('imageOnload');
            this.off('imageOnerror');
            this.image.destroy();
            this.image = null;
          }

          this.getImageTimer.cancel();
          this.getImageTimer = null;
          this.instanceNode.setCssProp('opacity', '');

          if (this.hotspot) {
            $(this.instanceNode.node.parentNode).removeEvent('tap');
          }

          if (this.instanceNode.node.hasAttribute('src')) {
            try {
              this.instanceNode.removeAttr('src');

              if (this.isStaticImage) {
                this.instanceNode.attr('src', this.imageUrl);
              }
            } catch (e) {// empty
            }
          }

          if (!this.isStaticImage) {
            this.instanceNode.removeAttr('src');
          } else {
            this.instanceNode.attr('src', this.src);
          }

          if (this.srcset) {
            this.instanceNode.attr('srcset', this.srcset);
          } else {
            try {
              this.instanceNode.removeAttr('srcset');
            } catch (e) {// empty
            }
          }

          this.srcset = null;

          if (!this.originAlt && (this.infoAlt || this.dataAlt)) {
            this.instanceNode.removeAttr('alt');
          }

          this.instanceNode.removeEvent('load');
          this.hotspotsData = null;
          super.destroy();
          return true;
        }

      }

      return ViewerImage;
    });
    Sirv.define('defaultsVideoOptions',
    /* eslint-env es6 */
    {
      autoplay: {
        type: 'boolean',
        defaults: false
      },
      // sirvvideo, video, youtube, vimeo
      loop: {
        type: 'boolean',
        defaults: false
      },
      // sirvvideo, video, youtube, vimeo
      volume: {
        type: 'number',
        minimum: 0,
        maximum: 100,
        defaults: 100
      },
      // sirvvideo, video, youtube
      // youtube does not have preload option
      // https://developers.google.com/youtube/iframe_api_reference
      // vimeo does not have preload option
      // https://developer.vimeo.com/player/sdk/embed
      preload: {
        type: 'boolean',
        defaults: true
      },
      // sirvvideo, video
      thumbnail: {
        oneOf: [{
          type: 'url'
        }, {
          type: 'boolean',
          'enum': [false]
        }, {
          type: 'number',
          minimum: 0
        }],
        defaults: false
      },
      // 1 = little motion
      // 2 = moderate motion
      // 3 = more motion
      // 4 = high motion
      motionFactor: {
        type: 'number',
        minimum: 1,
        maximum: 4,
        defaults: 3
      },
      dynamicAdaptiveStreaming: {
        type: 'boolean',
        defaults: true
      },
      // just for videojs
      quality: {
        // quality.min
        min: {
          type: 'number',
          'enum': [360, 480, 720, 1080],
          defaults: 360
        },
        // quality.max
        max: {
          type: 'number',
          'enum': [360, 480, 720, 1080],
          defaults: 1080
        }
      },
      controls: {
        enable: {
          type: 'boolean',
          defaults: true
        },
        // sirvvideo, video, youtube
        // Volume control
        volume: {
          type: 'boolean',
          defaults: true
        },
        // sirvvideo
        // Playback rate control
        speed: {
          type: 'boolean',
          defaults: false
        },
        // sirvvideo
        // Quality (resolutions) control
        quality: {
          type: 'boolean',
          defaults: false
        },
        // sirvvideo
        // controls.fullscreen. hidden option
        fullscreen: {
          type: 'boolean',
          defaults: true
        } // sirvvideo

      }
    });
    Sirv.define('Hotspot', ['bHelpers', 'globalFunctions', 'magicJS', 'EventEmitter', 'helper'], (bHelpers, globalFunctions, magicJS, EventEmitter, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('Hotspot', () => {
        return '@charset "UTF-8";.sirv-hotspot-pointer{display:inline-block;position:absolute;width:20px;height:20px;transform:translate(-50%,-50%);background-repeat:no-repeat;cursor:pointer;z-index:11;pointer-events:auto}.sirv-hotspot-pointer.pulsating-point{background-image:none}.sirv-hotspot-pointer.pulsating-point::after,.sirv-hotspot-pointer.pulsating-point::before{display:inline-block;position:absolute;top:0;left:0;width:100%;height:100%;transform-origin:50% 50%;border-radius:100%;content:\'\'}.sirv-hotspot-pointer.pulsating-point::before{transition:opacity .2s ease-in,transform .1s ease-out;background-color:#ff0;opacity:.6;overflow:hidden}.sirv-hotspot-pointer.pulsating-point::after{border:1px solid #ff0;opacity:0;box-sizing:border-box;animation:pulsating-point-pulsate 3s ease-out infinite;pointer-events:none}.sirv-hotspot-pointer.pulsating-point:hover::before{cursor:pointer;opacity:.8}.sirv-hotspot-pointer.pulsating-point:active::before{transform:scale(.875)}.sirv-hotspot-pointer.pulsating-point:hover::after{animation:none}.sirv-hotspot-pointer.pulsating-point:active::after{animation:pulsating-point-stop-pulsate .3s}.smv .smv-slides-box .smv-slides .smv-slide .smv-content .sirv-hotspot-container{position:absolute!important;pointer-events:none}.smv .smv-slides-box .smv-slides .smv-slide .smv-content .sirv-hotspot-container.sirv-hotspot-overwrite-pointer-event{pointer-events:auto!important}@keyframes pulsating-point-pulsate{0%{transform:scale(1);opacity:.8}45%{transform:scale(1.75);opacity:0}}@keyframes pulsating-point-stop-pulsate{from{opacity:.4}to{transform:scale(2);opacity:0}}.sirv-hotspot-tooltip{display:block;position:absolute;padding:8px 24px;transition:opacity .15s linear 0s;border:1px solid #efefef;border-radius:4px;background-color:#fff;font:normal 12px/1.42857 \'Lucida Grande\',\'Lucida Sans Unicode\',Verdana,\'Helvetica Neue\',Arial,Helvetica,sans-serif;border-collapse:separate;box-shadow:0 5px 10px 2px rgba(0,0,0,.1);opacity:0;z-index:9999999999;pointer-events:none;-webkit-font-smoothing:antialiased}.sirv-hotspot-tooltip--default{margin-top:-8px;padding:6px 9px;transform:translate(-50%,-100%);border:0;background-color:rgba(49,51,61,.76);color:#eee}.sirv-hotspot-tooltip--default::after{position:absolute;top:100%;left:50%;width:0;height:0;transform:translateX(-50%);border-width:8px 8px 0;border-style:solid;border-color:rgba(49,51,61,.76) transparent transparent;content:\'\'}.sirv-hotspot-tooltip--balloon{margin-top:-40px;transform:translate(-40px,-100%)}.sirv-hotspot-tooltip--balloon::after{position:absolute;top:100%;left:24px;width:0;height:0;border-width:0 15px 40px 0;border-style:solid;border-color:transparent #fff transparent transparent;content:\'\'}.sirv-hotspot-tooltip.sirv-hotspot-tooltip-visible{transition-delay:.1s;opacity:1}.sirv-hotspot-box{display:flex;position:fixed;max-width:100vw;max-height:100vh;padding:10px;transition:opacity .15s linear 0s;z-index:9999999999;box-sizing:border-box}.sirv-hotspot-box.sirv-hotspot-box-out-of-width{right:0!important;left:0!important}.sirv-hotspot-box.sirv-hotspot-box-out-of-height{top:0!important;bottom:0!important}.sirv-hotspot-box .sirv-hotspot-box-wrapper{display:flex;position:relative;max-width:inherit;max-height:inherit;padding:22px;border:1px solid #efefef;border-radius:4px;background:#fff;font-size:16px!important;line-height:100%;text-align:left;border-collapse:separate;box-shadow:0 5px 10px 2px rgba(0,0,0,.1);overflow:hidden;box-sizing:border-box}.sirv-hotspot-box .sirv-hotspot-box-content{top:0;left:0;width:100%;max-width:inherit;height:calc(100% + 2px);max-height:inherit;overflow:auto}.sirv-hotspot-box .sirv-hotspot-close-button{position:absolute;top:2px;right:2px;width:24px;height:24px;color:#888;font:normal 22px/1 Arial,monospace;text-align:center;cursor:pointer;speak:none;-webkit-font-smoothing:antialiased}.sirv-hotspot-box .sirv-hotspot-close-button::before{display:inline;position:static;color:inherit!important;font:inherit!important;content:\'×\';vertical-align:middle;-webkit-font-smoothing:inherit!important}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* global EventEmitter */

      /* global helper */

      /* eslint-disable no-restricted-syntax */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Hotspot" }] */

      const CSS_HOTSPOT_POINTER = 'sirv-hotspot-pointer';
      const CSS_HOTSPOT_POINTER_BACKWARD_COMPATIBILITY = 'hotspot-pointer';
      const CSS_HOTSPOT_TOOLTIP = 'sirv-hotspot-tooltip';
      const CSS_HOTSPOT_DEFAULT = 'pulsating-point';
      const CSS_HOTSPOT_BOX = 'sirv-hotspot-box';
      const CSS_HOTSPOT_WRAPPER = 'sirv-hotspot-box-wrapper';
      const CSS_HOTSPOT_BUTTON_CLOSE = 'sirv-hotspot-close-button';
      const CSS_HOTSPOT_CONTENT = 'sirv-hotspot-box-content';
      const CSS_HOTSPOT_BOX_OUT_OF_WIDTH = 'sirv-hotspot-box-out-of-width';
      const CSS_HOTSPOT_BOX_OUT_OF_HEIGHT = 'sirv-hotspot-box-out-of-height';
      const OVERWRITE_POINTER_EVENT = 'sirv-hotspot-overwrite-pointer-event';
      const STATES = {
        AUTO: 0,
        VISIBLE: 1
      };

      class Hotspot extends EventEmitter {
        constructor(container, hotspotData, index) {
          super();
          this.container = container;
          this.hotspotData = hotspotData;
          this._id = index;
          this.box = null;
          this.boxContainer = $J.D.node.body;
          this.baseBoxSize = null;
          this.tooltip = null;
          this.version = 1;
          this.pointer = null;
          this.hotspotSettings = {};
          this.dX = 1;
          this.dY = 1;
          this.isActive = false;
          this.isDisabled = false;
          this.isPointerInDoc = false;
          this.isHovered = false;
          this.isShown = false;
          this.isBoxContent = false;
          this.tooltipState = STATES.AUTO;
          this.boxState = STATES.AUTO;
          this.init();
        }

        isTooltipHovered() {
          return this.isHovered;
        }

        isBoxActivated() {
          return this.isActive;
        }

        isBoxAlwaysVisible() {
          return this.boxState === STATES.VISIBLE;
        }

        isTooltipAlwaysVisible() {
          return this.tooltipState === STATES.VISIBLE;
        }

        init() {
          this.setVersion();
          this.parseHotspotData();
          this.createBlocks();
          this.addEvents();
          this.createBox();
        }

        setVersion() {
          if (this.hotspotData.style || this.hotspotData.tooltip || this.hotspotData.box && this.hotspotData.box.content) {
            this.version = 2;
          }
        }

        parseHotspotData() {
          Object.keys(this.hotspotData).forEach(key => this.hotspotSettings[key] = this.hotspotData[key]);
          this.hotspotSettings.pointerPositionPercentage = {
            top: helper.isPercentage('' + this.hotspotSettings.pointer.y),
            left: helper.isPercentage('' + this.hotspotSettings.pointer.x)
          };
        }

        createBlocks() {
          this.pointer = $J.$new('div').addClass(CSS_HOTSPOT_POINTER).attr('data-spot-id', this._id);
          this.pointer.addClass(CSS_HOTSPOT_POINTER_BACKWARD_COMPATIBILITY);

          if (this.version > 1 && this.hotspotSettings.tooltip && this.hotspotSettings.tooltip.content) {
            this.tooltip = $J.$new('div').addClass(CSS_HOTSPOT_TOOLTIP).changeContent(this.hotspotSettings.tooltip.content);

            if (this.hotspotSettings.tooltip.style) {
              this.tooltip.addClass(CSS_HOTSPOT_TOOLTIP + '--' + this.hotspotSettings.tooltip.style);
            }
          }
        }

        setTooltipPosition() {
          if (this.tooltip) {
            let pointerXY = this.pointer.rect;
            const cssTooltip = {
              top: 0,
              left: 0
            };
            cssTooltip.top = this.hotspotSettings.tooltip.style ? pointerXY.top : pointerXY.bottom;
            cssTooltip.left = this.hotspotSettings.tooltip.style ? (pointerXY.left + pointerXY.right) / 2 : pointerXY.right;

            if ($J.$(this.boxContainer).tagName !== 'body') {
              pointerXY = this.pointer.node.getBoundingClientRect();
              cssTooltip.top = this.hotspotSettings.tooltip.style ? pointerXY.top - this.container.node.getBoundingClientRect().top : pointerXY.bottom - this.container.node.getBoundingClientRect().top;
              cssTooltip.left = this.hotspotSettings.tooltip.style ? pointerXY.left - this.container.node.getBoundingClientRect().left + pointerXY.width / 2 : pointerXY.left - this.container.node.getBoundingClientRect().left + pointerXY.width;
            }

            this.tooltip.setCss(cssTooltip);
          }
        }

        showTooltip() {
          if (!this.isHovered && !this.isDisabled) {
            if (this.tooltip) {
              this.setTooltipPosition();
              this.tooltip.appendTo(this.boxContainer).addClass(CSS_HOTSPOT_TOOLTIP + '-visible');
              this.isHovered = true;
              this.emit('hotspotHovered', {
                data: {
                  hotspot: this
                }
              });
            }
          }
        }

        addEvents() {
          this.pointer.addEvent(['click', 'mousedown'], e => {
            e.stop();
          });
          this.pointer.addEvent(['btnclick', 'tap'], e => {
            if (e.button === 3) {
              return true;
            }

            if (this.hotspotSettings.link) {
              $J.W.node.open(this.hotspotSettings.link);
              e.stop();
            } else if (this.isBoxContent) {
              e.stop();
              this.showBox();
            }

            return false;
          });

          if ($J.browser.uaName === 'edge' || $J.browser.ieMode) {
            this.pointer.addEvent('mousedown', e => {
              e.stopDistribution();
            });
          }

          if (this.hotspotSettings.tooltip && this.hotspotSettings.tooltip.content) {
            this.pointer.addEvent('mouseenter', e => {
              this.showTooltip();
            });
            this.pointer.addEvent('mouseleave', () => {
              if (this.tooltipState !== STATES.VISIBLE) {
                this.hideTooltip();
                this.isHovered = false;
                this.emit('hotspotLeft', {
                  data: {
                    hotspot: this
                  }
                });
              }
            });
          }

          let resizeTimer;
          $($J.W).addEvent('resize', e => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              if (this.isActive) {
                const hotspotInfo = this.hotspotSettings;

                if (hotspotInfo) {
                  this.box.setCss(this.correctBoxPosition(this.getBoxPosition(hotspotInfo)));
                }
              }
            }, 42);
          });
        }

        createBox() {
          let boxContent = null;

          if (this.version > 1 && this.hotspotSettings.box && this.hotspotSettings.box.content) {
            boxContent = this.hotspotSettings.box.content;
          } else if (this.hotspotSettings.data) {
            boxContent = this.hotspotSettings.data;
          }

          this.box = $J.$new('div').addClass(CSS_HOTSPOT_BOX);

          if (boxContent) {
            this.isBoxContent = true;
            const wrapper = $J.$new('div').addClass(CSS_HOTSPOT_WRAPPER).append($J.$new('div').addEvent(['btnclick', 'tap'], e => {
              if (this.boxState !== STATES.VISIBLE) {
                e.stop();
                this.hideBox(true);
              }
            }).addClass(CSS_HOTSPOT_BUTTON_CLOSE));
            const content = $J.$new('div').addClass(CSS_HOTSPOT_CONTENT).changeContent(boxContent + '').addEvent('click', e => {
              e.stopDistribution();
            });
            wrapper.append(content);
            this.box.append(wrapper);
          }

          this.box.setCss({
            top: '-10000px',
            left: '-10000px',
            position: 'absolute',
            opacity: 0
          });
        }

        getBoxPosition(hotspotInfo) {
          const result = {
            top: 0,
            left: 0,
            transform: ''
          };

          if (hotspotInfo && hotspotInfo.box) {
            const boxX = hotspotInfo.box.x;
            const boxY = hotspotInfo.box.y;

            if (this.hotspotSettings.box.fixed) {
              const boxBoundaries = this.container.rect;
              result.position = 'absolute';

              if ($J.$(this.boxContainer).tagName !== 'body') {
                switch (boxY) {
                  case 'top':
                    result.top = 0;
                    break;

                  case 'bottom':
                    result.top = boxBoundaries.bottom - boxBoundaries.top;
                    result.transform += ' translateY(-100%)';
                    break;

                  case 'center':
                    result.top = (0 + (boxBoundaries.bottom - boxBoundaries.top)) / 2;
                    result.transform += ' translateY(-50%)';
                    break;

                  default:
                    result.top = 0 + (parseFloat(boxY) || 0);
                }

                switch (boxX) {
                  case 'left':
                    result.left = 0;
                    break;

                  case 'right':
                    result.left = boxBoundaries.right - boxBoundaries.left;
                    result.transform += ' translateX(-100%)';
                    break;

                  case 'center':
                    result.left = (boxBoundaries.right - boxBoundaries.left) / 2;
                    result.transform += ' translateX(-50%)';
                    break;

                  default:
                    result.left = boxBoundaries.left + (parseFloat(boxX) || 0);
                }
              } else {
                switch (boxY) {
                  case 'top':
                    result.top = boxBoundaries.top;
                    break;

                  case 'bottom':
                    result.top = boxBoundaries.bottom;
                    result.transform += ' translateY(-100%)';
                    break;

                  case 'center':
                    result.top = (boxBoundaries.top + boxBoundaries.bottom) / 2;
                    result.transform += ' translateY(-50%)';
                    break;

                  default:
                    result.top = boxBoundaries.top + (parseFloat(boxY) || 0);
                }

                switch (boxX) {
                  case 'left':
                    result.left = boxBoundaries.left;
                    break;

                  case 'right':
                    result.left = boxBoundaries.right;
                    result.transform += ' translateX(-100%)';
                    break;

                  case 'center':
                    result.left = (boxBoundaries.left + boxBoundaries.right) / 2;
                    result.transform += ' translateX(-50%)';
                    break;

                  default:
                    result.left = boxBoundaries.left + (parseFloat(boxX) || 0);
                }
              }
            } else {
              const pointerXY = this.pointer.position;
              const scroll = $J.W.scroll;
              result.left = pointerXY.left - scroll.x + (parseFloat(boxX) || 0);
              result.top = pointerXY.top - scroll.y + (parseFloat(boxY) || 0);
            }
          }

          return result;
        }

        correctBoxPosition(position) {
          if (this.hotspotSettings.box && !this.hotspotSettings.box.fixed) {
            this.box.removeClass(CSS_HOTSPOT_BOX_OUT_OF_WIDTH);
            this.box.removeClass(CSS_HOTSPOT_BOX_OUT_OF_HEIGHT);
            const wSize = $J.W.size;

            if (this.baseBoxSize.width > wSize.width) {
              this.box.addClass(CSS_HOTSPOT_BOX_OUT_OF_WIDTH);
            } else if (position.left + this.baseBoxSize.width > wSize.width) {
              position.left = wSize.width - this.baseBoxSize.width;
            }

            if (this.baseBoxSize.height > wSize.height) {
              this.box.addClass(CSS_HOTSPOT_BOX_OUT_OF_HEIGHT);
            } else if (position.top + this.baseBoxSize.height > wSize.height) {
              position.top = wSize.height - this.baseBoxSize.height;
            }
          }

          return position;
        }

        setBoxPosition() {
          let boxCss = {
            transform: ''
          };
          boxCss = this.correctBoxPosition(this.getBoxPosition(this.hotspotSettings));
          this.box.setCssProp('position', '');
          this.box.setCss(boxCss);
          this.box.render();
        }

        showBox() {
          if (this.isActive || this.isDisabled) {
            return;
          }

          if (this.tooltip && this.tooltipState === STATES.AUTO) {
            this.tooltip.removeClass(CSS_HOTSPOT_TOOLTIP + '-visible');
          }

          this.box.setCss({
            opacity: 0
          });
          this.box.appendTo(this.boxContainer);
          this.setBaseBoxSize(this.box.size);
          this.setBoxPosition();
          this.box.setCss({
            opacity: 1
          });
          this.isActive = true;
          this.emit('hotspotActivate', {
            data: {
              hotspot: this
            }
          });
        }

        hideBox(fade) {
          if (this.isActive) {
            if (fade) {
              if (this.box) {
                this.box.setCssProp('opacity', 0);
              }

              setTimeout(() => {
                this.hideBox();
              }, 300);
              return this._id;
            }

            if (this.box) {
              this.box.remove();
            }

            this.isActive = false;
            this.emit('hotspotDeactivate', {
              data: {
                hotspot: this
              }
            });
          }
        }

        changeBoxContainer(container) {
          this.boxContainer = container ?? $J.D.node.body;
        }

        setBaseBoxSize(size, force) {
          if (size && force || !this.baseBoxSize) {
            this.baseBoxSize = {
              width: size.width,
              height: size.height
            };
          }
        }

        setHotspotSettings(settings) {
          for (const item in settings) {
            if ({}.hasOwnProperty.call(settings, item)) {
              this.hotspotSettings[item] = settings[item];
            }
          }
        }

        getHotspotSettings(settings) {
          return this.hotspotSettings;
        }

        setAspectRatio(x, y) {
          this.dX = x;
          this.dY = y;
        }

        setPointerPosition() {
          const hss = this.hotspotSettings;

          if (hss) {
            this.pointer.setCss({
              top: hss.pointerPositionPercentage.top ? hss.pointer.y : Math.ceil(hss.pointer.y * this.dY),
              left: hss.pointerPositionPercentage.left ? hss.pointer.x : Math.ceil(hss.pointer.x * this.dX)
            });
          }
        }

        showPointer() {
          if (this.hotspotSettings && !this.isDisabled) {
            this.pointer.addClass(CSS_HOTSPOT_DEFAULT);
            this.setPointerPosition();

            if (this.hotspotSettings.style || this.hotspotSettings.pointer.style) {
              let dataStyle = this.hotspotSettings.style;

              if (!dataStyle) {
                dataStyle = this.hotspotSettings.pointer.style;
              }

              this.pointer.addClass(dataStyle);
            }

            if (!this.isPointerInDoc) {
              this.isPointerInDoc = true;
              this.pointer.appendTo(this.container);
            }
          } else {
            this.hidePointer();
          }
        }

        hidePointer() {
          if (this.isPointerInDoc) {
            this.isPointerInDoc = false;
            this.pointer.remove();
          }
        }

        isHotspotShown() {
          return this.isShown;
        }

        show() {
          if (!this.isDisabled && !this.isShown) {
            this.isShown = true;
            this.showPointer();

            if (this.boxState === STATES.SHOW) {
              this.showBox();
            }

            if (this.tooltipState === STATES.SHOW) {
              this.showTooltip();
            }
          }
        }

        hide() {
          if (this.isShown) {
            this.isShown = false;
            this.hideBox();
            this.hideTooltip();
            this.hidePointer();
          }
        }

        isEnabled() {
          return !this.isDisabled;
        }

        enable() {
          if (this.isDisabled) {
            this.isDisabled = false; // this.show();
          }
        }

        disable() {
          if (!this.isDisabled) {
            this.isDisabled = true;
            this.hide();
          }
        }

        hideTooltip() {
          if (this.isHovered) {
            this.isHovered = false;

            if (this.tooltip) {
              this.tooltip.removeClass(CSS_HOTSPOT_TOOLTIP + '-visible');
            }
          }
        }

        overridePointerEvent() {
          if (!this.isBoxAlwaysVisible() && !this.isTooltipAlwaysVisible()) {
            this.container.addClass(OVERWRITE_POINTER_EVENT);
          }
        }

        removeOverridePointerEvent() {
          this.container.removeClass(OVERWRITE_POINTER_EVENT);
        }

        get id() {
          return this._id;
        }

        set id(id) {
          this._id = id;
        }

        get boxSize() {
          return this.box?.size ?? {
            width: 0,
            height: 0
          };
        }

        setState(settings, dontShow) {
          // For popup, tooltip, pointer - 1 - 'visible' | 0 - 'initial'
          if (this.boxState !== settings.popup) {
            this.boxState = settings.popup;

            if (settings.popup === STATES.VISIBLE) {
              if (!dontShow) {
                this.showBox();
              }
            } else {
              this.hideBox();
            }
          }

          if (this.tooltipState !== settings.tooltip) {
            this.tooltipState = settings.tooltip;

            if (settings.tooltip === STATES.VISIBLE) {
              if (!dontShow) {
                this.showTooltip();
              }
            } else {
              this.hideTooltip();
            }
          }
        }

        rewriteAttrPointer(attr) {
          this.pointer.attr('data-spot-id', attr || this._id);
        }

        getHotspotPointer() {
          return this.pointer;
        }

        destroy() {
          this.hideBox();
          this.hideTooltip();
          this.hotspotData = null;
          this.container = null;
          this._id = null;
          this.pointer.clearEvents();

          if (this.tooltip) {
            this.tooltip.clearEvents();
          }

          this.pointer.remove();
          this.box = null;
          this.boxContainer = null;
          this.baseBoxSize = null;
          this.tooltip = null;
          this.version = null;
          this.pointer = null;
          this.hotspotSettings = null;
          this.isActive = false;
          this.isDisabled = false;
          this.isPointerInDoc = false;
          this.isHovered = false;
          super.destroy();
        }

      }

      return Hotspot;
    });
    Sirv.define('Hotspots', ['bHelpers', 'magicJS', 'globalFunctions', 'EventEmitter', 'Hotspot', 'helper'], (bHelpers, magicJS, globalFunctions, EventEmitter, Hotspot, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global Hotspot */

      /* global EventEmitter */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Hotspots" }] */

      class Hotspots extends EventEmitter {
        constructor() {
          super();
          this.container = $J.$new('div').addClass('sirv-hotspot-container');
          this.hotspots = [];
          this.activeHotspots = [];
          this.hoveredHotspots = [];
          this._originImageSize = {
            width: 0,
            height: 0
          };
          this._instanceComponentNode = null;
          this.api = {
            add: this.addHotspot.bind(this),
            remove: this.removeHotspot.bind(this),
            removeAll: this.removeAllHotspots.bind(this),
            list: () => {
              return this.hotspots.map(hs => hs.getHotspotPointer());
            },
            setVisibility: this.setStateById.bind(this),
            enable: this.enable.bind(this),
            disable: this.disable.bind(this)
          };
          this.addEvents();
        }
        /**
         * @param {{ width: number; height: number; }} size
         */


        set originImageSize(size) {
          this._originImageSize = {
            width: size.width,
            height: size.height
          };
        }

        appendTo(container) {
          this.container.appendTo(container);
        }

        set instanceComponentNode(instance) {
          if (!this.hotspots.length) {
            this._instanceComponentNode = instance;
          }
        }
        /**
         * @param {{ top: number; left: number; width: number; height: number; }} nostNodeBoundingClientRect
         */
        // set containerSize(nostNodeBoundingClientRect) {


        set containerSize(instNodeBoundingClientRect) {
          // const componentSize = this.container.node.parentNode.getBoundingClientRect();
          if (!this.hotspots.length || !instNodeBoundingClientRect) {
            return;
          }

          const componentSize = this.getRightBoundengClientRect();
          this.container.setCss({
            top: instNodeBoundingClientRect.top - componentSize.top,
            left: instNodeBoundingClientRect.left - componentSize.left,
            width: instNodeBoundingClientRect.width * 100 / componentSize.width + '%',
            height: instNodeBoundingClientRect.height * 100 / componentSize.height + '%'
          });
          const size = this.container.size;
          const dx = size.width / this._originImageSize.width;
          const dy = size.height / this._originImageSize.height;
          this.hotspots.forEach(hs => hs.setAspectRatio(dx, dy));
        }

        getActiveHotspot(id) {
          return this.activeHotspots.filter(hs => hs.id === id)[0] || null;
        }

        getHoveredHotspots(id) {
          return this.hoveredHotspots.filter(hs => hs.id === id)[0] || null;
        }

        addEvents() {
          this.on('hotspotActivate', e => {
            const activeHotspot = this.getActiveHotspot(e.data.hotspot.id);

            if (!activeHotspot) {
              e.stopEmptyEvent();
              this.activeHotspots.forEach(hs => {
                if (!hs.isBoxAlwaysVisible()) {
                  hs.hideBox(true);
                }
              });
              this.activeHotspots.push(e.data.hotspot);
              this.activeHotspots[this.activeHotspots.length - 1].overridePointerEvent();
              e.data.id = e.data.hotspot.id;
              delete e.data.hotspot;
            }
          });
          this.on('hotspotDeactivate', e => {
            e.stopEmptyEvent();
            const activeHotspot = this.getActiveHotspot(e.data.hotspot.id);

            if (activeHotspot) {
              activeHotspot.removeOverridePointerEvent();
              this.activeHotspots = this.activeHotspots.filter(hs => hs.id !== activeHotspot.id);
            }

            e.data.id = e.data.hotspot.id;
            delete e.data.hotspot;
          });
          this.on('hotspotHovered', e => {
            const hoveredHotspot = this.getHoveredHotspots(e.data.hotspot.id);

            if (!hoveredHotspot) {
              e.stopAll();
              this.hoveredHotspots.push(e.data.hotspot);
            }
          });
          this.on('hotspotLeft', e => {
            e.stopAll();
            const hoveredHotspot = this.getHoveredHotspots(e.data.hotspot.id);

            if (hoveredHotspot) {
              this.hoveredHotspots = this.hoveredHotspots.filter(hs => hs.id !== hoveredHotspot.id);
            }
          });

          this.clickFn = e => {
            this.activeHotspots.forEach(hs => {
              if (!hs.isBoxAlwaysVisible()) {
                hs.hideBox(true);
              }
            });
            this.hoveredHotspots.forEach(hs => {
              if (!hs.isTooltipAlwaysVisible()) {
                hs.hideTooltip(true);
              }
            });
          };

          $($J.D).addEvent('click', this.clickFn);
        }

        isHotspotActivated() {
          return this.activeHotspots.length > 0;
        }

        createHotspots(hotspotsData) {
          if (hotspotsData && hotspotsData.length) {
            hotspotsData.forEach(data => {
              this.createHotspot(data, this.hotspots.length);
            });
          }
        }

        createHotspot(hotspotData, index) {
          const hotspot = new Hotspot(this.container, hotspotData, index);
          hotspot.parentClass = this;
          this.hotspots.push(hotspot);
        }

        addHotspot(hotspotsData) {
          if (!Array.isArray(hotspotsData)) {
            hotspotsData = [hotspotsData];
          }

          this.createHotspots(hotspotsData, this.hotspots.length);
        }

        getRightBoundengClientRect(hotspotsContainer) {
          if (!this.hotspots.length) {
            return this._instanceComponentNode ? this._instanceComponentNode.node.getBoundingClientRect() : hotspotsContainer.node.getBoundingClientRect();
          }

          return this.container.node.parentNode.getBoundingClientRect();
        }

        changeBoxContainerParent(inside) {
          const c = inside ? this.container : null;
          this.hotspots.forEach(hotspot => {
            hotspot.changeBoxContainer(c);
          });
        }

        hideActiveHotspotBox(flag) {
          const result = this.activeHotspots.length || this.hoveredHotspots.length;
          this.activeHotspots.forEach(hs => {
            hs.hideBox(flag);
          });
          this.hoveredHotspots.forEach(hs => {
            hs.hideTooltip();
          });
          return result;
        }

        show(index) {
          const hs = this.hotspots[index];

          if (hs) {
            hs.show();
          }
        }

        showAll() {
          this.hotspots.forEach(hotspot => {
            hotspot.show();
          });
        }

        hide(index) {
          const hs = this.hotspots[index];

          if (hs) {
            hs.hide();
          }
        }

        hideAll() {
          this.hotspots.forEach(hotspot => {
            hotspot.hide();
          });
        }

        enable(index) {
          const hs = this.hotspots[index];

          if (hs) {
            hs.enable();
            hs.show();
          }
        }

        disable(index) {
          if (this.hotspots[index]) {
            this.hotspots[index].disable();
          }
        }

        enableAll() {
          this.hotspots.forEach(hotspot => {
            hotspot.enable();
            hotspot.show();
          });
        }

        disableAll() {
          this.hotspots.forEach(hotspot => {
            hotspot.disable();
          });
        }

        showNeededElements() {
          this.hotspots.forEach(hs => {
            if (hs.isEnabled() && hs.isHotspotShown()) {
              if (hs.isBoxAlwaysVisible()) {
                if (hs.isBoxActivated()) {
                  hs.setBoxPosition();
                }

                hs.showBox();
              }

              if (hs.isTooltipAlwaysVisible()) {
                if (hs.isTooltipHovered()) {
                  hs.setTooltipPosition();
                }

                hs.showTooltip();
              }
            }
          });
        }

        removeHotspot(index) {
          const hs = this.hotspots[index];

          if (hs) {
            hs.disable();
            hs.destroy();
            this.removeByIndex(index);

            if (!this.hotspots.length) {
              this.container.remove();
            }
          }
        }

        removeAllHotspots() {
          for (let i = this.hotspots.length - 1; i >= 0; i--) {
            this.removeHotspot(i);
          }
        }

        removeByIndex(index) {
          this.hotspots.splice(index, 1);

          if (this.hotspots.length > 0 && index === 0 || index > 0 && index <= this.hotspots.length - 1) {
            this.rewriteHotspotIndex(index);
          }
        }

        rewriteHotspotIndex(startIndex) {
          for (let index = startIndex, l = this.hotspots.length; index < l; index++) {
            this.hotspots[index].id = index;
            this.hotspots[index].rewriteAttrPointer();
          }
        }

        setStateById(index, settings) {
          if (this.hotspots[index]) {
            this.hotspots[index].setState(settings);
          }
        }

        destroy() {
          $($J.D).removeEvent('click', this.clickFn);
          this.hotspots.forEach(hotspot => {
            hotspot.destroy();
          });
          this.container = null;
          this.activeHotspots = [];
          this.hoveredHotspots = [];
          this._instanceComponentNode = null;
          this.off('hotspotActivate');
          this.off('hotspotDeactivate');
          this.off('hotspotHovered');
          this.off('hotspotLeft');
          this.hotspots = [];
          super.destroy();
        }

      }

      return Hotspots;
    });
    Sirv.define('SpinHotspots', ['bHelpers', 'magicJS', 'globalFunctions', 'EventEmitter', 'Hotspots', 'helper'], (bHelpers, magicJS, globalFunctions, EventEmitter, Hotspots, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* global Hotspots, helper*/

      /* eslint-disable guard-for-in */

      /* eslint-disable no-restricted-syntax */

      /* eslint-disable no-loop-func */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "SpinHotspots" }] */

      class SpinHotspots extends Hotspots {
        constructor() {
          super();
          this.options = {
            rows: 1,
            columns: 36,
            rowsRevers: false,
            columnsRevers: false,
            originImageSize: {}
          };
          this.row = null;
          this.col = null;
          this.hotspotsSettings = [];
        }
        /**
         * @param {any} options
         */


        set Options(options) {
          this.options = Object.assign(this.options, options || {});
        }

        get frameIndex() {
          let result;

          if (this.options.rowsRevers && this.options.columnsRevers) {
            result = (this.options.rows - this.row - 1) * this.options.columns + (this.options.columns - this.col);
          } else if (this.options.rowsRevers) {
            result = (this.options.rows - this.row - 1) * this.options.columns + this.col + 1;
          } else if (this.options.columnsRevers) {
            result = this.row * this.options.columns + (this.options.columns - this.col);
          } else {
            result = this.row * this.options.columns + this.col + 1;
          }

          return result;
        }

        createHotspotsSettings(dataSettings) {
          let firstFrame = true;

          for (let index = 0, l = dataSettings.length; index < l; index++) {
            const map = new Map();
            Object.entries(dataSettings[index].frames).forEach(([frameIndex, frame]) => {
              const settings = frame;
              settings.pointerPositionPercentage = {
                top: helper.isPercentage('' + frame.pointer.y),
                left: helper.isPercentage('' + frame.pointer.x)
              };
              Object.entries(dataSettings[index]).forEach(([item, value]) => {
                if (item !== 'frames') {
                  if (!(item === 'data' && !firstFrame)) {
                    settings[item] = value;
                    firstFrame = false;
                  }
                }
              });
              map.set(parseInt(frameIndex, 10), settings);
            });
            this.hotspotsSettings.push(map);
            firstFrame = true;
          }
        }

        createHotspots(hotspotsData) {
          if (!Array.isArray(hotspotsData)) {
            hotspotsData = [hotspotsData];
          }

          this.createHotspotsSettings(hotspotsData);
          const hotspotSettings = this.startHotspotSettings;
          super.createHotspots(hotspotSettings);
        }

        addHotspot(hotspotData) {
          if (!Array.isArray(hotspotData)) {
            hotspotData = [hotspotData];
          }

          this.createHotspotsSettings(hotspotData);
          const hotspotSettings = this.startHotspotSettings;
          super.createHotspots(hotspotSettings.slice(hotspotSettings.length - hotspotData.length));
          this.updateAndShow();
        }

        get startHotspotSettings() {
          const tempHotspotData = [];
          this.hotspotsSettings.forEach(map => {
            let startSettings = null;

            if ($J.browser.uaName === 'ie') {
              map.forEach(value => {
                if (!startSettings) {
                  startSettings = value;
                }
              });
            } else if (map.entries().next().value) {
              startSettings = map.entries().next().value[1];
            }

            if (startSettings) {
              tempHotspotData.push(startSettings);
            }
          });
          return tempHotspotData;
        }

        setFramePosition(row, col) {
          this.row = row;
          this.col = col;
        }

        updateAndShow() {
          const frameIndex = this.frameIndex;
          this.hotspotsSettings.forEach((hotspotSettings, index) => {
            const sett = hotspotSettings.get(frameIndex);
            const hs = this.hotspots[index];

            if (sett && hs.isEnabled()) {
              hs.setHotspotSettings(sett);

              if (hs.isHotspotShown()) {
                hs.setPointerPosition();
                this.showNeededElements();

                if (hs.isBoxAlwaysVisible()) {
                  hs.setBaseBoxSize(hs.boxSize);
                  hs.setBoxPosition();
                }

                if (hs.isTooltipAlwaysVisible()) {
                  hs.setTooltipPosition();
                }
              } else {
                this.show(index);
              }
            } else {
              this.hide(index);
            }
          });
        }

        hideNeededElements(flag) {
          this.activeHotspots.forEach(hs => {
            if (!hs.isBoxAlwaysVisible()) {
              hs.hideBox(flag);
            }
          });
          this.hoveredHotspots.forEach(hs => {
            if (hs.isTooltipAlwaysVisible()) {
              hs.hideTooltip(flag);
            }
          });
        }

        changeHotspotsPosition(row, col) {
          if (this.row !== row || this.col !== col) {
            this.setFramePosition(row, col);
            this.updateAndShow();
          }
        }

        showAll() {
          const position = this.frameIndex;
          this.hotspotsSettings.forEach((map, index) => {
            if (map.get(position)) {
              this.show(index);
            }
          });
        }

        enable(index) {
          if (this.hotspotsSettings[index]) {
            const hs = this.hotspots[index];
            hs.enable();

            if (this.hotspotsSettings[index].get(this.frameIndex)) {
              hs.show();
            }
          }
        }

        setStateById(index, settings) {
          if (this.hotspots[index]) {
            this.hotspots[index].setState(settings, !this.hotspotsSettings[index].get(this.frameIndex));
          }
        }

        removeHotspot(index) {
          if (this.hotspots[index]) {
            this.hotspotsSettings.splice(index, 1);
            super.removeHotspot(index);
          }
        }

        destroy() {
          super.destroy();
          this.options = null;
          this.row = null;
          this.col = null;
          this.hotspotsSettings = null;
        }

      }

      return SpinHotspots;
    });
    Sirv.define('Zoominstance', ['bHelpers', 'magicJS', 'HotspotInstance', 'ImageZoom'], (bHelpers, magicJS, HotspotInstance, ImageZoom) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* global HotspotInstance */

      /* global ImageZoom */

      /* eslint-disable class-methods-use-this */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars

      class ZoomInstance extends HotspotInstance {
        constructor(node, options, defaultSchema) {
          super(node, options, defaultSchema);
          this.zoom = null;
          this.upscale = false;
          this.defaultZoomOptions = {}; // this.zoomContainer = options.lensContainer;

          this.zoomContainer = this.instanceNode;
          this.zoomClassName = 'smv-zoomed-in';
          this.api = Object.assign(this.api, {
            zoomIn: this.zoomIn.bind(this),
            zoomOut: this.zoomOut.bind(this),
            isZoomed: this.isZoomed.bind(this) // new

          });
        }

        setDefaultZoomOptions() {
          this.defaultZoomOptions = {
            test: false,
            upscale: this.upscale,
            smoothing: true
          };
        }

        createZoom(zoomNode, options) {
          if (!this.destroyed) {
            let zoomOptions = Object.assign({}, this.defaultZoomOptions);

            if (options) {
              zoomOptions = Object.assign(zoomOptions, options);
            }

            this.zoom = new ImageZoom(this.instanceNode, zoomOptions);
            this.zoom.parentClass = this;
            return zoomOptions;
          }

          return null;
        }

        onZoomGetImage(e) {
          e.data.exactSize = true;
          e.data.maxSize = false;
          e.data.round = false;
          e.data.callbackData = {
            lens: true,
            indexX: e.data.indexX,
            indexY: e.data.indexY,
            level: e.data.level,
            number: e.data.number,
            map: e.data.map
          };
        }

        onZoomCancelLoadingOfTiles(e) {
          if (!e.data.callbackData) {
            e.data.callbackData = {};
          }

          e.data.callbackData.lens = true;
        }

        onZoomBeforeShow(e) {}

        onZoomShown(e) {}

        onZoomHidden(e) {}

        setZoomEvents() {
          if (!this.zoom) {
            return;
          }

          this.on('zoomGetImage', e => {
            e.stopAll();
            this.onZoomGetImage(e);
          });
          this.on('zoomCancelLoadingOfTiles', e => {
            e.stopAll();
            this.onZoomCancelLoadingOfTiles(e);
          });
          this.on('zoomBeforeShow', e => {
            e.stopAll();
            this.onZoomBeforeShow(e);
          });
          this.on('zoomShown', e => {
            e.stopAll();
            this.onZoomShown(e);
          });
          this.on('zoomHidden', e => {
            e.stopAll();
            this.onZoomHidden(e);
          });
        }

        zoomIn() {
          return this.ready;
        }

        zoomOut() {
          return this.ready;
        }
        /**
         * Current zoom level from 0.00 to 1.00
         * 0.00 - size of base image is equal size of zoom image
         * 1.00 - max zoom
         */


        getZoomData() {
          if (this.ready && this.zoom) {
            return this.zoom.getZoomData();
          }

          return 0;
        } // isZoomShown => isZoomed


        isZoomed() {
          if (this.ready && this.zoom) {
            return this.zoom.shown || this.zoom.showing;
          }

          return false;
        }

        isZoomSizeExist() {
          return false;
        }

        clearZoom() {
          if (this.zoom) {
            this.off('zoomGetImage');
            this.off('zoomCancelLoadingOfTiles');
            this.off('zoomBeforeShow');
            this.off('zoomShown');
            this.off('zoomHidden');
            this.zoom.destroy();
            this.zoom = null;
          }
        }

        destroy() {
          this.clearZoom();
          super.destroy();
        }

      }

      return ZoomInstance;
    });
    Sirv.define('ImageZoom', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('ImageZoom', () => {
        return '.sirv-zoom{position:absolute;backface-visibility:hidden!important;-webkit-touch-callout:none!important;-ms-user-select:none!important;user-select:none!important;outline:0!important;z-index:999999999;touch-action:none;-webkit-tap-highlight-color:transparent!important}.sirv-zoom .sirv-outside-zoom{background:#fff;box-shadow:0 0 3px rgba(153,153,153,.5)}.sirv-zoom .sirv-circle-zoom{border:0;border-radius:100%;background:rgba(255,255,255,.3)}.sirv-zoom .sirv-circle-zoom::before{position:absolute;display:block;top:0;right:0;bottom:0;left:0;border:1px solid rgba(153,153,153,.7);border-radius:100%;background:0 0;box-shadow:inset 0 0 20px 1px rgba(0,0,0,.3);content:\'\';z-index:126}.sirv-zoom .sirv-zoom-wrapper{position:absolute;display:inline-block;overflow:hidden;z-index:9}.sirv-zoom .sirv-zoom-wrapper .sirv-zoom-image-wrapper{position:absolute;overflow:hidden}.sirv-zoom .sirv-zoom-wrapper .sirv-zoom-image-wrapper>img{position:absolute;top:0;left:0;margin:0;padding:0;-webkit-user-drag:none;-ms-user-select:none;user-select:none;user-drag:none}.sirv-zoom .sirv-zoom-wrapper .sirv-deepzoom{position:relative;top:0;left:0;width:100%;height:100%;overflow:hidden;z-index:42}.sirv-zoom .sirv-zoom-wrapper .sirv-deepzoom>div{position:absolute;top:0;left:0;width:100%;height:100%}.sirv-zoom .sirv-zoom-wrapper .sirv-deepzoom>div canvas{top:0;left:0}.zoom-helper{position:fixed;border-radius:4px;display:inline-block;top:10px;right:10px;padding:10px;border:1px solid #ccc9c9;background-color:#eaeaea;box-shadow:1px 1px 9px 1px rgba(0,0,0,.5);overflow:hidden;z-index:999;overflow-y:auto}.zoom-helper .z-loaded-color{background-color:#87bd89!important}.zoom-helper .z-loading-color{background-color:#a99cef!important}.zoom-helper .z-canceled-color{background-color:#f19c9c!important}.zoom-helper .z-helper-head{margin-bottom:9px}.zoom-helper .z-body,.zoom-helper .z-head,.zoom-helper .z-level{position:relative}.zoom-helper .z-level{border-radius:4px;margin-bottom:9px;padding:10px;background-color:#d4d3d3;box-sizing:border-box}.zoom-helper .z-head{margin-bottom:9px}.zoom-helper .z-body{border-top:1px solid;border-left:1px solid}.zoom-helper .z-tile{position:absolute;display:inline-block;border-right:1px solid;border-bottom:1px solid;box-sizing:border-box}.zoom-helper .z-status{border-radius:50%;display:inline-block;width:10px;height:10px;margin-left:10px;background-color:#e87979;box-sizing:border-box}.zoom-helper .z-status.shown{background-color:#66ca66!important}.sirv-zoom-map{position:absolute;box-sizing:border-box;bottom:16px;left:16px;width:200px;height:150px;border:1px solid #bdbdbd;overflow:hidden;z-index:126;cursor:pointer}.sirv-zoom-map .sirv-zoom-map-lens{position:absolute;box-sizing:border-box;top:50px;left:50px;width:50px;height:50px;border:1px solid #fff;z-index:42}.sirv-zoom-map .sirv-zoom-map-lens::after,.sirv-zoom-map .sirv-zoom-map-lens::before{position:absolute;display:block;width:100%;height:100%;content:\'\'}.sirv-zoom-map .sirv-zoom-map-lens::before{box-sizing:content-box;border-width:1em;border-style:solid;border-color:rgba(0,0,0,.6);border-image:initial;top:-1em;left:-1em}.sirv-zoom-map .sirv-zoom-map-lens::after{box-sizing:border-box;border-width:1px;border-style:solid;border-color:#fff;border-image:initial}.sirv-zoom-map>img{position:relative;top:0;left:0;width:100%;height:100%}.sirv-zoom-lens,.sirv-zoom-lens-wrapper{position:absolute;top:0;left:0}.sirv-zoom-lens-wrapper{background-color:rgba(153,153,153,.4);overflow:hidden;z-index:9999999999}.sirv-zoom-lens{box-shadow:0 0 3px rgba(153,153,153,.5);overflow:hidden}.sirv-zoom-lens img{max-width:none!important;max-height:none!important;transition:none!important}.sirv-filter-bw{filter:grayscale(.5) opacity(.5);filter:url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'saturate\' values=\'0\'/><feComponentTransfer><feFuncA type=\'linear\' slope=\'0.6\'/></feComponentTransfer></filter></svg>#grayscale")}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* eslint-disable no-unused-vars */

      const CURSOR_STATES = {
        canZoom: 'smv-cursor-zoom',
        zoomIn: 'smv-cursor-zoom-in',
        zoomOut: 'smv-cursor-zoom-out',
        drag: 'smv-cursor-dragging'
      };
      const TOUCH = ['mousedrag', 'touchdrag'];
      const TOUCHEND = ['edge', 'ie'].includes($J.browser.uaName) ? 'pointerup' : 'touchend';
      const MOVE = ['edge', 'ie'].includes($J.browser.uaName) ? 'pointermove' : 'mousemove';

      const getPercentValue = (value, percent) => {
        return value / 100 * percent;
      };

      const getDifference = (bigValue, smallValue) => {
        return (bigValue - smallValue) / 2;
      };

      const checkImagePosition = (value, minPos, maxPos, lensSize) => {
        if (value > minPos) {
          value = minPos;
        }

        if (value + maxPos < lensSize) {
          value = lensSize - maxPos;
        }

        return value;
      };

      const getPercent = (value, size) => {
        return value / size * 100;
      };

      const checkRange = (value, min, max) => {
        if (value < min) {
          value = min;
        }

        if (value > max) {
          value = max;
        }

        return value;
      };

      const calcScale = (baseSize, currentSize) => {
        return currentSize / baseSize;
      };

      const getLevels = (minSize, maxSize) => {
        let levelsNumber = Math.max(1, Math.round(Math.log(Math.max(maxSize.width / minSize.width, maxSize.height / minSize.height)) / Math.LN2));
        let levelWidth = maxSize.width;
        let levelHeight = maxSize.height;
        const result = [];

        while (levelsNumber > 0) {
          levelsNumber -= 1;
          result.push({
            width: levelWidth,
            height: levelHeight
          });
          levelWidth = parseInt(levelWidth / 2, 10);
          levelHeight = parseInt(levelHeight / 2, 10);
        }

        return result;
      };
      /* eslint-env es6 */

      /* global EventEmitter */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint class-methods-use-this: ["off", { "_setItemClass": ["error"] }] */

      /* start-removable-tile-helper-block */
      // eslint-disable-next-line no-unused-vars


      class ZoomHelper extends EventEmitter {
        constructor(options) {
          super();
          this.o = Object.assign({
            maxTileSize: 15,
            minTileSize: 5
          }, options || {});
          this.inDoc = false;
          this.container = $J.$new('div').addClass('zoom-helper');
          this.header = $J.$new('div').addClass('z-helper-head');
          this.zoom = $J.$new('span').addClass('z-zoom');
          this.tileSize = {
            width: 0,
            height: 0
          };
          this.levels = {};
        }

        _createHead() {
          let tmp = $J.$new('div');
          tmp.innerHTML = 'Zoom: ';
          tmp.append(this.zoom);
          this.setZoom(0);
          this.header.append(tmp);
          tmp = $J.$new('div');
          tmp.innerHTML = '<div class="z-status z-canceled-color"></div> - canceled';
          this.header.append(tmp);
          tmp = $J.$new('div');
          tmp.innerHTML = '<div class="z-status z-loading-color"></div> - loading';
          this.header.append(tmp);
          tmp = $J.$new('div');
          tmp.innerHTML = '<div class="z-status z-loaded-color"></div> - loaded';
          this.header.append(tmp);
        }

        _calcSizeOfTile(levelSize) {
          const getSize = (sizeOfPart, aspectRatio) => {
            let result = parseInt(sizeOfPart * aspectRatio, 10);

            if (result < this.o.minTileSize) {
              result = this.o.minTileSize;
            }

            return result;
          };

          let w;
          let h;

          if (levelSize.width > levelSize.height) {
            w = this.o.maxTileSize;
            h = getSize(w, levelSize.height / levelSize.width);
          } else {
            h = this.o.maxTileSize;
            w = getSize(h, levelSize.width / levelSize.height);
          }

          return {
            width: w,
            height: h
          };
        }

        _createTile(c, r, options) {
          const getSize = (isLast, size) => {
            return isLast ? (() => {
              let s = parseInt(size / 2, 10);

              if (s < 3) {
                s = 3;
              }

              return s;
            })() : size;
          };

          const checkSize = (l, t) => {
            return l % t < t / 2;
          };

          const w = getSize(options.cols - 1 === c && checkSize(options.levelSize.width, options.tileSize.width), this.tileSize.width);
          const h = getSize(options.rows - 1 === r && checkSize(options.levelSize.height, options.tileSize.height), this.tileSize.height);
          const node = $J.$new('div').addClass('z-tile');
          node.setCss({
            top: r * this.tileSize.height + 'px',
            left: c * this.tileSize.width + 'px',
            width: w + 'px',
            height: h + 'px'
          });
          return {
            currentClass: null,
            width: w,
            height: h,
            col: c,
            row: r,
            node: node
          };
        }

        _show(level) {
          if (!level) {
            return;
          }

          if (!this.inDoc) {
            this.inDoc = true;

            this._createHead();

            this.container.append(this.header);
            $($J.D.node.body).append(this.container);
          }

          if (!level.inDoc) {
            level.inDoc = true;
            this.container.append(level.node);
            this.container.setCssProp('max-height', $J.W.innerHeight - 55 + 'px');
          }
        }

        _setItemClass(level, col, row, _class) {
          const tile = level.tiles[row][col];

          if (tile.currentClass !== _class) {
            if (tile.currentClass) {
              tile.node.removeClass(tile.currentClass);
            }

            tile.currentClass = _class;
            tile.node.addClass(_class);
          }
        }

        setZoom(zoom) {
          zoom += '';

          if (zoom.length < 2) {
            zoom += '.0';
          }

          this.zoom.innerHTML = zoom;
        }

        createLevel(options) {
          const node = $J.$new('div').addClass('z-level');
          const body = $J.$new('div').addClass('z-body');

          const createTiles = (cols, rows) => {
            let i;
            let j;
            const arr = [];

            for (j = 0; j < rows; j++) {
              const arr2 = [];

              for (i = 0; i < cols; i++) {
                const tile = this._createTile(i, j, options);

                body.append(tile.node);
                arr2.push(tile);
              }

              arr.push(arr2);
            }

            return arr;
          };

          const head = $J.$new('div').addClass('z-head');
          const statusContainer = $J.$new('div').addClass('z-status');
          let tmp = $J.$new('div');
          tmp.innerHTML = 'Level: ' + options.level;
          head.append(tmp);
          tmp = $J.$new('div');
          tmp.innerHTML = 'Shown:';
          tmp.append(statusContainer);
          head.append(tmp);
          tmp = $J.$new('div');
          tmp.innerHTML = options.levelSize.width + 'x' + options.levelSize.height;
          head.append(tmp);
          node.append(head);
          node.append(body);

          if (!this.tileSize.width) {
            this.tileSize = this._calcSizeOfTile(options.levelSize);
          }

          const tiles = createTiles(options.cols, options.rows);
          const last = tiles[options.rows - 1][options.cols - 1];
          body.setCss({
            width: (options.cols - 1) * this.tileSize.width + last.width + 'px',
            height: (options.rows - 1) * this.tileSize.height + last.height + 'px'
          });
          this.levels[options.level] = {
            inDoc: false,
            number: options.level,
            status: statusContainer,
            node: node,
            head: head,
            body: body,
            tiles: tiles
          };
        }

        tileAction(data) {
          const level = this.levels[data.level + ''];

          let _class;

          switch (data.type) {
            case 0:
              // canceled
              _class = 'z-canceled-color';
              break;

            case 1:
              // loading
              _class = 'z-loading-color';
              break;

            case 2:
              // loaded
              _class = 'z-loaded-color';
              break;
            // no default
          }

          this._setItemClass(level, data.col, data.row, _class);
        }

        setLevelState(levelID, value) {
          const level = this.levels[levelID + ''];
          const _class = 'shown';

          if (value) {
            if (level.inDoc) {
              level.status.addClass(_class);
            }
          } else {
            level.status.removeClass(_class);
          }
        }

        setData(data) {
          let level;

          if ($J.defined(data.level)) {
            level = this.levels[data.level + ''];
          }

          if (level) {
            this._show(level);
          }

          if (data.zoom) {
            this.setZoom(data.zoom);
          }

          if (level) {
            if ('col' in data) {
              this._setItemClass(level, data.col, data.row, 'z-loaded-color');
            }
          }

          if (level && $J.defined(data.levelStatus)) {
            this.setLevelState(data.level, data.levelStatus);
          }
        }

        destroy() {
          if (this.inDoc) {
            this.inDoc = false;
            this.zoom.remove();
            this.zoom.inneHTML = '';
            this.header.remove();
            this.header.inneHTML = '';
            this.container.remove();
            this.container.inneHTML = '';
            this.levels = {};
            this.tileSize = {
              width: 0,
              height: 0
            };
          }

          super.destroy();
        }

      }
      /* end-removable-tile-helper-block */


      const DeepZoom = (() => {
        /* eslint-env es6 */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars
        class Camera {
          constructor(options) {
            this.isInner = options.inner; // lengthOfRow

            this.rows = options.lengthOfRow; // lengthOfColumn

            this.cols = options.lengthOfColumn;
            this.size = {
              width: options.cameraWidth,
              height: options.cameraHeight
            }; // baseMapSize

            this.bMapS = {
              width: options.mapWidth,
              height: options.mapHeight
            }; // baseTileSize

            this.bTileS = {
              width: options.tileWidth,
              height: options.tileHeight
            }; // baseScale

            this.bScale = {
              x: options.scaleX,
              y: options.scaleY
            }; // mapSize

            this.mapS = {
              width: this.bMapS.width,
              height: this.bMapS.height
            }; // tileSize

            this.tileS = {
              width: this.bTileS.width,
              height: this.bTileS.height
            };
            this.baseLastTileSize = {
              width: this.bMapS.width - (this.cols - 1) * this.bTileS.width,
              height: this.bMapS.height - (this.rows - 1) * this.bTileS.height
            };
            this.lastTileSize = {
              width: this.baseLastTileSize.width,
              height: this.baseLastTileSize.height
            };
            this.position = {
              x: 0,
              y: 0
            };
            this.lastCorrectionPosition = {
              x: 0,
              y: 0
            };
            this.scale = {
              x: 0,
              y: 0
            };
            this.lastScale = 0;
            this.lastGlobaslScale = 0;
            this.count = {
              x: 0,
              y: 0
            };
            this.calcCount();
            this.shownTiles = {
              startX: 0,
              countX: this.count.x,
              startY: 0,
              countY: this.count.y
            };
          }

          static getTileIndex(position, tileSize) {
            return Math.floor(position / tileSize);
          }

          static getTileSize(size, scale) {
            return size * scale;
          }

          get x() {
            return this.position.x;
          }

          get y() {
            return this.position.y;
          }

          get width() {
            return this.size.width;
          }

          get height() {
            return this.size.height;
          }

          get mapWidth() {
            return this.mapS.width;
          }

          get mapHeight() {
            return this.mapS.height;
          }

          get shownTilesX() {
            return this.shownTiles.startX;
          }

          get shownTilesY() {
            return this.shownTiles.startY;
          }

          get shownTilesWidth() {
            return this.shownTiles.countX;
          }

          get shownTilesHeight() {
            return this.shownTiles.countY;
          }

          get scaleX() {
            return this.scale.x;
          }

          get scaleY() {
            return this.scale.y;
          }

          set mapWidth(width) {
            if (width !== null && width !== undefined) {
              this.mapS.width = width;
            }
          }

          set mapHeight(height) {
            if (height !== null && height !== undefined) {
              this.mapS.height = height;
            }
          }

          checkTile(x, y) {
            const st = this.shownTiles;
            return st.startX <= x && st.startY <= y && st.startX + st.countX > x && st.startY + st.countY > y;
          }

          calcCount() {
            this.count = {
              x: Math.ceil(this.size.width / this.tileS.width) + 1,
              y: Math.ceil(this.size.height / this.tileS.height) + 1
            };
          }

          findShownTiles() {
            const p = this.position;
            const ts = this.tileS;
            let startX = 0;
            let startY = 0;
            let countX = this.count.x;
            let countY = this.count.y;

            if (p.x < 0) {
              startX = Camera.getTileIndex(Math.abs(p.x), ts.width);
            }

            if (p.y < 0) {
              startY = Camera.getTileIndex(Math.abs(p.y), ts.height);
            }

            if (startX + countX > this.cols) {
              countX = this.cols - startX;
            }

            if (startY + countY > this.rows) {
              countY = this.rows - startY;
            }

            this.shownTiles = {
              startX: startX,
              countX: countX,
              startY: startY,
              countY: countY
            };
          }

          calcTileSize() {
            this.tileS.width = Camera.getTileSize(this.bTileS.width, this.scale.x);
            this.tileS.height = Camera.getTileSize(this.bTileS.height, this.scale.y);
            this.lastTileSize.width = Camera.getTileSize(this.baseLastTileSize.width, this.scale.x);
            this.lastTileSize.height = Camera.getTileSize(this.baseLastTileSize.height, this.scale.y);
          }

          calcData(position) {
            if (this.lastScale !== this.scale.x) {
              this.calcTileSize();
              this.calcCount();
              this.mapS.width = this.tileS.width * (this.cols - 1) + this.lastTileSize.width;
              this.mapS.height = this.tileS.height * (this.rows - 1) + this.lastTileSize.height;
              this.lastCorrectionPosition.x = (this.bMapS.width * this.bScale.x - this.mapS.width) / 2;
              this.lastCorrectionPosition.y = (this.bMapS.height * this.bScale.y - this.mapS.height) / 2;
              this.lastScale = this.scale.x;
            }

            this.position.x = position.x + this.lastCorrectionPosition.x;
            this.position.y = position.y + this.lastCorrectionPosition.y;
          }

          action(position, scale) {
            if (this.lastGlobaslScale !== scale.x) {
              this.lastScale = this.scale.x;
              this.scale.x = scale.x * this.bScale.x;
              this.scale.y = scale.y * this.bScale.y;
              this.lastGlobaslScale = scale.x;
            }

            this.calcData(position);
            this.findShownTiles();
          }

          resize(viewPort) {
            this.size.width = viewPort.width;
            this.size.height = viewPort.height;
            this.calcCount();
            this.findShownTiles();
          }

          destroy() {
            this.shownTiles = [];
          }

        }
        /* eslint-env es6 */

        /* global Map */

        /* global EventEmitter */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


        const TILE_STATES = {
          NOT_LOADED: 0,
          LOADING: 1,
          LOADED: 2
        }; // eslint-disable-next-line no-unused-vars

        class Tile extends EventEmitter {
          constructor(options) {
            super();
            this.id = options.id;
            this.index = {
              x: options.indexX,
              y: options.indexY
            };
            this.position = {
              x: options.x,
              y: options.y
            };
            this.size = {
              width: options.width,
              height: options.height
            };
            this.storage = options.storage;
            this.state = TILE_STATES.NOT_LOADED;
            this.node = null;

            if (this.storage.has(this.id)) {
              this.node = this.storage.get(this.id);
              this.state = TILE_STATES.LOADED;
            }
          }

          get loaded() {
            return this.state === TILE_STATES.LOADED;
          }

          addImageToStorage() {
            if (!this.storage.has(this.id)) {
              this.storage.set(this.id, this.node);
            }
          }

          load() {
            if (this.state === TILE_STATES.NOT_LOADED) {
              this.state = TILE_STATES.LOADING;
              this.emit('getTile', {
                data: {
                  indexX: this.index.x,
                  indexY: this.index.y,
                  number: this.id
                }
              });
            }
          }

          cancelLoading() {
            if (this.state === TILE_STATES.LOADING) {
              this.state = TILE_STATES.NOT_LOADED;
              this.emit('zoomCancelLoadingOfTiles', {
                data: {
                  indexX: this.index.x,
                  indexY: this.index.y,
                  number: this.id
                }
              });
            }
          }
          /**
           * @param {nodeElement} node
           */


          set image(node) {
            if (this.state !== TILE_STATES.LOADED) {
              this.state = TILE_STATES.LOADED;
              this.node = $(node);
              this.addImageToStorage();
            }
          }

          destroy() {
            this.cancelLoading();
            this.storage = null;
            super.destroy();
          }

        }
        /* eslint-env es6 */
        // eslint-disable-next-line no-unused-vars


        class LevelView {
          constructor(parent, dppx) {
            this.p = $(parent);
            this.dppx = dppx; // wrapper

            this.w = $J.$new('div');
            this.cvs = $J.$new('canvas');
            this.ctx = this.cvs.node.getContext('2d');
            this.w.append(this.cvs);
          }
          /**
           * @param {string | number} index
           */


          set index(index) {
            this.w.addClass('deepzoom-level-' + index);
            this.w.attr('z-index' + (index + 1));
          }

          append() {
            this.p.append(this.w);
          }

          show() {
            this.w.setCssProp('display', '');
          }

          hide() {
            this.w.setCssProp('display', 'none');
          }

          clear() {
            this.ctx.clearRect(0, 0, this.cvs.node.width, this.cvs.node.height);
          }

          draw(scaleX, scaleY, moveX, moveY) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.clear();
            this.ctx.setTransform(scaleX, 0, 0, scaleY, moveX, moveY);
          }

          drawTile(tileNode, tileSize, tilePosition) {
            if ($J.browser.uaName === 'edge' || $J.browser.uaName === 'ie') {
              if (this.dppx > 1) {
                this.ctx.drawImage(tileNode.node, 0, 0, tileSize.width, tileSize.height, tilePosition.x, tilePosition.y, tileSize.width, tileSize.height);
              } else {
                this.ctx.drawImage(tileNode.node, tilePosition.x, tilePosition.y, tileSize.width, tileSize.height);
              }
            } else {
              this.ctx.drawImage(tileNode.node, 0, 0, tileSize.width, tileSize.height, tilePosition.x, tilePosition.y, tileSize.width, tileSize.height);
            }
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set canvasSize(size) {
            this.cvs.setCss(size);
            this.cvs.attr('width', size.width * this.dppx);
            this.cvs.attr('height', size.height * this.dppx);
          }

          destroy() {
            this.cvs.remove();
            this.w.remove();
          }

        }
        /* eslint-env es6 */

        /* global Map, Camera, Tile, zoomHelper, EventEmitter */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


        const TILES_HASH_STORAGE = new Map();

        const getCorrectedTileSize = (value, dppx) => {
          // return value * ((1 - (dppx - 1)) || 1);
          // dppx -= 1;
          // if (dppx <= 0) { dppx = 1; }
          // return value * dppx;
          return value / dppx;
        }; // eslint-disable-next-line no-unused-vars


        class Level extends EventEmitter {
          constructor(view, options) {
            super();
            this.view = view;
            this.id = options.id; // number of level

            this.dppx = options.dppx;
            this.size = {
              width: options.width,
              height: options.height
            }; // size of level image
            // maxSize

            this.mSize = {
              width: options.maxWidth,
              height: options.maxHeight
            }; // size of biggest image
            // tileSize

            this.tSize = {
              width: options.tileWidth,
              height: options.tileHeight
            };
            this.tileImageSize = {
              width: options.tileImageWidth,
              height: options.tileImageHeight
            };
            this.layerSize = {
              width: options.layerWidth,
              height: options.layerHeight
            };
            this.hash = options.hash + '-' + (this.size.width + 'x' + this.size.height);

            if (!TILES_HASH_STORAGE.has(this.hash)) {
              TILES_HASH_STORAGE.set(this.hash, new Map());
            }

            this.scaleFactor = {
              x: (this.mSize.width - this.size.width) / this.size.width + 1,
              y: (this.mSize.height - this.size.height) / this.size.height + 1
            };
            this.maxDisplayedSize = {
              width: options.maxDisplayedWidth,
              height: options.maxDisplayedHeight
            };
            this.minDisplayedSize = {
              width: options.minDisplayedWidth,
              height: options.minDisplayedHeight
            };
            this.globalScale = {
              x: 1,
              y: 1
            };
            this.globalPosition = {
              x: 0,
              y: 0
            };
            this.view.index = this.id;
            this.lensSize = {
              width: options.viewPortWidth,
              height: options.viewPortHeight
            };
            this.isAdded = false;
            this.isShown = false;
            this.tiles = this.calcTiles();
            this.countOfTiles = this.tiles.length * this.tiles[0].length;
            this.loadedTiles = 0;
            this.camera = new Camera({
              inner: options.inner,
              scaleX: this.scaleFactor.x,
              scaleY: this.scaleFactor.y,
              cameraWidth: options.viewPortWidth,
              cameraHeight: options.viewPortHeight,
              mapWidth: this.size.width,
              mapHeight: this.size.height,
              tileWidth: getCorrectedTileSize(this.tileImageSize.width, this.dppx),
              tileHeight: getCorrectedTileSize(this.tileImageSize.height, this.dppx),
              lengthOfRow: this.tiles.length,
              lengthOfColumn: this.tiles[0].length
            });
            /* start-removable-tile-helper-block */

            if (zoomHelper) {
              zoomHelper.createLevel({
                level: this.id,
                cols: this.tiles[0].length,
                rows: this.tiles.length,
                levelSize: {
                  width: this.size.width,
                  height: this.size.height
                },
                tileSize: {
                  width: this.tileImageSize.width,
                  height: this.tileImageSize.height
                }
              });
            }
            /* end-removable-tile-helper-block */

          }

          addEvents() {
            const ts = this.tileImageSize;
            this.on('getTile', e => {
              e.data.width = this.size.width;
              e.data.height = this.size.height;
              e.data.level = this.id;
              e.data.imageSettings = {
                tile: {
                  width: ts.width,
                  height: ts.height,
                  number: e.data.number
                }
              };

              if (this.dppx > 1) {
                e.data.dppx = this.dppx;
              }
              /* start-removable-tile-helper-block */


              if (zoomHelper) {
                zoomHelper.tileAction({
                  level: this.id,
                  col: e.data.indexX,
                  row: e.data.indexY,
                  type: 1
                });
              }
              /* end-removable-tile-helper-block */

            });
            this.on('zoomCancelLoadingOfTiles', e => {
              e.data.width = this.size.width;
              e.data.height = this.size.height;
              e.data.imageSettings = {
                tile: {
                  width: ts.width,
                  height: ts.height,
                  number: e.data.number
                }
              };
              /* start-removable-tile-helper-block */

              if (zoomHelper) {
                zoomHelper.tileAction({
                  level: this.id,
                  col: e.data.indexX,
                  row: e.data.indexY,
                  type: 0
                });
              }
              /* end-removable-tile-helper-block */

            });
          }

          cancelLoadingOfTiles() {
            this.tiles.forEach(row => {
              row.forEach(tile => {
                tile.cancelLoading();
              });
            });
          }
          /**
           * @param {{ indexY: number; indexX: number; node: nodeElement; }} imageData
           */


          set image(imageData) {
            const tile = this.tiles[imageData.indexY][imageData.indexX];

            if (!tile.loaded) {
              this.loadedTiles += 1;
            }

            tile.image = imageData.node;

            if (this.isShown && this.camera.checkTile(imageData.indexX, imageData.indexY)) {
              this.drawTile(tile);
            }
            /* start-removable-tile-helper-block */


            if (zoomHelper) {
              zoomHelper.setData({
                level: this.id,
                col: imageData.indexX,
                row: imageData.indexY
              });
            }
            /* end-removable-tile-helper-block */

          }

          append() {
            if (!this.isAdded && this.isShown) {
              this.isAdded = true;
              this.addEvents();
              this.view.append();
            }
          }

          calcTiles() {
            const result = [];
            const ts = this.tileImageSize;
            const l1 = Math.ceil(this.layerSize.width / ts.width);
            const l2 = Math.ceil(this.layerSize.height / ts.height);

            for (let j = 0; j < l2; j++) {
              const arr = $([]);

              for (let i = 0; i < l1; i++) {
                const tile = new Tile({
                  y: j * ts.height,
                  x: i * ts.width,
                  indexX: i,
                  indexY: j,
                  id: j * l1 + i,
                  width: i !== l1 - 1 ? ts.width : this.layerSize.width - i * ts.width,
                  height: j !== l2 - 1 ? ts.height : this.layerSize.height - j * ts.height,
                  storage: TILES_HASH_STORAGE.get(this.hash)
                });
                tile.parentClass = this;
                arr.push(tile);
              }

              result.push(arr);
            }

            return result;
          }

          correctDPPXPosition(pos, lensSize, imageSize) {
            let result = pos;

            if (this.dppx > 1) {
              const center = lensSize / 2;
              result = Math.abs(pos - center) / (imageSize / 100);
              result = center * this.dppx - imageSize * this.dppx / 100 * result;
            }

            return result;
          }

          draw() {
            const c = this.camera;

            if (this.isShown) {
              this.view.draw(c.scaleX, c.scaleY, this.correctDPPXPosition(c.x, c.width, c.mapWidth), this.correctDPPXPosition(c.y, c.height, c.mapHeight));
              this.eachTile(tile => {
                this.drawTile(tile);
              });
            }
          }

          drawTile(tile) {
            if (tile && tile.loaded) {
              this.view.drawTile(tile.node, tile.size, tile.position);
            }
          }

          eachTile(callback) {
            const c = this.camera;

            for (let y = 0, l = c.shownTilesHeight; y < l; y++) {
              for (let x = 0, l2 = c.shownTilesWidth; x < l2; x++) {
                callback(this.tiles[c.shownTilesY + y][c.shownTilesX + x]);
              }
            }
          }

          checkSize() {
            const last = this.isShown;
            const c = this.camera;
            const v1 = c.mapWidth <= this.maxDisplayedSize.width;
            const v2 = c.mapHeight <= this.maxDisplayedSize.height;
            const v3 = c.mapWidth > this.minDisplayedSize.width;
            const v4 = c.mapHeight > this.minDisplayedSize.height;
            this.isShown = v1 && v2 && v3 && v4;

            if (last !== this.isShown) {
              if (this.isShown) {
                this.view.show();
              } else {
                this.view.hide();
              }

              if (!this.isShown) {
                this.cancelLoadingOfTiles();
              }
            }
          }

          action(position, scale) {
            this.globalPosition.x = position.x;
            this.globalPosition.y = position.y;
            this.globalScale.x = scale.x;
            this.globalScale.y = scale.y;
            this.camera.action(this.globalPosition, this.globalScale);

            if (this.camera.mapWidth > this.mSize.width || this.camera.mapHeight > this.mSize.height) {
              this.camera.mapWidth = this.mSize.width;
              this.camera.mapHeight = this.mSize.height;
            }

            this.checkSize();
            this.append();
            this.draw();
            /* start-removable-tile-helper-block */

            if (zoomHelper) {
              zoomHelper.setData({
                level: this.id,
                levelStatus: this.isShown
              });
            }
            /* end-removable-tile-helper-block */

          }

          loadImages() {
            if (this.isShown && this.loadedTiles !== this.countOfTiles) {
              this.eachTile(tile => {
                tile.load();
              });
            }
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set lensSize(size) {
            this.view.canvasSize = size;
          }

          resize(cameraSize) {
            this.lensSize = cameraSize;
            this.camera.resize(cameraSize);
            this.action(this.globalPosition, this.globalScale);
          }

          destroy() {
            this.off('getTile');
            this.off('zoomCancelLoadingOfTiles');
            this.isShown = false;
            this.camera.destroy();
            this.tiles.forEach(row => {
              row.forEach(tile => {
                tile.destroy();
              });
            });
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars


        class ZoomView {
          constructor(parentNode, classPrefix) {
            this.p = $(parentNode); // container

            this.c = $J.$new('div');
            this.c.addClass(classPrefix + '-deepzoom');
          }

          get container() {
            return this.c;
          }

          show() {
            this.p.append(this.c);
          }

          hide() {
            this.c.remove();
          }

          destroy() {
            this.c.remove();
            this.c = null;
          }

        }
        /* eslint-env es6 */

        /* global Level, getPercentValue, zoomHelper, EventEmitter, helper, LevelView, calcScale, getLevels */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars


        class ZoomController extends EventEmitter {
          constructor(view, options) {
            super();
            this.view = view;
            this.options = Object.assign({
              tiles: true,
              inner: true,
              tileSize: {
                width: 256,
                height: 256
              },
              minZoomFactor: 100,
              // px
              upscale: false
            }, options);
            this._hash = null;
            this.setDefaultVars();
          }

          static convertScaleToSize(size, scale) {
            return {
              width: helper.round(size.width * scale.x, 2),
              height: helper.round(size.height * scale.y, 2)
            };
          }
          /**
           * @param {string} url
           */


          set hash(url) {
            // this._hash = '' + $J.getHashCode(url.split('?')[0]);
            this._hash = '' + $J.getHashCode(url);
          } // private


          setDefaultVars() {
            this.isShown = false;
            this.originSize = {
              width: 0,
              height: 0
            };
            this._maxSize = {
              width: 0,
              height: 0
            };
            this._minSize = {
              width: 0,
              height: 0
            };
            this._lensSize = {
              width: 0,
              height: 0
            };
            this.currentSize = {
              width: 0,
              height: 0
            };
            this.levels = $([]);
            this.on('getTile', e => {
              if (!this.options.tiles) {
                delete e.data.imageSettings.tile;
                delete e.data.number;
              }
            });
          } // private


          createLevels() {
            const calcTileImageSize = (value, dppx) => {
              return dppx < 1.5 ? value : value * $J.DPPX;
            };

            const maxSize = this._maxSize;
            const minSize = this._minSize;

            if (!this.levels.length && maxSize.width - minSize.width > this.options.minZoomFactor) {
              let arr = [];

              if (this.options.inner) {
                arr = getLevels(minSize, maxSize, this.options.inner);
              } else {
                arr.push({
                  width: maxSize.width,
                  height: maxSize.height
                });
              }

              let tileSize = this.options.tileSize;

              for (let i = 0, l = arr.length; i < l; i++) {
                if (!this.options.tiles) {
                  tileSize = arr[i];
                }

                const _minSize = i + 1 < l - 1 ? arr[i + 1] : minSize;

                const _maxSize = i - 1 >= 0 ? arr[i - 1] : maxSize;

                const dppx = helper.getDPPX(arr[i].width, this.originSize.width, this.options.upscale);
                const levelView = new LevelView(this.view.container, dppx);

                const _level = new Level(levelView, {
                  id: l - i,
                  hash: this._hash,
                  dppx: dppx,
                  inner: this.options.inner,
                  width: arr[i].width,
                  height: arr[i].height,
                  maxWidth: this._maxSize.width,
                  maxHeight: this._maxSize.height,
                  layerWidth: Math.round(arr[i].width * dppx),
                  layerHeight: Math.round(arr[i].height * dppx),
                  maxDisplayedWidth: arr[i].width + getPercentValue(_maxSize.width - arr[i].width, 50),
                  maxDisplayedHeight: arr[i].height + getPercentValue(_maxSize.height - arr[i].height, 50),
                  minDisplayedWidth: _minSize.width + getPercentValue(arr[i].width - _minSize.width, 50),
                  minDisplayedHeight: _minSize.height + getPercentValue(arr[i].height - _minSize.height, 50),
                  tileWidth: tileSize.width,
                  tileHeight: tileSize.height,
                  tileImageWidth: calcTileImageSize(tileSize.width, dppx),
                  tileImageHeight: calcTileImageSize(tileSize.height, dppx),
                  viewPortWidth: this._lensSize.width,
                  viewPortHeight: this._lensSize.height
                });

                _level.parentClass = this;
                this.levels.push({
                  view: levelView,
                  controller: _level
                });
              }

              this.levels.reverse();
            }
          }

          getCurrentShownLevel() {
            let result = null;
            const l = this.levels.length;

            if (this.isShown) {
              for (let i = l - 1; i >= 0; i--) {
                if (this.levels[i].controller.isShown) {
                  result = this.levels[i].controller;
                  break;
                }
              }
            }

            return result;
          }

          getScale(direction) {
            const level = this.getCurrentShownLevel();
            let scale;
            const l = this.levels.length;

            switch (direction) {
              case 'zoomin':
                if (level) {
                  if (this.currentSize.width < level.size.width) {
                    scale = calcScale(this._maxSize.width, level.size.width);
                  } else if (level.id !== l) {
                    scale = calcScale(this._maxSize.width, this.levels[level.id].controller.size.width);
                  } else {
                    scale = calcScale(this._maxSize.width, this.levels[l - 1].controller.size.width);
                  }
                } else {
                  scale = calcScale(this._maxSize.width, this.levels[0].controller.size.width);
                }

                break;

              case 'zoomout':
                if (level) {
                  if (this.currentSize.width > level.size.width) {
                    scale = calcScale(this._maxSize.width, level.size.width);
                  } else if (level.id > 1) {
                    scale = calcScale(this._maxSize.width, this.levels[level.id - 2].controller.size.width);
                  } else {
                    scale = calcScale(this._maxSize.width, this._minSize.width);
                  }
                } else {
                  scale = calcScale(this._maxSize.width, this._minSize.width);
                }

                break;
              // no default
            }

            return scale;
          }

          show() {
            if (!this.isShown) {
              this.isShown = true;
              this.view.show();
            }

            return this;
          }

          hide() {
            if (this.isShown) {
              this.isShown = false;
              this.view.hide();
              this.levels.forEach(level => {
                level.view.destroy();
                level.controller.destroy();
              });
              this.setDefaultVars();
            }

            return this;
          }

          action(position, scale) {
            if (this.isShown) {
              this.currentSize = ZoomController.convertScaleToSize(this._maxSize, scale);
              this.levels.forEach(level => {
                level.controller.action(position, scale);
              });
              /* start-removable-tile-helper-block */

              if (zoomHelper) {
                zoomHelper.setData({
                  zoom: helper.round(this.currentSize.width / this._minSize.width, 1, this.currentSize.width === this._maxSize.width)
                });
              }
              /* end-removable-tile-helper-block */

            }

            return this;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set lensSize(size) {
            this._lensSize.width = size.width;
            this._lensSize.height = size.height;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set minSize(size) {
            this._minSize.width = size.width;
            this._minSize.height = size.height;
          }
          /**
           * @param {{ width: number; height: number; originWidth: number; originHeight: number; }} size
           */


          set maxSize(size) {
            this._maxSize.width = size.width;
            this._maxSize.height = size.height;
            this.originSize.width = size.originWidth;
            this.originSize.height = size.originHeight;
            this.createLevels();
          }

          loadImages() {
            if (this.isShown) {
              this.levels.forEach(level => {
                level.controller.loadImages();
              });
            }
          }
          /**
           * @param {{ indexY: number; indexX: number; node: nodeElement; level: number; }} data
           */


          set image(data) {
            if (this.isShown) {
              this.levels[data.level - 1].controller.image = data;
            }
          }

          resize() {
            if (this.isShown) {
              this.levels.forEach(level => {
                level.controller.resize(this._lensSize);
              });
            }
          }

          destroy() {
            this.hide();
            this.off('getTile');
            this.off('zoomCancelLoadingOfTiles');
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* global EventEmitter */

        /* global ZoomView */

        /* global ZoomController */

        /* eslint-disable indent */

        /* eslint-disable no-lonely-if */

        /* eslint no-unused-vars: ["error", { "args": "none" }] */

        /* eslint guard-for-in: "off"*/

        /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars


        class DZoom extends EventEmitter {
          constructor(parentNode, options) {
            super();
            this.view = new ZoomView(parentNode, 'sirv');
            this.controller = new ZoomController(this.view, options);
            this.controller.parentClass = this;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set lensSize(size) {
            this.controller.lensSize = size;
          }

          loadImages() {
            this.controller.loadImages();
          }

          getScale(direction) {
            return this.controller.getScale(direction);
          }
          /**
           * @param {{ indexY: number; indexX: number; node: nodeElement; }} data
           */


          set image(data) {
            this.controller.image = data;
          }
          /**
           * @param {string} hash
           */


          set hash(hash) {
            this.controller.hash = hash;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set minSize(size) {
            this.controller.minSize = size;
          }
          /**
           * @param {{ width: number; height: number; originWidth: number; originHeight: number; }} size
           */


          set maxSize(size) {
            this.controller.maxSize = size;
          }

          show() {
            this.controller.show();
          }

          hide() {
            this.controller.hide();
          }

          action(imageDPosition, dScale) {
            this.controller.action(imageDPosition, dScale);
          }

          resize() {
            this.controller.resize();
          }

          destroy() {
            this.controller.destroy();
            this.controller = null;
            this.view.destroy();
            this.view = null;
            super.destroy();
          }

        }

        return DZoom;
      })();

      const Eye = (() => {
        /* eslint-env es6 */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars
        class View {
          constructor(parent, hover) {
            this.pn = $(parent);
            const className = 'sirv-zoom-lens'; // container

            this.c = $J.$new('div');
            this.c.addClass(className + '-wrapper'); // insideContainer

            this.ic = $J.$new('div');
            this.ic.addClass(className);
            this.ic.appendTo(this.c);
            this.img = null; // blackAndWhiteImg

            this.bwImg = null;

            if (hover) {
              this.c.addEvent('mousedown', e => {
                e.stop();
              });
            }
          }

          get container() {
            return this.c;
          }

          calcContainerPosition() {
            if (['img', 'canvas'].includes(this.pn.tagName)) {
              const positon = this.pn.position;
              const parentPosition = $(this.pn.node.parentNode).position;
              this.c.setCss({
                top: positon.top - parentPosition.top,
                left: positon.left - parentPosition.left
              });
            }
          }
          /**
           * @param {{ width: numaber; height: numaber; }} size
           */


          set imageSize(size) {
            if (this.img) {
              // this.bwImg = $(this.img.cloneNode());
              // this.bwImg.addClass('sirv-filter-bw');
              [this.img, this.bwImg].forEach(img => {
                if (img) {
                  img.setCss({
                    top: 0,
                    left: 0,
                    width: size.width,
                    height: size.height,
                    position: 'absolute'
                  });
                }
              });
            }
          }

          get size() {
            return this.pn.size;
          }
          /**
           * @param {{ width: numaber; height: numaber; }} size
           */


          set containerSize(size) {
            this.c.setCss({
              width: size.width,
              height: size.height
            });
          }
          /**
           * @param {{ width: numaber; height: numaber; }} size
           */


          set insideContainerSize(size) {
            this.ic.setCss({
              width: size.width,
              height: size.height
            });
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set insideContainerFontSize(size) {
            this.ic.setCssProp('font-size', Math.max(size.width, size.height) + 'px');
          }

          setTransform(x, y) {
            this.ic.setCssProp('transform', 'translate3d(' + x + 'px,' + y + 'px, 0px)');

            if (this.img) {
              this.img.setCssProp('transform', 'translate3d(' + x * -1 + 'px, ' + y * -1 + 'px, 0px)');
            }
          }

          show(img, size) {
            if (img) {
              this.img = $(img);
            }

            this.calcContainerPosition();
            this.imageSize = size;

            if (this.img) {
              this.ic.append(this.img); // this.pn.append(this.bwImg);
            }

            let container = this.pn;

            if (['img', 'canvas'].includes(container.tagName)) {
              container = $(container.node.parentNode);
            }

            container.append(this.c);
          }

          hide() {
            this.c.remove();

            if (this.img) {
              this.img.remove();
              this.img = null;

              if (this.bwImg) {
                this.bwImg.remove();
                this.bwImg = null;
              }
            }
          }

          destroy() {
            this.c.removeEvent('mousedown');
            this.c.remove();
          }

        }
        /* eslint-env es6 */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


        const difference = (a, b) => {
          return Math.abs(a - b);
        };

        const getAnimationValue = (a, b, step) => {
          return (a - b) * step;
        }; // eslint-disable-next-line no-unused-vars


        class Controller {
          constructor(view) {
            this.view = view; // parentSize

            this.pSize = {
              width: 0,
              height: 0
            };
            this.inDoc = false;
            this.timer = null;
            this.isPlaying = false;
            this.pos = {
              x: null,
              y: null
            };
            this.dPos = {
              x: null,
              y: null
            };
            this._size = {
              width: 0,
              height: 0
            };
            this.dSize = {
              width: 0,
              height: 0
            };
          } // private


          doAnimation() {
            let result = false;
            const minSize = 0.001;

            if (difference(this.pos.x, this.dPos.x) > minSize || difference(this.pos.y, this.dPos.y) > minSize || difference(this._size.width, this.dSize.width) > minSize || difference(this._size.height, this.dSize.height) > minSize) {
              result = true;
            }

            return result;
          } // private


          animate() {
            this.isPlaying = true;
            const step = 0.4;
            const dx = getAnimationValue(this.pos.x, this.dPos.x, step);
            const dy = getAnimationValue(this.pos.y, this.dPos.y, step);
            const dw = getAnimationValue(this._size.width, this.dSize.width, step);
            const dh = getAnimationValue(this._size.height, this.dSize.height, step);
            this.dPos.x += dx;
            this.dPos.y += dy;
            this.dSize.width += dw;
            this.dSize.height += dh;
            this.setCss();

            if (this.doAnimation()) {
              this.timer = setTimeout(() => {
                this.animate();
              }, 16);
            } else {
              this.stopAnimation();
            }
          } // private


          setCss() {
            const s = this._size;
            const ds = this.dSize;

            if (difference(s.width, ds.width) > 0 || difference(s.height, ds.height) > 0) {
              this.view.insideContainerSize = ds;
              this.view.insideContainerFontSize = this.pSize;
            }

            this.view.setTransform(Math.round(this.dPos.x), Math.round(this.dPos.y));
          } // private


          stopAnimation() {
            if (this.isPlaying) {
              this.isPlaying = false;
              clearTimeout(this.timer);
              this.dPos.x = this.pos.x;
              this.dPos.y = this.pos.y;
              this.dSize.width = this._size.width;
              this.dSize.height = this._size.height;
              this.setCss();
            }
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set size(size) {
            this._size.width = size.width;
            this._size.height = size.height;

            if (this.inDoc && this.dPos.x !== null) {
              if (!this.isPlaying) {
                this.animate();
              }
            }
          }
          /**
           * @param {{ x: number; y: number; }} pos
           */


          set position(pos) {
            const s = this._size;
            const ps = this.pSize;

            let _x = pos.x - s.width / 2;

            let _y = pos.y - s.height / 2;

            if (_x < 0) {
              _x = 0;
            }

            if (_y < 0) {
              _y = 0;
            }

            if (_x > ps.width - s.width) {
              _x = ps.width - s.width;
            }

            if (_y > ps.height - s.height) {
              _y = ps.height - s.height;
            }

            this.pos.x = _x;
            this.pos.y = _y;

            if (this.dPos.x === null) {
              this.dPos.x = _x;
              this.dPos.y = _y;
            }

            if (this.inDoc) {
              if (!this.isPlaying) {
                this.animate();
              }
            }
          } // private


          setSizes() {
            const ps = this.view.size;
            this.pSize = ps;
            this.view.containerSize = ps;
            this.view.insideContainerFontSize = ps;
          }

          show(img) {
            if (!this.inDoc) {
              this.inDoc = true;
              this.setSizes();
              this.view.show(img, this.pSize);
            }
          }

          hide() {
            if (this.inDoc) {
              this.inDoc = false;
              this.view.hide();
              this.pos = {
                x: null,
                y: null
              };
              this.dPos = {
                x: null,
                y: null
              };
              this._size = {
                width: 0,
                height: 0
              };
              this.dSize = {
                width: 0,
                height: 0
              };
            }
          }

          resize() {
            if (this.inDoc) {
              this.setSizes();
              this.view.calcContainerPosition();
            }
          }

          destroy() {
            this.stopAnimation();
            this.inDoc = false;
          }

        }
        /* eslint-env es6 */

        /* global View */

        /* global Controller */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars


        class _Eye {
          constructor(prentNode, hover) {
            this.view = new View(prentNode, hover);
            this.controller = new Controller(this.view);
          }

          addEventToMainContainer(name, callback) {
            this.view.container.addEvent(name, callback);
          }

          removeEventToMainContainer(name, callback) {
            if (callback) {
              this.view.container.removeEvent(name, callback);
            } else {
              this.view.container.removeEvent(name);
            }
          }

          clearEvents() {
            this.view.container.clearEvents();
          }

          get boundaries() {
            return this.view.container.node.getBoundingClientRect();
          }

          show(img) {
            this.controller.show(img);
          }

          hide() {
            this.controller.hide();
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set size(size) {
            this.controller.size = size;
          }
          /**
           * @param {{ x: number; y: number; }} pos
           */


          set position(pos) {
            this.controller.position = pos;
          }

          destroy() {
            this.controller.destroy();
            this.view.destroy();
          }

        }

        return _Eye;
      })();

      const ZoomMap = (() => {
        /* eslint-env es6 */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars
        class View {
          constructor(parent) {
            this.p = $(parent);
            const className = 'sirv-zoom-map'; // container

            this.c = $J.$new('div');
            this.c.addClass(className);
            this.lens = $J.$new('div');
            this.lens.addClass(className + '-lens');
            this._img = null;
            this.b = $($J.D.node.body);
            this.c.append(this.lens);
          }

          calcRightPosition(x, y) {
            const rect = this.c.rect;
            return {
              x: x - rect.left,
              y: y - rect.top
            };
          }

          addDomEventToDocBody(eventName, callback) {
            this.b.addEvent(eventName, callback);
          }

          removeDomEventToDocBody(eventName, callback) {
            this.b.removeEvent(eventName, callback);
          }

          addDomEventToLens(eventName, callback) {
            this.lens.addEvent(eventName, callback);
          }

          addDomEvent(eventName, callback) {
            this.c.addEvent(eventName, callback);
          }
          /**
           * @param {string} value
           */


          set cursor(value) {
            this.c.setCssProp('cursor', value);
          }

          removeEvents() {
            this.c.removeEvent(['btnclick', 'tap']);
            this.c.removeEvent(['mousedown', 'touchstart']);
            this.lens.removeEvent(['mousedown', 'touchstart']);
            this.c.removeEvent(['mousemove', 'touchmove']);
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set size(size) {
            this.c.setCss({
              width: size.width + 'px',
              height: size.height + 'px'
            });
          }

          addLensCss(lensPosition, lensSize, containerSize) {
            this.lens.setCss({
              top: lensPosition.top - 1 + 'px',
              left: lensPosition.left - 1 + 'px',
              width: lensSize.width + 'px',
              height: lensSize.height + 'px',
              'font-size': containerSize + 'px'
            });
          }
          /**
           * @param {{ src: string; srcset: string|undefined; }} img
           */


          set img(img) {
            this._img = $J.$new('img', {
              'src': img.src
            });

            if (img.srcset) {
              this._img.attr('srcset', img.srcset + ' 2x');
            }

            this.c.append(this._img);
          } // private


          removeEventTransitionEvent() {
            this.c.removeEvent('transitionend');
          }

          show(callback) {
            this.c.setCss({
              opacity: 0,
              transition: 'opacity .3s linear'
            });
            this.p.append(this.c);
            this.c.render();
            this.removeEventTransitionEvent();
            this.c.addEvent('transitionend', e => {
              e.stop();
              this.removeEventTransitionEvent();
              this.c.setCssProp('transition', '');
              this.addDomEvent(['mousedown', 'touchstart'], _e => {
                _e.stop();
              });
              callback();
            });
            this.c.setCssProp('opacity', 1);
          }

          hide(force, callback) {
            this.removeEventTransitionEvent();

            if (!force) {
              this.c.addEvent('transitionend', e => {
                e.stop();

                this._removeEventTransitionEvent();

                this.c.setCssProp('transition', '');
                this.c.remove();
                this.removeEvents();
                callback();
              });
            } else {
              this.c.remove();
              this.removeEvents();
              callback();
            }

            this.c.setCssProp('opacity', 0);
          }

          destroy() {
            this.c = null;
            this.lens = null;
          }

        }
        /* eslint-env es6 */

        /* global getPercent */

        /* global EventEmitter */

        /* global helper */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


        const getOffset = e => {
          let rect;
          const result = {
            x: 0,
            y: 0
          };
          const oe = e.originEvent;

          if ($J.defined(oe.offsetX)) {
            result.x = oe.offsetX;
            result.y = oe.offsetY;
          } else {
            // rect = e.target.getBoundingClientRect();
            rect = $(e.target).position;
            result.x = oe.targetTouches[0].pageX - rect.left;
            result.y = oe.targetTouches[0].pageY - rect.top;
          }

          return result;
        };

        const betweenMinMax = (value, min, max) => {
          if (!$J.defined(min)) {
            min = 0;
          }

          if (!$J.defined(max)) {
            max = 100;
          }

          return Math.min(Math.max(value, min), max);
        }; // eslint-disable-next-line no-unused-vars


        class Controller extends EventEmitter {
          constructor(view, options) {
            super();
            this.view = view;
            this.o = options;
            this.state = globalVariables.APPEARANCE.HIDDEN;
            this.scale = {
              x: 1,
              y: 1
            };
            this.viewPortSize = {
              width: 0,
              height: 0
            }; // bigImageSize

            this.bISize = {
              width: 0,
              height: 0
            }; // currentBigImageSize

            this.cBISize = {
              width: 0,
              height: 0
            }; // currentBigImagePosition

            this.cBIPosition = {
              top: 0,
              left: 0
            }; // currentMapContainerSize

            this.mapSize = {
              width: 0,
              height: 0
            }; // lensSize

            this.ls = {
              width: 0,
              height: 0
            }; // lensPosition

            this.lp = {
              top: 0,
              left: 0
            }; // correctLensPosition

            this.clp = {
              x: 0,
              y: 0
            };
            this.isDragMoved = false;
          } // convert current percent to the center percent of map eye


          static setInTheCenter(value) {
            if (value < 50) {
              value = Math.max(value - (50 - value), 0);
            } else if (value > 50) {
              value = Math.min(value + (value - 50), 100);
            }

            return value;
          } // private


          getPercentPosition(x, y) {
            const cms = this.mapSize;
            const pos = this.view.calcRightPosition(x, y);
            x = betweenMinMax(helper.round(getPercent(pos.x, cms.width), 1));
            y = betweenMinMax(helper.round(getPercent(pos.y, cms.height), 1));
            return {
              x: x,
              y: y
            };
          } // private


          isInside(x, y) {
            let result = false;
            const lp = this.lp;
            const ls = this.ls;
            const pos = this.view.calcRightPosition(x, y);

            if (lp.left < pos.x && lp.left + ls.width > pos.x && lp.top < pos.y && lp.top + ls.height > pos.y) {
              result = true;
            }

            return result;
          } // private


          addEvents() {
            let count = 1;
            let isDragMoved = false;

            this.dragEndHandler = e => {
              if (isDragMoved) {
                e.stop();
                isDragMoved = false;
                this.clp = {
                  x: 0,
                  y: 0
                };
                this.view.cursor = '';
                this.view.removeDomEventToDocBody(e.type, this.dragEndHandler);
                this.view.removeDomEventToDocBody('mouseout', this.mouseOutHandler);
              }
            };

            this.mouseOutHandler = event => {
              event.stop();

              if ((!event.oe.relatedTarget || event.oe.relatedTarget.tagName === 'HTML') && isDragMoved) {
                this.dragEndHandler(event);
                this.view.removeDomEventToDocBody(['mouseup', 'touchend'], this.dragEndHandler);
              }
            };

            this.view.addDomEvent(['btnclick', 'tap'], e => {
              e.stop(); // this.emit('zoomMapNewPosition', { data: this.getPercentPosition(e.x - this.ls.width / 2, e.y - this.ls.height / 2) });

              this.emit('zoomMapNewPosition', {
                data: this.getPercentPosition(e.x, e.y)
              });
            });
            this.view.addDomEventToLens(['mousedown', 'touchstart'], e => {
              const pageXY = e.pageXY;

              if (this.isInside(pageXY.x, pageXY.y)) {
                e.stop();
                count = 1;
                const offset = getOffset(e);
                this.clp.y = offset.y;
                this.clp.x = offset.x;
                isDragMoved = true;
                this.view.addDomEventToDocBody(['mouseup', 'touchend'], this.dragEndHandler);
                this.view.addDomEventToDocBody('mouseout', this.mouseOutHandler);
              }
            });
            this.view.addDomEvent(['mousemove', 'touchmove'], e => {
              if (isDragMoved) {
                if (count <= 0) {
                  e.stop();
                  const pageXY = e.pageXY;
                  this.view.cursor = 'move'; // this.emit('zoomMapNewPosition', { data: this.getPercentPosition(pageXY.x - this.clp.x, pageXY.y - this.clp.y) });

                  this.emit('zoomMapNewPosition', {
                    data: this.getPercentPosition(pageXY.x, pageXY.y)
                  });
                }

                count--;
              }
            });
          } // private


          calcMap(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight) {
            let cWidth = this.o.maxwidth;
            let cHeight = this.o.maxheight;

            if (zoomContainerWidth <= cWidth) {
              cWidth = zoomContainerWidth / 2;
              cHeight = cWidth * (imgHeight / imgWidth);
            }

            if (zoomContainerHeight <= cHeight) {
              cHeight = zoomContainerHeight / 2;
              cWidth = cHeight * (imgWidth / imgHeight);
            }

            if (cWidth / cHeight > imgWidth / imgHeight) {
              cWidth = cHeight * (imgWidth / imgHeight);
            } else {
              cHeight = cWidth * (imgHeight / imgWidth);
            }

            cWidth = parseInt(cWidth, 10);
            cHeight = parseInt(cHeight, 10);
            this.mapSize.width = cWidth;
            this.mapSize.height = cHeight;
            this.viewPortSize.width = zoomContainerWidth;
            this.viewPortSize.height = zoomContainerHeight;
            this.bISize.width = imgWidth;
            this.bISize.height = imgHeight;
          }

          prepare(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight) {
            this.calcMap(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight);
            this.view.size = this.mapSize;
            this.emit('zoomGetImage', {
              data: {
                width: this.mapSize.width,
                height: this.mapSize.height
              }
            });
          }
          /**
           * @param {{ top: number; left: number; }} pos
           */


          set lensPosition(bigImagePos) {
            const bis = this.cBISize;
            const ms = this.mapSize;
            let top = ms.height / bis.height * bigImagePos.top;
            let left = ms.width / bis.width * bigImagePos.left;
            this.cBIPosition.top = bigImagePos.top;
            this.cBIPosition.left = bigImagePos.left;

            if (top < 0) {
              top = 0;
            }

            if (left < 0) {
              left = 0;
            }

            const ls = this.ls;

            if (top + ls.height > ms.height) {
              top = ms.height - ls.height;
            }

            if (left + ls.width > ms.width) {
              left = ms.width - ls.width;
            }

            this.lp.top = top;
            this.lp.left = left;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set lensSize(size) {
            this.cBISize.width = size.width;
            this.cBISize.height = size.height;
            const cm = this.mapSize;
            const vp = this.viewPortSize;
            this.ls.width = vp.width >= size.width ? cm.width : vp.width / size.width * cm.width;
            this.ls.height = vp.height >= size.height ? cm.height : vp.height / size.height * cm.height;
          }

          move(imgPos, scale) {
            const bis = this.bISize;
            const imgWidth = bis.width * scale.x;
            const imgHeight = bis.height * scale.y;
            const imgTop = Math.abs(imgPos.y + (bis.height - imgHeight) / 2);
            const imgLeft = Math.abs(imgPos.x + (bis.width - imgWidth) / 2);
            this.scale.x = scale.x;
            this.scale.y = scale.y;
            this.lensSize = {
              width: imgWidth,
              height: imgHeight
            };
            this.lensPosition = {
              top: imgTop,
              left: imgLeft
            };
            this.view.addLensCss(this.lp, this.ls, Math.max(this.mapSize.width, this.mapSize.height));
          }

          show() {
            if ([globalVariables.APPEARANCE.SHOWING, globalVariables.APPEARANCE.SHOWN].includes(this.state)) {
              return;
            }

            this.state = globalVariables.APPEARANCE.SHOWING;
            this.view.show(() => {
              this.addEvents();
              this.state = globalVariables.APPEARANCE.SHOWN;
            });
          }

          hide(force) {
            if ([globalVariables.APPEARANCE.HIDDEN, globalVariables.APPEARANCE.HIDING].includes(this.state) && !force) {
              return;
            }

            this.state = globalVariables.APPEARANCE.HIDING;
            this.view.hide(force, () => {
              this.view.removeDomEventToDocBody(['mouseup', 'touchend'], this.dragEndHandler);
              this.state = globalVariables.APPEARANCE.HIDDEN;
            });
          }

          resize(maxWidth, maxHeight, imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight) {
            this.o.maxwidth = maxWidth;
            this.o.maxheight = maxHeight;
            this.calcMap(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight);
            this.view.size = this.mapSize;
          }

          destroy() {
            this.hide(true);
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* global EventEmitter */

        /* global View */

        /* global Controller */

        /* eslint-disable indent */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
        // eslint-disable-next-line no-unused-vars


        class _ZoomMap extends EventEmitter {
          constructor(parent, options) {
            super();
            this.options = Object.assign({
              maxwidth: 200,
              maxheight: 200
            }, options || {});
            this.view = new View(parent);
            this.controller = new Controller(this.view, this.options);
            this.controller.parentClass = this;
          }

          prepare(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight) {
            this.controller.prepare(imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight);
          }

          move(imgPos, scale) {
            this.controller.move(imgPos, scale);
          }
          /**
           * @param {{ src: string; srcset: string; }} img
           */


          set img(img) {
            this.view.img = img;
          }

          show() {
            this.controller.show();
          }

          hide(force) {
            this.controller.hide(force);
          }

          resize(maxWidth, maxHeight, imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight) {
            this.controller.resize(maxWidth, maxHeight, imgWidth, imgHeight, zoomContainerWidth, zoomContainerHeight);
          }

          destroy() {
            this.controller.destroy();
            this.view.destroy();
            super.destroy();
          }

        }

        return _ZoomMap;
      })();
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


      const findZoomNode = el => {
        return $($(el).node.getElementsByTagName('img')[0] || $(el).node.getElementsByTagName('canvas')[0] || el);
      }; // eslint-disable-next-line no-unused-vars


      class View {
        constructor(parentNode) {
          this.pn = $(parentNode);
          const className = 'sirv-zoom'; // eventsCanvasNode

          this.cnv = $J.$new('div');
          this.cnv.addClass(className);
          this.node = $J.$new('div').setCss({
            opacity: 0
          });
          this.node.addClass(className + '-wrapper');
          this.zoomWrapper = $J.$new('div').addClass('sirv-zoom-image-wrapper'); // zoomNode

          this.zoom = findZoomNode(this.pn); // lensContainer

          this.lens = $J.D.node.body;
          this.isBody = true;
          this.image = null;
          this.perspective = '';

          if ($J.browser.mobile && $J.browser.platform === 'ios') {
            // perspective much helps for ios
            this.perspective = 'perspective(1000px) ';
          }
        }

        get hash() {
          if (this.image) {
            return this.image.$J_UUID + '' || this.image.attr('src');
          }

          return null;
        }

        get parentSize() {
          return this.pn.size;
        }

        get parentPostion() {
          return this.pn.position; // Inaccurate position for mobile
        }

        get zoomSize() {
          return this.zoom.size;
        }

        get parentBoundaries() {
          if (this.cnv.node.parentNode) {
            return this.cnv.node.getBoundingClientRect();
          }

          return null;
        } // eslint-disable-next-line class-methods-use-this


        addScrollEvent(callback) {
          $J.W.addEvent('scroll', callback);
        } // eslint-disable-next-line class-methods-use-this


        removeScrollEvent(callback) {
          if (callback) {
            $J.W.removeEvent('scroll', callback);
          } else {
            $J.W.removeEvent('scroll');
          }
        }

        addClassToWrapper(zoomType) {
          this.node.addClass('sirv-' + zoomType + '-zoom');
        }

        addEventToMainContainer(name, callback) {
          this.cnv.addEvent(name, callback);
        }

        removeEventFromMainContainer(...args) {
          this.cnv.removeEvent(args);
        }

        addEventToWrapper(name, callback) {
          this.node.addEvent(name, callback);
        }

        removeEventFromWrapper(...args) {
          this.node.removeEvent(args);
        }

        addMouseoutEvent(callback) {
          this.addEventToWrapper('mouseout', e => {
            // let toElement = e.toElement || e.relatedTarget;
            let toElement = e.related;

            if (!toElement) {
              return;
            }

            while (toElement && toElement !== this.node.node && toElement !== this.lens.node) {
              // while (toElement !== this.node && toElement !== $J.D.node.body) {
              toElement = toElement.parentNode;
            }

            if (this.node.node !== toElement) {
              callback(e);
            }
          });
        }
        /**
         * @param {nodeElement} lensContainer
         */


        set lensContainer(lensContainer) {
          if (!lensContainer) {
            lensContainer = $($J.D.node.body);
          }

          this.isBody = $(lensContainer) === $($J.D.node.body);
          this.lens = $(lensContainer);
        }

        toggleCursorClass(oldClass, newClass) {
          this.cnv.removeClass(oldClass).addClass(newClass);
        }

        setImagePosition(position, scale) {
          if (this.image) {
            this.zoomWrapper.setCssProp('transform', this.perspective + 'translate3d(' + position.x + 'px, ' + position.y + 'px, 0) scale(' + scale.x + ', ' + scale.y + ')');
          }
        }

        addStartCss() {
          this.lensStyle = {
            opacity: 0,
            transform: 'scale(0)'
          };
        }

        appendNodes(smallImg, imageSize) {
          this.cnv.addEvent('contextmenu', e => {
            e.stopDefaults();
          });
          this.image = $(smallImg);
          this.image.setCss({
            width: imageSize.width + 'px',
            height: imageSize.height + 'px'
          });
          /*
              if tiels === false
              image sticks to mouse cursor
              just for firefox
          */

          if (!$J.browser.mobile) {
            this.image.addEvent('mousedown', e => {
              e.stopDefaults();
            });
          }

          this.zoomWrapper.append(this.image);
          this.node.append(this.zoomWrapper);
          this.node.appendTo(this.cnv);
          this.cnv.appendTo(this.lens, false);
        }
        /**
         * @param {{ position: { top: number; left: number; }; size: { width: number; height: number; }; }} css
         */


        set eventNodePositionSize(css) {
          let top = css.position.top;
          let left = css.position.left;

          if (!this.isBody) {
            const parentContainer = this.lens.position;
            top -= parentContainer.top;
            left -= parentContainer.left;
          }

          this.cnv.setCss({
            top: top,
            left: left,
            width: css.size.width,
            height: css.size.height
          });
        }
        /**
         * @param {{any}} styleObj
         */


        set lensStyle(styleObj) {
          this.node.setCss(styleObj);
        }
        /**
         * @param {{ top: number; left: number; }} position
         */


        set lensPosition(position) {
          this.lensStyle = {
            top: position.top,
            left: position.left
          };
        }
        /**
         * @param {{ width: number; height: number; }} size
         */


        set lensSize(size) {
          this.lensStyle = {
            width: size.width,
            height: size.height
          };
        }

        setLensCss(position, size, transition) {
          this.lensPosition = position;
          this.lensSize = size;
          this.lensStyle = {
            opacity: 1,
            transform: 'scale(1)',
            // top: position.top,
            // left: position.left,
            // width: size.width,
            // height: size.height,
            transition: transition || 'none'
          };
        }

        setImageSize(position, size, scale) {
          this.zoomWrapper.setCss({
            'top': 0,
            'left': 0,
            'width': size.width + 'px',
            'height': size.height + 'px',
            'transform-origin': '50% 50%',
            'transform': this.perspective + 'translate3d(' + position.x + 'px, ' + position.y + 'px, 0) scale(' + scale.x + ', ' + scale.y + ')'
          });
          this.zoomWrapper.render();
          this.image.setCss({
            width: '100%',
            height: '100%'
          });
          this.image.render();
        }

        clearCss() {
          this.node.setCss({
            transition: '',
            opacity: '',
            transform: ''
          });
          this.node.removeAttr('style');

          if (this.image) {
            this.image.setCss({
              width: '',
              height: ''
            });
          }

          this.zoomWrapper.setCss({
            top: '',
            left: '',
            width: '',
            height: '',
            transition: '',
            transform: ''
          });
        }

        clearDOM() {
          if (this.image) {
            this.image.remove();
            this.image = null;
          }

          this.zoomWrapper.remove();
          this.node.remove();
          this.cnv.remove();
        }

        removeEvents() {
          this.cnv.clearEvents(); // this.cnv.removeEvent('mouseover');

          if (this.image) {
            this.image.clearEvents();
          }

          this.node.clearEvents(); // this.node.removeEvent('mouseout');
          // this.node.removeEvent('mousemove');
          // this.node.removeEvent('btnclick');
          // this.node.removeEvent('mousescroll');
          // this.node.removeEvent('transitionend');
          // this.node.removeEvent('mousedrag');
          // this.node.removeEvent('touchdrag');
        }

        get boundaries() {
          return this.cnv.node.getBoundingClientRect();
        }

        destroy() {
          if (this.image) {
            this.image.remove();
            this.image = null;
          }

          this.zoomWrapper.remove();
          this.node.remove();
          this.cnv.remove();
        }

      }
      /* eslint-env es6 */

      /* global View */
      // eslint-disable-next-line no-unused-vars


      class InnerView extends View {
        constructor(parentNode) {
          super(parentNode);
          this.mouseMoveHandler = null;
        }

        getContainerForMap() {
          return this.node;
        }

        addStartCss() {
          // TODO review it
          super.addStartCss();
          this.node.addEvent('mousescroll', e => {
            e.stop();
          });
          this.lensStyle = {
            opacity: 0,
            transform: 'scale(1)'
          };
        }

        removeDragstart() {
          this.node.del('event:mousedrag:dragstart'); // fix mousedrag when the lens is opening second time
        }

        addEventsCanvasClass(className) {
          this.cnv.addClass(className);
        }

        removeEventsCanvasClass(className) {
          this.cnv.removeClass(className);
        }

        getContainerSize() {
          return this.node.size;
        }

        getContainerPosition() {
          return this.node.position;
        }

        addGlobalEvent(callback) {
          if (!this.mouseMoveHandler) {
            this.mouseMoveHandler = callback;
            $J.D.addEvent('mousemove', callback);
          }
        }

        removeGlobalEvent() {
          if (this.mouseMoveHandler) {
            $J.D.removeEvent('mousemove', this.mouseMoveHandler);
            this.mouseMoveHandler = null;
          }
        }

        removeEvents() {
          super.removeEvents();
          this.removeGlobalEvent();
        }

      }
      /* eslint-env es6 */

      /* global View */
      // eslint-disable-next-line no-unused-vars


      class MagnifierView extends View {
        get parentSize() {
          return this.zoom.size;
        }

        get parentPostion() {
          return this.zoom.position; // Inaccurate position for mobiles
        }

      }
      /* eslint-env es6 */

      /* global View */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      class OutsideView extends View {
        getImageForEye() {
          return this.image.node.cloneNode();
        }

        getNodeForEye() {
          return this.zoom;
        }
        /**
         * @param {{ top: number; left: number; }} position
         */


        set lensPosition(position) {
          this.cnv.setCss({
            top: position.top,
            left: position.left
          });
        }

        setCanvasNodeSize(size) {
          this.cnv.setCss({
            width: size.width,
            height: size.height
          });
        }

        addStartCss(value) {
          this.lensStyle = {
            opacity: 0,
            transform: 'translate3d(' + value.start.x + '%, ' + value.start.y + '%, 0px)'
          };
        }

        get parentSize() {
          return this.zoom.size;
        }

        get parentPostion() {
          return this.zoom.position; // Inaccurate position for mobiles
        }

        setLensCss(position, size, transition) {
          this.cnv.setCss({
            top: position.top,
            left: position.left
          }); // super.setLensCss({ top: 0, left: 0 }, size, transition);

          super.setLensCss(position, size, transition);
        } // eslint-disable-next-line class-methods-use-this


        addMouseMoveEvent(callback) {
          $J.W.addEvent('mousemove', callback);
        } // eslint-disable-next-line class-methods-use-this


        removeMouseMoveEvent(callback) {
          $J.W.removeEvent('mousemove', callback);
        }

        clearCss() {
          this.cnv.removeAttr('style');
        }

      }
      /* eslint-env es6 */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      const AnimationLoop = (() => {
        const STATES = {
          STOPPED: 0,
          STARTED: 1
        };

        class _Animation {
          constructor(callback, stopCallback) {
            this.state = STATES.STOPPED;
            this.id = null;

            this.cb = callback || (() => {});

            this.stopCb = stopCallback || (() => {});
          }

          start() {
            if (this.state !== STATES.STARTED) {
              this.state = STATES.STARTED;

              const step = lastTime => {
                this.cb(lastTime);

                if (this.state !== STATES.STOPPED) {
                  this.id = requestAnimationFrame(step);
                }
              };

              this.id = requestAnimationFrame(step);
            }
          }

          stop() {
            if (this.state !== STATES.STOPPED) {
              this.state = STATES.STOPPED;
              cancelAnimationFrame(this.id);
              this.stopCb();
            }
          }

        }

        return _Animation;
      })();
      /* eslint-env es6 */

      /* global EventEmitter */

      /* global ZoomHelper */

      /* global helper */

      /* global AnimationLoop */

      /* global getDifference */

      /* global getPercentValue */

      /* global checkRange */

      /* global CURSOR_STATES */

      /* global getPercent */

      /* global DeepZoom */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


      let zoomHelper = null; // TODO tmp
      // eslint-disable-next-line no-unused-vars

      class Controller extends EventEmitter {
        constructor(view, o) {
          super();
          this.o = Object.assign({
            test: false,
            pan: false,
            // drag zoom
            smoothing: true,
            tiles: true,
            customZooming: true,
            clickBehavior: 'both',
            // both, up
            upscale: false,
            // upscale last level image when we have retina display
            trigger: 'hover' // hover, click, dblclick

          }, o);
          this.view = view;
          this.state = globalVariables.APPEARANCE.HIDDEN;
          this._x = 0;
          this._y = 0;
          this.baseScale = {
            x: 1,
            y: 1
          };
          this.scale = {
            x: 1,
            y: 1
          };
          this.dScale = {
            x: 1,
            y: 1
          }; // imageSize

          this.iSize = {
            width: 0,
            height: 0
          }; // imagePosition

          this.iPos = {
            x: 0,
            y: 0
          }; // imageDPosition

          this.iDPos = {
            x: 0,
            y: 0
          }; // parentPosition

          this.pPos = {
            top: 0,
            left: 0
          }; // parentSize

          this.pSize = {
            width: 0,
            height: 0
          };
          this.anim = null;
          this.animCb = null;
          this.animStep = 0;
          this.lastAnimTimer = 0;
          this.deepZoom = null;
          this.deepZoomTimer = null;
          this.lensSize = {
            width: 0,
            height: 0
          };
          this.lensHalfSize = {
            width: 0,
            height: 0
          };
          this.lensPosition = {
            top: 0,
            left: 0
          };
          this.currentLensSize = {
            width: 100,
            height: 100
          };
          this.dppx = 1; // just for image, not tiles

          this.zoomNodeSize = {
            width: 0,
            height: 0
          };
          this.boundaries = null;
          this.ANIM_STEP = 0.1;
          this.nonDeepZoomImageLevels = [];

          this.scrollHandler = () => {
            if ([globalVariables.APPEARANCE.SHOWING, globalVariables.APPEARANCE.SHOWN].includes(this.state)) {
              this.hide(this.state === globalVariables.APPEARANCE.SHOWING);
            }
          };
        }

        init() {
          this.getAllSizes();
          this.view.setLensCss(this.lensPosition, this.lensSize);
          this.createDeepZoom();
          this.createAnimation(this.ANIM_STEP);
          this.view.addScrollEvent(this.scrollHandler);
        } // private


        createDeepZoom() {
          this.deepZoom = new DeepZoom(this.view.node, {
            tiles: this.o.tiles,
            inner: ['inner', 'outside'].includes(this.o.type),
            upscale: this.o.upscale // minSize: this.pSize

          });
          this.deepZoom.parentClass = this;
          this.on('getTile', e => {
            e.stopAll();
            this.emit('zoomGetImage', {
              data: e.data
            });
          });
          this.on('zoomCancelLoadingOfTiles', e => {
            e.stopEmptyEvent();
          });
        }
        /**
         * @param {nodeElement} lensContainer
         */


        set lensContainer(lensContainer) {
          this.view.lensContainer = lensContainer;
        } // private


        getBoundaries() {
          this.boundaries = this.view.parentBoundaries;
        } // private


        getAllSizes() {
          this.pSize = this.view.parentSize;
          this.pPos = this.view.parentPostion;
          this.zoomNodeSize = this.view.zoomSize;
          this.getBoundaries();
        }

        get shown() {
          return this.state === globalVariables.APPEARANCE.SHOWN;
        }

        get showing() {
          return this.state === globalVariables.APPEARANCE.SHOWING;
        } // private


        deepZoomAction(equals, newSize) {
          clearTimeout(this.deepZoomTimer);
          this.deepZoomTimer = setTimeout(() => {
            this.deepZoom.loadImages();

            if (newSize) {
              this.deepZoom.lensSize = newSize;
              this.deepZoom.resize();
            }

            this.deepZoom.action(this.iDPos, this.dScale);

            if (!equals) {
              this.deepZoomAction(this.dScale.x === this.scale.x);
            }
          }, this.lastAnimTimer + 10); // must be more than fps (1000 / 60 = 16)

          if (newSize) {
            this.deepZoom.lensSize = newSize;
            this.deepZoom.resize();
          }

          this.deepZoom.action(this.iDPos, this.dScale);
        } // private


        stopMovingAndZooming() {
          this.scale.x = this.dScale.x;
          this.scale.y = this.dScale.y;
          this.iPos.x = this.iDPos.x;
          this.iPos.y = this.iDPos.y;
        } // private


        createAnimation(step) {
          const checkScale = sett => {
            let result = false;

            if (this.dScale[sett] < this.baseScale[sett]) {
              result = true;
              this.dScale[sett] = this.baseScale[sett];
            }

            if (this.dScale[sett] > 1) {
              result = true;
              this.dScale[sett] = 1;
            }

            return result;
          };

          this.animStep = step;
          let last = 0;
          this.anim = new AnimationLoop(lastTime => {
            if (!last) {
              last = lastTime;
              return;
            }

            let dx;
            let dy;
            let diffX;
            let diffY;
            let isChanged = false;
            this.lastAnimTimer = lastTime - last;
            last = lastTime;
            let xScaleWasClosed = false;
            let yScaleWasClosed = false;

            if (this.scale.x !== this.dScale.x) {
              isChanged = true;
              this.sendZoomingAction(); // this.setCursorState();

              diffX = this.scale.x - this.dScale.x; // diffY = this.scale.y - this.dScale.y;

              dx = diffX * this.animStep; // dy = diffY * this.animStep;

              this.dScale.x += dx;
              this.dScale.y += dx; // this.dScale.y += dy;

              xScaleWasClosed = checkScale('x');
              yScaleWasClosed = xScaleWasClosed; // yScaleWasClosed = checkScale('y');
              // if (Math.abs(diffX) < 0.0001 || Math.abs(diffY) < 0.0001) {

              if (Math.abs(diffX) < 0.0001) {
                this.dScale.x = this.scale.x; // this.dScale.y = this.scale.y;

                this.dScale.y = this.scale.x;
              }
            }

            if (this.iPos.x !== this.iDPos.x || this.iPos.y !== this.iDPos.y) {
              isChanged = true;
              diffX = this.iPos.x - this.iDPos.x;
              diffY = this.iPos.y - this.iDPos.y;
              dx = diffX * this.animStep;
              dy = diffY * this.animStep;
              this.iDPos.x += dx;
              this.iDPos.y += dy;
              this.iDPos.x = helper.round(this.iDPos.x, 4);
              this.iDPos.y = helper.round(this.iDPos.y, 4);

              if (Math.max(Math.abs(diffX), Math.abs(diffY)) < 1 || xScaleWasClosed || yScaleWasClosed) {
                this.iDPos.x = this.iPos.x;
                this.iDPos.y = this.iPos.y;
              }
            }

            if (isChanged) {
              this.render(this.iDPos, this.dScale);
            } else if (this.animCb) {
              this.animCb();
              this.animStep = step;
              this.animCb = null;
            }
          }, () => {
            last = 0;
          });
        }

        render(position, scale) {
          this.deepZoomAction();
          this.view.setImagePosition(position || this.iDPos, scale || this.dScale);
        } // private


        correctX(value) {
          return value - this.pPos.left;
        } // private


        correctY(value) {
          return value - this.pPos.top;
        } // private

        /**
         * @param {number} x
         */


        set x(x) {
          this._x = this.correctX(x);
        } // private

        /**
         * @param {number} y
         */


        set y(y) {
          this._y = this.correctY(y);
        }

        getZoomData(scale) {
          let result = 0;

          if (!scale) {
            scale = this.scale.x;
          }

          if (this.shown || this.showing) {
            result = helper.round((scale - this.baseScale.x) / (1 - this.baseScale.x), 2);
          }

          return result;
        }

        get nextMinZoom() {
          let result = this.deepZoom.getScale('zoomout');

          if (result < this.baseScale.x) {
            result = this.baseScale.x;
          }

          return this.getZoomData(result);
        }

        get nextMaxZoom() {
          let result = this.deepZoom.getScale('zoomin');

          if (result > 1) {
            result = 1;
          }

          return this.getZoomData(result);
        } // private


        zoom(direction, x, y) {
          const last = this.scale.x;
          const is = this.iSize;
          const cw = is.width * this.scale.x;
          const ch = is.height * this.scale.y;
          const dw = getDifference(is.width, cw);
          const dh = getDifference(is.height, ch);
          x = x || this.pPos.left + this.lensHalfSize.width;
          y = y || this.pPos.top + this.lensHalfSize.height;
          this.basePercentOfScale = {
            x: getPercent(Math.abs(this.iPos.x) + this.correctX(x) - dw, cw),
            y: getPercent(Math.abs(this.iPos.y) + this.correctY(y) - dh, ch)
          };
          const scale = this.deepZoom.getScale(direction);
          this.scale.x = scale;
          this.scale.y = scale;
          this.x = x;
          this.y = y;
          this.afterZoom(last);
        }

        afterZoom(lastScale) {
          if (lastScale !== this.scale.x) {
            this.sendZoomingAction();
            this.setCursorState();

            if (this.o.smoothing) {
              this.animStep = 0.25;
            } else {
              this.dScale.x = this.scale.x;
              this.dScale.y = this.scale.y;
              this.iDPos.x = this.iPos.x;
              this.iDPos.y = this.iPos.y;
              this.render(this.iPos, this.scale);
            }
          }
        } // public


        zoomUp(x, y) {
          if ((this.shown || this.showing) && this.scale.x !== 1) {
            this.zoom('zoomin', x, y);
            return true;
          }

          return false;
        } // public


        zoomDown(x, y) {
          if ((this.shown || this.showing) && this.scale.x !== this.baseScale.x) {
            this.zoom('zoomout', x, y);
            return true;
          }

          return false;
        } // private


        sendZoomingAction() {
          clearTimeout(this.zoomingTimer);
          this.zoomingTimer = setTimeout($(from => {
            this.emit('zooming', {
              data: {
                zoom: this.getZoomData(),
                // from 0 to 1
                from: from,
                to: this.scale.x
              }
            });
          }).bind(this, this.dScale.x), 24);
        } // private


        setCursorState(state) {
          if (!$J.defined(state)) {
            const scale = this.getZoomData();

            if (scale === 0) {
              state = 'zoomIn';
            } else if (scale === 1) {
              state = 'zoomOut';
            } else if (scale > 0 && scale < 1) {
              if (this.o.clickBehavior === 'up') {
                state = 'zoomIn';
              } else {
                state = 'zoomOut';
              }
            }
          }

          if (this.currentCursorState !== state) {
            this.view.toggleCursorClass(CURSOR_STATES[this.currentCursorState], CURSOR_STATES[state]);
            this.currentCursorState = state;
          }
        }

        setImage(data) {
          // when will work last block "else" if deepZoom always true!?
          const node = data.node;

          if (this.shown || this.showing) {
            const _data = Object.assign({}, data.callbackData);

            _data.node = node;
            this.deepZoom.image = _data;
          }
        } // private


        setLensSize(width, height) {
          this.lensSize = {
            width: width,
            height: height
          };
          this.lensHalfSize = {
            width: this.lensSize.width / 2,
            height: this.lensSize.height / 2
          };
        } // private


        calcLensSize() {
          const ps = this.pSize;
          const cls = this.currentLensSize;
          this.setLensSize(getPercentValue(ps.width, cls.width), getPercentValue(ps.height, cls.height));
        } // private


        getBaseScale() {
          this.baseScale = {
            x: this.zoomNodeSize.width / this.iSize.width,
            y: this.zoomNodeSize.height / this.iSize.height
          };
        } // eslint-disable-next-line class-methods-use-this


        calcLensPosition() {} // eslint-disable-next-line class-methods-use-this


        getImagePosition() {} // private


        showDeepZoom(bigImageOriginWidth, bigImageOriginHeight) {
          if (this.deepZoom) {
            /* start-removable-tile-helper-block */
            if (this.o.test && !zoomHelper) {
              zoomHelper = new ZoomHelper();
              zoomHelper.parentClass = this;
            }
            /* end-removable-tile-helper-block */


            const hash = this.view.hash;

            if (hash) {
              this.deepZoom.hash = hash;
            }

            this.deepZoom.lensSize = this.lensSize;
            this.deepZoom.minSize = this.zoomNodeSize;
            this.deepZoom.maxSize = Object.assign({
              originWidth: bigImageOriginWidth,
              originHeight: bigImageOriginHeight
            }, this.iSize);
            this.deepZoom.show();
          }
        } // private


        endOfShowing(isWithoutSettingEvents) {
          let result = false;

          if (this.state === globalVariables.APPEARANCE.SHOWING) {
            result = true;
            this.state = globalVariables.APPEARANCE.SHOWN;

            if (!isWithoutSettingEvents) {
              this.setEvents();
            }

            this.setCursorState();

            if (!this.o.smoothing) {
              this.deepZoomAction();
            }
          }

          return result;
        }

        sendZoomShownEvent() {
          this.emit('zoomShown', {
            data: {
              clientPosition: {
                x: this._x,
                y: this._y
              },
              pagePosition: {
                x: this.pPos.left,
                y: this.pPos.top
              }
            }
          });
        }

        showCenter(smallImg, largeImg, toLevel) {
          this.getAllSizes();
          const x = this.pPos.left + this.pSize.width / 2;
          const y = this.pPos.top + this.pSize.height / 2;
          return this.show(smallImg, largeImg, x, y, false, toLevel);
        }
        /*
            public
            toLevel = max || undefined(default), first, zero
        */


        show() {
          if (this.state !== globalVariables.APPEARANCE.HIDDEN) {
            return false;
          }

          this.state = globalVariables.APPEARANCE.SHOWING;
          return true;
        } // private


        endOfHiding() {
          this.stopMovingAndZooming();
          clearTimeout(this.hideTimer);
          this.anim.stop();
          this.setCursorState('zoomIn');
          this.view.clearCss();
          this.baseScale = {
            x: 1,
            y: 1
          };
          this.scale = {
            x: 1,
            y: 1
          };
          this.dScale = {
            x: 1,
            y: 1
          };
          this.setUpEvent = false;
          this.basePercentOfScale = {
            x: 0,
            y: 0
          };
          clearTimeout(this.deepZoomTimer);
          this.deepZoom.hide();
          this.view.clearDOM();
          this.state = globalVariables.APPEARANCE.HIDDEN;
          /* start-removable-tile-helper-block */

          if (zoomHelper) {
            zoomHelper.destroy();
            zoomHelper = null;
          }
          /* end-removable-tile-helper-block */


          this.emit('zoomHidden', {
            data: {
              clientPosition: {
                x: this._x,
                y: this._y
              },
              pagePosition: {
                x: this.pPos.left,
                y: this.pPos.top
              }
            }
          });
        } // private


        hide(force) {
          if (![globalVariables.APPEARANCE.SHOWN, globalVariables.APPEARANCE.SHOWING].includes(this.state)) {
            return false;
          }

          this.state = globalVariables.APPEARANCE.HIDING;
          this.view.removeEvents();

          if (force) {
            clearTimeout(this.deepZoomTimer);
            this.deepZoom.hide();
            this.endOfHiding();
          } else {
            this.stopMovingAndZooming();
          }

          return true;
        } // private


        addClickEvent() {
          let eventName = ['btnclick', 'tap'];

          if (this.o.trigger === 'dblclick') {
            eventName = ['dblbtnclick', 'dbltap'];
          }

          this.view.addEventToWrapper(eventName, e => {
            e.stop();
            this.x = e.x;
            this.y = e.y;

            if (this.o.clickBehavior === 'up') {
              if (!this.zoomUp(e.x, e.y)) {
                this.hide();
              }
            } else if (this.o.smoothing && this.scale.x !== this.baseScale.x) {
              this.hide();
            } else {
              this.hide(true);
            }
          });
        }

        customMove(x, y) {
          if (![globalVariables.APPEARANCE.HIDDEN, globalVariables.APPEARANCE.HIDING].includes(this.state)) {
            this.move(x, y);
          }
        } // private


        move(x, y) {
          this.x = x;
          this.y = y;
          this.afterMove();
        } // private


        afterMove() {
          if (!this.o.smoothing) {
            this.render(this.iPos, this.scale);
          }
        } // eslint-disable-next-line class-methods-use-this


        setEvents() {}

        setLensStyleOnResize() {
          this.view.lensStyle = {
            top: this.lensPosition.top,
            left: this.lensPosition.left,
            width: this.lensSize.width,
            height: this.lensSize.height
          };
        }

        onResize() {
          if (this.state !== globalVariables.APPEARANCE.HIDDEN) {
            if (this.state === globalVariables.APPEARANCE.HIDING) {
              this.hide(true);
            } else {
              if (this.state === globalVariables.APPEARANCE.SHOWING) {
                if (this.o.smoothing) {
                  this.state = globalVariables.APPEARANCE.SHOWN;
                  this.setEvents();
                  this.view.removeEventFromWrapper('transitionend');
                  this.view.lensStyle = {
                    'transition': ''
                  };
                  this.stopMovingAndZooming();
                  this.view.setImagePosition(this.iPos, this.scale);
                }
              }

              this.getAllSizes();

              if (this.zoomNodeSize.width > this.iSize.width || this.zoomNodeSize.height > this.iSize.height) {
                this.hide(true);
                return;
              }

              this.getBaseScale();
              this.scale.x = checkRange(this.scale.x, this.baseScale.x, 1);
              this.scale.y = checkRange(this.scale.y, this.baseScale.y, 1);
              this.calcLensSize();
              this.calcLensPosition();
              this.setLensStyleOnResize();
              this.deepZoom.lensSize = this.pSize;
              this.deepZoom.minSize = this.zoomNodeSize; // this.deepZoom.maxSize = this.iSize;

              this.deepZoom.resize(); // this.calcPositionOfImage(false, true);

              this.view.eventNodePositionSize = {
                position: this.pPos,
                size: this.pSize
              };

              if (!this.o.smoothing) {
                this.sendZoomingAction();
                this.setCursorState();
                this.deepZoomAction();
                this.view.setImagePosition(this.iPos, this.scale);
              }
            }
          }
        }

        destroy() {
          this.hide(true);
          clearTimeout(this.zoomingTimer);
          this.view.removeScrollEvent(this.scrollHandler);
          this.setCursorState('canZoom');
          clearTimeout(this.deepZoomTimer);
          this.deepZoom.destroy();
          this.deepZoom = null;
          this.off('getTile');
          this.off('zoomCancelLoadingOfTiles');
          /* start-removable-tile-helper-block */

          if (zoomHelper) {
            zoomHelper.destroy();
            zoomHelper = null;
          }
          /* end-removable-tile-helper-block */


          this.zoomingTimer = null;
          super.destroy();
        }

      }
      /* eslint-env es6 */

      /* global TOUCHEND */

      /* global TOUCH */

      /* global checkRange */

      /* global ZoomMap */

      /* global Controller */

      /* global getPercentValue */

      /* global getDifference */

      /* global checkImagePosition */

      /* global CURSOR_STATES */

      /* global getPercent */

      /* global MOVE */

      /* eslint-disable indent */

      /* eslint-disable no-lonely-if */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      const InnerController = (() => {
        // const MAX_SCALE_SIZE = 0.9135416666666667;
        // const MIN_SCALE_SIZE = 0.03854166666666667;
        // const MAX_STEP = 0.07;
        // const MAX_STEP = 0.2;
        // const MIN_STEP = 0.2;
        // const MIN_STEP = 0.5;
        // const getStepForAppearance = (scaleSize) => {
        //     let nextStep;
        //     nextStep = Math.abs(MAX_SCALE_SIZE - MIN_SCALE_SIZE) / Math.abs(MAX_STEP - MIN_STEP);
        //     nextStep = MAX_STEP + (MAX_SCALE_SIZE - scaleSize) / nextStep;
        //     return nextStep;
        // };
        const outOfSquare = (checkedPoint, nodePos, nodeSize, scrollPosition) => {
          let result = false;
          const x = nodePos.left - scrollPosition.x;
          const y = nodePos.top - scrollPosition.y;

          if (checkedPoint.x <= x || checkedPoint.y <= y || checkedPoint.x >= x + nodeSize.width || checkedPoint.y >= y + nodeSize.height) {
            result = true;
          }

          return result;
        };

        class IController extends Controller {
          constructor(view, o) {
            super(view, Object.assign({
              map: false,
              mapSize: 50 // in percentage // 100% is 50% from each image side

            }, o));
            this.basePercentOfScale = {
              x: 0,
              y: 0
            };
            this.clonedImage = null;
            this.hideTimer = null;
            this.showTimer = null;
            this.map = null;
            this.zoomingTimer = null;
            this.currentCursorState = 0;
            this.innerImagePosition = {
              x: 0,
              y: 0
            };
            this.setUpEvent = false;

            if ($J.browser.mobile) {
              this.o.pan = true;

              if (this.o.trigger === 'hover') {
                this.o.trigger = 'click';
              }
            }

            this.view.setLensCss(this.lensPosition, this.lensSize);
            this.ANIM_STEP = 0.3;
          }

          init() {
            super.init();
            this.createZoomMap();
          } // private


          createZoomMap() {
            if (!this.o.map) {
              return;
            }

            const mWidth = parseInt(getPercentValue(this.pSize.width / 2, this.o.mapSize), 10);
            const mHeight = parseInt(getPercentValue(this.pSize.height / 2, this.o.mapSize), 10);
            this.map = new ZoomMap(this.view.getContainerForMap(), {
              maxwidth: mWidth,
              maxheight: mHeight
            });
            this.map.parentClass = this;
            this.on('zoomGetImage', e => {
              e.stopEmptyEvent();
              e.data.map = true;
              e.data.exactSize = true;
            });
            this.on('zoomMapNewPosition', e => {
              e.stopAll(); // this.move(
              //     this.pPos.left + getPercentValue(this.lensSize.width, e.data.x),
              //     this.pPos.top + getPercentValue(this.lensSize.height, e.data.y)
              // );

              this.x = this.pPos.left + getPercentValue(this.lensSize.width, e.data.x);
              this.y = this.pPos.top + getPercentValue(this.lensSize.height, e.data.y);
              this.calcPositionOfImageInCenter(this.scale);

              if (!this.o.smoothing) {
                this.deepZoomAction();
                this.view.setImagePosition(this.iPos, this.scale);

                if (this.map) {
                  this.map.move(this.iPos, this.scale);
                }
              }
            });
          } // private


          move(x, y) {
            this.x = x;
            this.y = y;
            this.calcPositionOfImage(this.scale);
            this.afterMove();
          } // private


          render(position, scale) {
            super.render(position, scale);

            if (this.map) {
              this.map.move(position || this.iDPos, scale || this.dScale);
            }
          } // private


          calcPositionOfImageForPinch(scale) {
            if (!scale) {
              scale = this.dScale;
            }

            const w = this.iSize.width * scale.x;
            const h = this.iSize.height * scale.y;
            const dw = getDifference(this.iSize.width, w);
            const dh = getDifference(this.iSize.height, h);
            let x;
            let y;

            if (w > this.lensSize.width) {
              x = this._x - (getPercentValue(w, this.basePercentOfScale.x) + dw);
              x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            } else {
              x = this.lensSize.width / 2 - (w / 2 + dw);
            }

            if (h > this.lensSize.height) {
              y = this._y - (getPercentValue(h, this.basePercentOfScale.y) + dh);
              y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);
            } else {
              y = this.lensSize.height / 2 - (h / 2 + dh);
            }

            this.iPos = {
              x: x,
              y: y
            };
          }

          setScale(scale, x, y) {
            if (this.state === globalVariables.APPEARANCE.SHOWN) {
              if ($J.defined(x)) {
                this.x = x;
                this.y = y;
              }

              this.scale.x = scale;
              this.scale.y = scale;
              this.scale.x = checkRange(this.scale.x, this.baseScale.x, 1);
              this.scale.y = checkRange(this.scale.y, this.baseScale.y, 1);
              this.calcPositionOfImageForPinch(this.scale);
              this.sendZoomingAction();
              this.setCursorState();

              if (!this.o.smoothing) {
                this.dScale.x = this.scale.x;
                this.dScale.y = this.scale.y;
                this.imageDPosition.x = this.imagePosition.x;
                this.imageDPosition.y = this.imagePosition.y;
                this.deepZoomAction();
                this.view.setImagePosition(this.imagePosition, this.scale);

                if (this.map) {
                  this.map.move(this.imagePosition, this.scale);
                }
              }
            }
          } // private


          afterZoom(lastScale) {
            this.calcPositionOfImageForPinch(this.scale);
            super.afterZoom(lastScale);
          } // private


          calcPositionOfImage(scale, first, _x, _y) {
            const sw = _x || this._x;
            const sh = _y || this._y;

            if (!scale) {
              scale = this.dScale;
            }

            const w = this.iSize.width * scale.x;
            const h = this.iSize.height * scale.y;
            const dw = getDifference(this.iSize.width, w);
            const dh = getDifference(this.iSize.height, h);
            let x;
            let y; // x = sw - getPercentValue(w, getPercent(sw, this.pSize.width)) - dw;
            // y = sh - getPercentValue(h, getPercent(sh, this.pSize.height)) - dh;
            // x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            // y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);

            if (w > this.lensSize.width) {
              x = sw - getPercentValue(w, getPercent(sw, this.pSize.width)) - dw;
              x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            } else {
              x = this.lensSize.width / 2 - (w / 2 + dw);
            }

            if (h > this.lensSize.height) {
              y = sh - getPercentValue(h, getPercent(sh, this.pSize.height)) - dh;
              y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);
            } else {
              y = this.lensSize.height / 2 - (h / 2 + dh);
            }

            this.iPos = {
              x: x,
              y: y
            };
          }

          calcPositionOfImageInCenter(scale) {
            if (!scale) {
              scale = this.dScale;
            }

            const w = this.iSize.width * scale.x;
            const h = this.iSize.height * scale.y;
            const dw = getDifference(this.iSize.width, w);
            const dh = getDifference(this.iSize.height, h); // let x = this._x / (this.zoomNodeSize.width / w);
            // let y = this._y / (this.zoomNodeSize.height / h);

            let x = this._x / (this.lensSize.width / w);
            let y = this._y / (this.lensSize.height / h);
            x = this.lensSize.width / 2 - x - dw;
            y = this.lensSize.height / 2 - y - dh;
            x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);
            this.iPos = {
              x: x,
              y: y
            };
          }
          /**
           * @param {{ x: number; y: number; }} point
           */


          set basePercent(point) {
            if ([globalVariables.APPEARANCE.SHOWN, globalVariables.APPEARANCE.SHOWING].includes(this.state)) {
              const is = this.iSize;
              const cw = is.width * this.scale.x;
              const ch = is.height * this.scale.y;
              const dw = getDifference(is.width, cw);
              const dh = getDifference(is.height, ch);
              this.basePercentOfScale = {
                x: getPercent(Math.abs(this.iPos.x) + this.correctX(point.x) - dw, cw),
                y: getPercent(Math.abs(this.iPos.y) + this.correctY(point.y) - dh, ch)
              };
            }
          }

          setImage(data) {
            //when will work last block "else" if deepZoom always true!?
            if (this.shown || this.showing) {
              if (data.callbackData.map) {
                if (this.map) {
                  this.map.img = {
                    src: data.src,
                    srcset: data.srcset
                  };
                }
              } else {
                super.setImage(data);
              }
            }
          } // private


          endOfShowing(isWithoutSettingEvents) {
            if (super.endOfShowing(isWithoutSettingEvents)) {
              if (this.map) {
                this.map.show();
              }
            }
          }

          getImagePosition() {
            this.innerImagePosition = {
              x: getDifference(this.lensSize.width, this.zoomNodeSize.width),
              y: getDifference(this.lensSize.height, this.zoomNodeSize.height)
            };
          }
          /*
              public
              toLevel = max || undefined(default), first, zero
          */


          show(smallImg, bigImageOptions, x, y, actionEndHide, toLevel) {
            if (!super.show()) {
              return false;
            }

            this.setUpEvent = actionEndHide;
            this.iSize = {
              width: bigImageOptions.width,
              height: bigImageOptions.height
            };
            this.view.addStartCss();
            this.view.appendNodes(smallImg, this.iSize);
            this.getAllSizes();
            this.x = x;
            this.y = y;
            this.calcLensSize();
            this.getImagePosition();
            this.getBaseScale();
            this.showDeepZoom(bigImageOptions.originWidth, bigImageOptions.originHeight);
            this.showTimer = setTimeout(() => {
              // this timeout helps us to show non tile image without blink (cloned image manages to render)
              this.showTimer = null;
              this.emit('zoomBeforeShow', {
                data: {}
              });

              if (toLevel && toLevel !== 'max') {
                let scale;

                if (toLevel === 'zero') {
                  this.scale.x = this.baseScale.x;
                  this.scale.y = this.baseScale.y;
                } else {
                  scale = this.deepZoom.getScale('zoomin');
                  this.scale.x = scale;
                  this.scale.y = scale;
                }
              }

              this.calcPositionOfImage(this.scale, true);
              this.view.eventNodePositionSize = {
                position: this.pPos,
                size: this.pSize
              };
              this.dScale.x = this.baseScale.x;
              this.dScale.y = this.baseScale.y;
              this.iDPos = {
                x: getDifference(this.iSize.width, this.iSize.width * this.dScale.x) * -1 + this.innerImagePosition.x,
                y: getDifference(this.iSize.height, this.iSize.height * this.dScale.y) * -1 + this.innerImagePosition.y
              };
              this.view.setLensCss(this.lensPosition, this.lensSize);
              this.view.setImageSize(this.iDPos, this.iSize, this.dScale);
              this.boundaries = this.view.boundaries;

              if (this.map) {
                this.map.prepare(this.iSize.width, this.iSize.height, this.pSize.width, this.pSize.height);
              }

              if (this.o.smoothing && toLevel !== 'zero') {
                this.setEvents(); // this.animStep = getStepForAppearance(this.scale.x - this.baseScale.x);

                this.animStep = 0.3;

                this.animCb = () => {
                  this.deepZoomAction();
                  this.endOfShowing(true);
                };
              } else {
                this.endOfShowing();
              }

              if (this.o.smoothing) {
                this.anim.start();
              } // deleted it from this.endOfShowing() function because it sometimes doesn't work


              this.sendZoomShownEvent();
            }, 0);
            return true;
          }

          hide(force) {
            const result = super.hide(force);

            if (result) {
              clearTimeout(this.showTimer);

              if (force) {// empty
              } else {
                if (this.scale.x !== this.baseScale.x || this.scale.y !== this.baseScale.y) {
                  // this.animStep = getStepForAppearance(this.scale.x - this.baseScale.x);
                  this.animStep = 0.4;
                  this.scale.x = this.baseScale.x;
                  this.scale.y = this.baseScale.y;
                  this.iPos = {
                    x: getDifference(this.iSize.width, this.iSize.width * this.scale.x) * -1 + this.innerImagePosition.x,
                    y: getDifference(this.iSize.height, this.iSize.height * this.scale.y) * -1 + this.innerImagePosition.y
                  };

                  this.animCb = () => {
                    this.endOfHiding();
                  };
                } else {
                  this.endOfHiding();
                }
              }
            }

            return result;
          } // private


          addMouseScrollEvent() {
            this.view.addEventToWrapper('mousescroll', e => {
              e.stop();

              if (this.o.pan) {
                const is = this.iSize;
                const cw = is.width * this.scale.x;
                const ch = is.height * this.scale.y;
                const dw = getDifference(is.width, cw);
                const dh = getDifference(is.height, ch);
                this.basePercentOfScale = {
                  x: getPercent(Math.abs(this.iPos.x) + this.correctX(e.x) - dw, cw),
                  y: getPercent(Math.abs(this.iPos.y) + this.correctY(e.y) - dh, ch)
                };
              }

              let delta;
              const last = this.scale.x;

              if (e.isMouse) {
                const percent = 37;
                const v = e.delta / getPercentValue(e.deltaFactor, percent);
                this.scale.x += v;
                this.scale.y += v;
              } else {
                delta = e.delta;

                if (Math.abs(delta) > 15) {
                  delta = 15;

                  if (e.delta < 0) {
                    delta *= -1;
                  }
                }

                delta /= 350;
                this.scale.x += delta;
                this.scale.y += delta;
              }

              this.scale.x = checkRange(this.scale.x, this.baseScale.x, 1);
              this.scale.y = checkRange(this.scale.y, this.baseScale.y, 1);

              if (this.o.pan) {
                this.x = e.x;
                this.y = e.y;
                this.calcPositionOfImageForPinch(this.scale);
              } else {
                this.calcPositionOfImage(this.scale);
              }

              if (last !== this.scale.x) {
                this.sendZoomingAction();
                this.setCursorState();

                if (!this.o.smoothing) {
                  this.dScale.x = this.scale.x;
                  this.dScale.y = this.scale.y;
                  this.iDPos.x = this.iPos.x;
                  this.iDPos.y = this.iPos.y;
                  this.deepZoomAction();
                  this.view.setImagePosition(this.iPos, this.scale);

                  if (this.map) {
                    this.map.move(this.iPos, this.scale);
                  }
                }
              }

              this.hideByTimer();
            });
          }

          hideByTimer() {
            clearTimeout(this.hideTimer);

            if (this.scale.x <= this.baseScale.x + 0.00000001 && this.o.type !== 'outside') {
              this.hideTimer = setTimeout(() => {
                this.hide(true);
              }, 1000);
            }
          } // private


          addInnerTouchDrag() {
            let move = false;
            let lastX;
            let lastY;
            let currentWidth;
            let currentHeight;
            let dw;
            let dh;
            this.view.addEventToWrapper(TOUCH, e => {
              e.stop();

              if (e.state === 'dragstart') {
                move = true;
                this.view.addEventsCanvasClass(CURSOR_STATES.drag);
                this.stopMovingAndZooming(); // this.scale.x = this.dScale.x;
                // this.scale.y = this.dScale.y;

                this.x = e.x;
                this.y = e.y;
                currentWidth = this.iSize.width * this.scale.x;
                currentHeight = this.iSize.height * this.scale.y;
                dw = getDifference(this.iSize.width, currentWidth);
                dh = getDifference(this.iSize.height, currentHeight);
                lastX = e.x;
                lastY = e.y;
              } else if (e.state === 'dragend') {
                move = false;
                this.view.removeEventsCanvasClass(CURSOR_STATES.drag);
              } else if (move) {
                this.x = e.x;
                this.y = e.y;

                if (currentWidth > this.lensSize.width) {
                  this.iPos.x += e.x - lastX;
                  this.iPos.x = checkImagePosition(this.iPos.x, 0 - dw, dw + currentWidth, this.lensSize.width);
                } else {
                  this.iPos.x = this.lensSize.width / 2 - (currentWidth / 2 + dw);
                }

                if (currentHeight > this.lensSize.height) {
                  this.iPos.y += e.y - lastY;
                  this.iPos.y = checkImagePosition(this.iPos.y, 0 - dh, dh + currentHeight, this.lensSize.height);
                } else {
                  this.iPos.y = this.lensSize.height / 2 - (currentHeight / 2 + dh);
                }

                if (this.o.smoothing && this.o.pan) {
                  this.animStep = 0.3;
                } else {
                  this.iDPos.x = this.iPos.x;
                  this.iDPos.y = this.iPos.y;
                  this.deepZoomAction();
                  this.view.setImagePosition(this.iPos, this.scale);

                  if (this.map) {
                    this.map.move(this.iPos, this.scale);
                  }
                }

                lastX = e.x;
                lastY = e.y;
              }
            });
          } // private


          addInnerPinch() {
            let timer;
            let startScale;
            const saveValue = 1 - this.baseScale.x;
            let scale;
            let maxCompensation;
            let minCompensation;
            let max;
            let min;

            if (!this.o.customZooming) {
              return;
            }

            this.view.addEventToWrapper('pinch', e => {
              e.stop();

              if (e.state === 'pinchstart') {
                clearTimeout(timer);
                this.stopMovingAndZooming();
                this.view.node.removeEvent(TOUCH);
                this.scale.x = this.dScale.x;
                this.scale.y = this.dScale.y;
                startScale = this.scale.x;
                maxCompensation = 1;
                minCompensation = 1;
                max = 1;
                min = this.baseScale.x;
                this.basePercent = e.centerPoint;
              } else if (e.state === 'pinchresize') {
                this.basePercent = e.centerPoint;
              } else if (e.state === 'pinchmove') {
                this.x = e.centerPoint.x;
                this.y = e.centerPoint.y;
                scale = e.scale;
                scale *= startScale;

                if (max < scale) {
                  max = scale;
                  min = this.baseScale.x;
                  minCompensation = 1;
                  maxCompensation = saveValue / (max - this.baseScale.x);
                }

                if (min > scale) {
                  min = scale;
                  max = 1;
                  maxCompensation = 1;
                  minCompensation = this.baseScale.x / min;
                }

                scale = (this.baseScale.x + (scale - this.baseScale.x) * maxCompensation) * minCompensation;
                this.scale.x = scale;
                this.scale.y = scale;
                this.scale.x = checkRange(this.scale.x, this.baseScale.x, 1);
                this.scale.y = checkRange(this.scale.y, this.baseScale.y, 1);
                this.calcPositionOfImageForPinch(this.scale);
                this.sendZoomingAction();
                this.setCursorState();

                if (!this.o.smoothing) {
                  this.dScale.x = this.scale.x;
                  this.dScale.y = this.scale.y;
                  this.iDPos.x = this.iPos.x;
                  this.iDPos.y = this.iPos.y;
                  this.deepZoomAction();
                  this.view.setImagePosition(this.iPos, this.scale);

                  if (this.map) {
                    this.map.move(this.iPos, this.scale);
                  }
                }
              } else if (e.state === 'pinchend') {
                clearTimeout(timer);
                timer = setTimeout(() => {
                  this.addInnerTouchDrag();
                }, 42);

                if (this.scale.x <= this.baseScale.x + 0.00000001 && this.o.type !== 'outside' && this.state !== globalVariables.APPEARANCE.HIDING) {
                  clearTimeout(timer);
                  this.hide(true);
                }
              }
            });
          }

          hideZoomByMouseOut() {
            const cb = e => {
              if (outOfSquare(e.clientXY, this.view.getContainerPosition(), this.view.getContainerSize(), $J.D.scroll)) {
                this.view.removeGlobalEvent();
                this.hide();
              }
            };

            this.view.addGlobalEvent(cb);
          } // private


          setEvents() {
            if (this.setUpEvent && $J.browser.mobile) {
              this.view.addEventToWrapper(TOUCHEND, e => {
                e.stop();
                this.hide(true);
              });
            }

            if (this.o.customZooming) {
              this.addMouseScrollEvent();
            }

            this.addInnerTouchDrag();
            this.view.removeDragstart();

            if (!this.setUpEvent) {
              this.addInnerPinch();
            }

            if (this.o.trigger !== 'hover') {
              this.addClickEvent();
            } else {
              this.hideZoomByMouseOut();
            }

            if (!this.o.pan && !$J.browser.mobile) {
              this.view.addEventToMainContainer(MOVE, e => {
                if (e.pointerType && e.pointerType === 'touch') {
                  return;
                }

                e.stop();
                const pageXY = e.pageXY;
                this.move(pageXY.x, pageXY.y);
              });
            }
          } // private


          keepOldPosition(oldLensSize) {
            let x = this.iPos.x;
            let y = this.iPos.y;
            const w = this.iSize.width * this.scale.x;
            const h = this.iSize.height * this.scale.y;
            const dw = getDifference(this.iSize.width, w);
            const dh = getDifference(this.iSize.height, h);
            x -= (oldLensSize.width - this.lensSize.width) / 2;
            y -= (oldLensSize.height - this.lensSize.height) / 2;

            if (w > this.lensSize.width) {
              x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            } else {
              x = this.lensSize.width / 2 - (w / 2 + dw);
            }

            if (h > this.lensSize.height) {
              y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);
            } else {
              y = this.lensSize.height / 2 - (h / 2 + dh);
            }

            this.iPos = {
              x: x,
              y: y
            };
          }

          onResize() {
            const oldLensSize = this.lensSize;
            super.onResize();

            if (this.state !== globalVariables.APPEARANCE.HIDDEN) {
              if (this.state !== globalVariables.APPEARANCE.HIDING) {
                this.keepOldPosition(oldLensSize);
                this.getImagePosition();

                if (this.map) {
                  const mWidth = parseInt(getPercentValue(this.pSize.width / 2, this.o.mapSize), 10);
                  const mHeight = parseInt(getPercentValue(this.pSize.height / 2, this.o.mapSize), 10);
                  this.map.resize(mWidth, mHeight, this.iSize.width, this.iSize.height, this.pSize.width, this.pSize.height);

                  if (!this.o.smoothing) {
                    this.map.move(this.iPos, this.scale);
                  }
                }
              }
            }
          }

          destroy() {
            clearTimeout(this.showTimer);

            if (this.map) {
              this.map.destroy();
              this.map = null;
              this.off('zoomGetImage');
              this.off('zoomMapNewPosition');
            }

            super.destroy();
          }

        }

        return IController;
      })();
      /* eslint-env es6 */

      /* global getDifference */

      /* global TOUCHEND */

      /* global TOUCH */

      /* global getPercent */

      /* global Controller */

      /* global getPercentValue */

      /* global MOVE */

      /* global checkRange */

      /* eslint-disable indent */

      /* eslint-disable no-lonely-if */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line


      const MagnifierController = (() => {
        const MIN_SIZE_OF_LENS = 10;
        const MAX_SIZE_OF_LENS = 90;
        const DEFAULT_MAGNIFIER_SIZE = 70; // percent

        const DEFAULT_MOBILE_MAGNIFIER_ZOOM_MARGIN = 65;

        const checkMinMax = size => {
          let factor;

          if (size.width >= size.height) {
            factor = size.width / size.height;
          } else {
            factor = size.height / size.width;
          }

          const min = MIN_SIZE_OF_LENS;
          const max = MAX_SIZE_OF_LENS;

          if (factor > max / min) {
            return {
              width: 50,
              height: 50
            };
          }

          if (size.width < min) {
            size.height = min * (size.height / size.width);
            size.width = min;
          }

          if (size.height < min) {
            size.width = min * (size.width / size.height);
            size.height = min;
          }

          if (size.width > max) {
            size.height = max * (size.height / size.width);
            size.width = max;
          }

          if (size.height > max) {
            size.width = max * (size.width / size.height);
            size.height = max;
          }

          return size;
        }; // eslint-disable-next-line no-unused-vars


        class MController extends Controller {
          constructor(view, o) {
            if ($J.browser.mobile && o.margin === 9) {
              delete o.margin;
            }

            super(view, Object.assign({
              width: 70,
              // percent
              height: 70,
              // percent
              margin: DEFAULT_MOBILE_MAGNIFIER_ZOOM_MARGIN
            }, o));
            this.setUpEvent = false;
            this.isSquare = true;
            this.ANIM_STEP = 0.4;
          }

          init() {
            super.init();
            this.setOutsideLensSize();
          } // private


          setOutsideLensSize() {
            const s = {
              width: this.o.width,
              height: this.o.height
            };

            if (s.width === s.height) {
              this.isSquare = true;
            }

            if ([s.width, s.height].includes('auto')) {
              this.isSquare = true;

              if (s.width === 'auto') {
                if (s.height !== 'auto') {
                  s.height = this.getPercentSize(s.height, 'height');
                  s.width = s.height;
                } else {
                  s.height = DEFAULT_MAGNIFIER_SIZE;
                  s.width = s.height;
                }
              } else if (s.width !== 'auto') {
                s.width = this.getPercentSize(s.width, 'width');
                s.height = s.width;
              } else {
                s.height = DEFAULT_MAGNIFIER_SIZE;
                s.width = s.height;
              }
            } else {
              s.width = this.getPercentSize(s.width, 'width');
              s.height = this.getPercentSize(s.height, 'height');
            }

            this.currentLensSize = checkMinMax({
              width: s.width,
              height: s.height
            });
            this.ANIM_STEP = 0.6;
          } // private


          calcLensSize() {
            if (this.isSquare) {
              const ps = this.pSize;
              const cls = this.currentLensSize;
              const value = getPercentValue(Math.min(ps.width, ps.height), cls.width);
              this.setLensSize(value, value);
            } else {
              super.calcLensSize();
            }
          } // private


          calcLensPosition() {
            const ps = this.pSize;
            let margin = this.o.margin; //eslint-disable-next-line no-unused-vars
            // let lensPositionState = 'top'; // top left right bottom;

            if (margin < 0) {
              margin = 0;
            }

            if (this._x < 0) {
              this._x = 0;
            }

            if (this._y < 0) {
              this._y = 0;
            }

            if (this._x > ps.width) {
              this._x = ps.width;
            }

            if (this._y > ps.height) {
              this._y = ps.height;
            }

            let top;
            let left;
            top = this._y - this.lensHalfSize.height;
            left = this._x - this.lensHalfSize.width; // if (!$J.browser.mobile) {
            //     margin = 0;
            // }

            let scroll;
            let ws;
            const pp = this.pPos;

            if ($J.browser.mobile) {
              top -= margin;
              scroll = $($J.W).scroll;
              ws = $($J.W).size;

              if (pp.top + top < scroll.y) {
                if (pp.left + this._x - this.lensSize.width - margin > scroll.x) {
                  // lensPositionState = 'left';
                  top = this._y - this.lensHalfSize.height;
                  left = this._x - this.lensSize.width - margin;
                } else if (pp.left + this._x + this.lensSize.width + margin < scroll.x + ws.width) {
                  // lensPositionState = 'right';
                  top = this._y - this.lensHalfSize.height;
                  left = this._x + margin;
                } else if (scroll.y + ws.height > pp.top + this._y + margin + this.lensSize.height) {
                  // lensPositionState = 'bottom';
                  top = this._y + margin;
                }
              }
            } // if (['top', 'bottom'].includes(lensPositionState) && !$J.browser.mobile) {
            //     if (pp.left + left < scroll.x) {
            //         left = scroll.x - pp.left;
            //     }
            //     if (pp.left + left + this.lensSize.width > scroll.x + ws.width) {
            //         left = scroll.x - pp.left + ws.width - this.lensSize.width;
            //     }
            // }


            this.lensPosition = {
              top: top,
              left: left
            };
          }

          calcPositionOfImage(scale, first, _x, _y) {
            const sw = _x || this._x;
            const sh = _y || this._y;
            const x = this.lensHalfSize.width - getPercentValue(this.iSize.width, getPercent(sw, this.pSize.width));
            const y = this.lensHalfSize.height - getPercentValue(this.iSize.height, getPercent(sh, this.pSize.height));
            this.iPos = {
              x: x,
              y: y
            };
          } // private


          getPercentSize(value, side) {
            if (/%$/.test(value)) {
              value = parseInt(value, 10);
            } else {
              value = parseInt(value, 10);
              value /= this.pSize[side] / 100;
            }

            return value;
          } // private


          setEvents() {
            if (this.setUpEvent && !this.o.pan) {
              this.view.addEventToMainContainer(TOUCHEND, e => {
                e.stop();
                this.hide(true);
              });
            }

            if (this.o.customZooming) {
              this.addMouseScroollEvent();
            }

            this.addMouseOverEvent();

            if (this.o.trigger === 'hover') {
              this.addMouseOutEvent();
            }

            if (this.o.pan) {
              this.addDragEvent();
            }

            if ($J.browser.mobile) {
              this.addTapEvent();
            }

            if (this.o.trigger !== 'hover') {
              this.addClickEvent();
            }

            if (!this.o.pan && !$J.browser.mobile) {
              this.view.addEventToMainContainer(MOVE, e => {
                if (e.pointerType && e.pointerType === 'touch') {
                  return;
                }

                e.stop();
                const pageXY = e.pageXY;
                this.move(pageXY.x, pageXY.y);

                if (this._x <= 0 || this._y <= 0 || this._x >= this.pSize.width || this._y >= this.pSize.height) {
                  this.hide();
                }
              });
            }
          }

          afterMove() {
            this.calcLensPosition();
            this.calcPositionOfImage(this.scale);
            this.view.lensPosition = this.lensPosition;
            super.afterMove();
          } // private


          changeLensSize(size) {
            const min = MIN_SIZE_OF_LENS;
            const max = MAX_SIZE_OF_LENS;
            size.width = checkRange(size.width, min, max);
            size.height = checkRange(size.height, min, max);

            if (size.width !== this.currentLensSize.width) {
              this.currentLensSize.width = size.width;
              this.currentLensSize.height = size.height;
              this.calcLensSize();
              this.calcLensPosition();
              this.calcPositionOfImage();
              this.iDPos.x = this.iPos.x;
              this.iDPos.y = this.iPos.y;
              this.deepZoomAction(false, this.lensSize);
              this.view.setImagePosition(this.iPos, this.scale);
              this.view.lensPosition = this.lensPosition;
              this.view.lensSize = this.lensSize;
            }
          } // private


          addMouseScroollEvent() {
            this.view.addEventToWrapper('mousescroll', e => {
              e.stop();
              let i;
              const delta = e.delta;
              const s = {
                width: 0,
                height: 0
              };

              if (this.isSquare) {
                for (i in s) {
                  if ({}.hasOwnProperty.call(s, i)) {
                    s[i] = this.currentLensSize[i] + delta;
                  }
                }
              } else {
                i = this.currentLensSize.height / this.currentLensSize.width;
                s.width = this.currentLensSize.width + delta;
                s.height = this.currentLensSize.height + delta * i;
              }

              this.changeLensSize(s);
            });
          } // private


          addMouseOverEvent() {
            this.view.addEventToMainContainer('mouseover', e => {
              e.stop();
              const pageXY = e.pageXY;
              this.x = pageXY.x;
              this.y = pageXY.y;
              this.calcLensPosition();
              this.calcPositionOfImage();
              this.view.lensPosition = {
                top: this.lensPosition.top,
                left: this.lensPosition.left
              };
              this.view.setImagePosition(this.iPos, this.scale);
            });
          } // private


          addMouseOutEvent() {
            this.view.addEventToWrapper('mouseout', e => {
              // let toElement = e.toElement || e.relatedTarget;
              let toElement = e.related; // if we change between workspace we must to hide the lens
              // if (!toElement) { return; }

              while (toElement && toElement !== this.node && toElement !== this.lensContainer && toElement !== this.eventsCanvasNode) {
                toElement = toElement.parentNode;
              }

              if (this.node !== toElement && this.eventsCanvasNode !== toElement) {
                const p = e.clientXY;

                if (p.x < this.boundaries.left || p.x > this.boundaries.right || p.y < this.boundaries.top || p.y > this.boundaries.bottom) {
                  e.stop();

                  if (this.o.smoothing) {
                    this.hide();
                  } else {
                    this.hide(true);
                  }
                }
              }
            });
          } // private


          addDragEvent() {
            let move = false;
            this.view.addEventToMainContainer(TOUCH, e => {
              e.stop();

              if (e.state === 'dragstart') {
                move = true;
              } else if (e.state === 'dragend') {
                move = false;
              } else if (move) {
                this.move(e.x, e.y);
              }
            });
          } // private


          addTapEvent() {
            this.view.addEventToMainContainer(this.o.trigger === 'dblclick' ? 'dbltap' : 'tap', e => {
              e.stop();

              if (this.o.smoothing) {
                this.hide();
              } else {
                this.hide(true);
              }
            });
          }

          hide(force) {
            const result = super.hide(force);

            if (result) {
              if (force) {// empty
              } else {
                this.view.addEventToWrapper('transitionend', e => {
                  e.stop();
                  this.view.removeEventFromWrapper('transitionend');
                  this.endOfHiding();
                });
                this.view.lensStyle = {
                  transition: 'opacity .2s linear, transform .2s linear',
                  opacity: 0,
                  transform: 'scale(0)'
                };
              }
            }

            return result;
          }
          /*
              public
              toLevel = max || undefined(default), first, zero
          */


          show(smallImg, bigImageOptions, x, y, actionEndHide, toLevel) {
            if (!super.show()) {
              return false;
            }

            this.emit('zoomBeforeShow', {
              data: {}
            });
            this.setUpEvent = actionEndHide;
            this.iSize = {
              width: bigImageOptions.width,
              height: bigImageOptions.height
            };
            this.view.addStartCss();
            this.view.appendNodes(smallImg, this.iSize);
            this.getAllSizes();
            this.x = x;
            this.y = y;
            this.calcLensSize();
            this.calcLensPosition(); // this.getImagePosition();

            this.getBaseScale();
            this.showDeepZoom(bigImageOptions.originWidth, bigImageOptions.originHeight); // this.calcPositionOfImage(false, true);

            this.calcPositionOfImage(this.scale, true);
            this.view.eventNodePositionSize = {
              position: this.pPos,
              size: this.pSize
            };
            this.dScale.x = this.baseScale.x;
            this.dScale.y = this.baseScale.y;
            this.iDPos = {
              x: getDifference(this.iSize.width, this.iSize.width * this.dScale.x) * -1 - this.lensPosition.left,
              y: getDifference(this.iSize.height, this.iSize.height * this.dScale.y) * -1 - this.lensPosition.top
            };
            this.view.setLensCss(this.lensPosition, this.lensSize, 'opacity .15s linear, transform .15s linear');
            this.view.setImageSize(this.iDPos, this.iSize, this.dScale);
            this.boundaries = this.view.boundaries;

            if (this.o.smoothing) {
              this.view.addEventToWrapper('transitionend', e => {
                e.stop();
                this.view.removeEventFromWrapper('transitionend');
                this.view.lensStyle = {
                  transition: ''
                };
                this.sendZoomShownEvent();
              });
              this.endOfShowing();
              this.anim.start();
            } else {
              this.endOfShowing();
              this.sendZoomShownEvent();
            } // deleted it from this.endOfShowing() function because it sometimes doesn't work
            // this.sendZoomShownEvent();


            return true;
          }

        }

        return MController;
      })();
      /* eslint-env es6 */

      /* global checkRange */

      /* global TOUCH */

      /* global getDifference */

      /* global Eye */

      /* global getPercentValue */

      /* global Controller */

      /* global checkImagePosition */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      const OutsideController = (() => {
        const DEFAULT_OUTSIDE_ZOOM_MARGIN = 9; // px

        class OController extends Controller {
          constructor(view, o) {
            super(view, Object.assign({
              margin: DEFAULT_OUTSIDE_ZOOM_MARGIN,
              outsidePosition: 'right',
              // top, left, right, bottom
              width: 100,
              // percent
              height: 100 // percent

            }, o));
            this.showingParams = null;
            this.eye = new Eye(this.view.getNodeForEye(), this.o.trigger === 'hover');
            this.ANIM_STEP = 0.18;
            this.mouseOutHandler = this.mouseOut.bind(this);
          }

          getBoundaries() {
            this.boundaries = this.eye.boundaries;
          }

          init() {
            super.init();
            this.setOutsideLensSize();
          } // private


          setEyesParams() {
            const sw = this.currentLensSize.width / (this.iSize.width * this.scale.x);
            const sh = this.currentLensSize.height / (this.iSize.height * this.scale.y);
            this.eye.size = {
              width: sw * this.zoomNodeSize.width,
              height: sh * this.zoomNodeSize.height
            };
            this.eye.position = {
              x: this._x,
              y: this._y
            };
          }

          calcLensPosition() {
            let margin = this.o.margin;
            const ps = this.pSize;
            const pp = this.pPos;

            if (margin < 0) {
              margin = 0;
            }

            let t = pp.top;
            let l = pp.left;

            switch (this.o.outsidePosition) {
              case 'top':
                t += (this.lensSize.height + margin) * -1;
                break;

              case 'left':
                l += (this.lensSize.width + margin) * -1;
                break;

              case 'right':
                l += ps.width + margin;
                break;

              case 'bottom':
                t += ps.height + margin;
                break;
              //no default
            }

            this.lensPosition = {
              top: t,
              left: l
            };
          }

          calcPositionOfImage(scale) {
            if (!scale) {
              scale = this.dScale;
            }

            const w = this.iSize.width * scale.x;
            const h = this.iSize.height * scale.y;
            const dw = getDifference(this.iSize.width, w);
            const dh = getDifference(this.iSize.height, h);
            let x = this._x / (this.zoomNodeSize.width / w);
            let y = this._y / (this.zoomNodeSize.height / h);
            x = this.lensSize.width / 2 - x - dw;
            y = this.lensSize.height / 2 - y - dh;
            x = checkImagePosition(x, 0 - dw, dw + w, this.lensSize.width);
            y = checkImagePosition(y, 0 - dh, dh + h, this.lensSize.height);
            this.iPos = {
              x: x,
              y: y
            };
          }

          afterMove() {
            this.calcLensPosition();
            this.calcPositionOfImage(this.scale);
            this.setEyesParams();
            this.view.lensPosition = this.lensPosition;
            super.afterMove();
          }

          hide(force) {
            const result = super.hide(force);

            if (result) {
              if (!$J.browser.mobile) {
                this.view.removeMouseMoveEvent(this.mouseOutHandler);
              }

              this.eye.clearEvents();
              this.eye.hide();

              if (force) {// empty
              } else {
                this.view.removeEvents();
                this.endOfHiding();
              }
            }

            return result;
          } // private


          getShowingPropertiesToOutsideMode() {
            const result = {
              start: {
                x: 0,
                y: 0
              },
              end: {
                x: 0,
                y: 0
              }
            };

            switch (this.o.outsidePosition) {
              case 'top':
                result.start.y = 10;
                result.end.y = 0;
                break;

              case 'left':
                result.start.x = 10;
                result.end.x = 0;
                break;

              case 'right':
                result.start.x = -10;
                result.end.x = 0;
                break;

              case 'bottom':
                result.start.y = -10;
                result.end.y = 0;
                break;
              // no default
            }

            return result;
          } // private


          endOfShowing() {
            super.endOfShowing();
            this.getBoundaries();
          }
          /*
              public
              toLevel = max || undefined(default), first, zero
          */


          show(smallImg, bigImageOptions, x, y, actionEndHide, toLevel) {
            if (!super.show()) {
              return false;
            }

            this.emit('zoomBeforeShow', {
              data: {}
            });
            this.iSize = {
              width: bigImageOptions.width,
              height: bigImageOptions.height
            };
            this.showingParams = this.getShowingPropertiesToOutsideMode();
            this.view.addStartCss(this.showingParams);
            this.view.appendNodes(smallImg, this.iSize);
            this.getAllSizes();
            this.x = x;
            this.y = y;
            this.calcLensSize();
            this.calcLensPosition(); // this.getImagePosition();

            this.getBaseScale();
            this.showDeepZoom(bigImageOptions.originWidth, bigImageOptions.originHeight); // this.calcPositionOfImage(false, true);

            this.calcPositionOfImage(this.scale, true);
            this.view.eventNodePositionSize = {
              position: this.pPos,
              size: this.pSize
            };
            this.dScale.x = this.baseScale.x;
            this.dScale.y = this.baseScale.y;
            this.iDPos = {
              x: getDifference(this.iSize.width, this.iSize.width * this.dScale.x) * -1,
              y: getDifference(this.iSize.height, this.iSize.height * this.dScale.y) * -1
            };
            this.view.setLensCss(this.lensPosition, this.lensSize, this.o.smoothing ? 'opacity .4s linear, transform .15s ease-in' : 'none');
            this.view.setImageSize(this.iDPos, this.iSize, this.dScale);

            if (this.o.smoothing || toLevel === 'zero') {
              this.endOfShowing();
            }

            this.eye.show(this.view.getImageForEye());
            this.getBoundaries();
            this.setEyesParams();
            this.animStep = 0.3;

            if (this.o.smoothing) {
              this.anim.start();
            } else {
              this.endOfShowing();
            } // deleted it from this.endOfShowing() function because it sometimes doesn't work


            this.sendZoomShownEvent();
            return true;
          }

          setOutsideLensSize() {
            const s = {
              width: this.o.width,
              height: this.o.height
            };

            if (s.width === 'auto') {
              s.width = this.pSize.width;
            } else if (/%$/.test(this.o.width)) {
              s.width = this.pSize.width / 100 * parseInt(this.o.width, 10);
            } else {
              s.width = parseInt(s.width, 10);
            }

            if (s.height === 'auto') {
              s.height = this.pSize.height;
            } else if (/%$/.test(this.o.height)) {
              s.height = this.pSize.height / 100 * parseInt(this.o.height, 10);
            } else {
              s.height = parseInt(s.height, 10);
            }

            this.currentLensSize = {
              width: s.width,
              height: s.height
            };
          }

          calcLensSize() {
            const cls = this.currentLensSize;
            this.lensSize = {
              width: cls.width,
              height: cls.height
            };
            this.lensHalfSize = {
              width: this.lensSize.width / 2,
              height: this.lensSize.height / 2
            };
          } // private


          setEvents() {
            if ($J.browser.mobile && this.o.pan) {
              this.addOutsideTouchDrag();
            } // TODO maybe remove it


            if (!$J.browser.mobile && $J.browser.touchScreen && ['edge', 'ie'].includes($J.browser.uaName)) {
              if (!this.o.pan) {
                this.eye.addEventToMainContainer('pointerup', e => {
                  this.hide();
                });
              }
            }

            this.eye.addEventToMainContainer('mousemove', e => {
              e.stop();
              const pageXY = e.pageXY;
              this.move(pageXY.x, pageXY.y);
            });

            if (this.o.trigger === 'hover') {
              if (!$J.browser.mobile) {
                this.view.addMouseMoveEvent(this.mouseOutHandler);
              }

              this.eye.addEventToMainContainer('mouseout', this.mouseOutHandler);
            } else {
              let eventName = ['btnclick', 'tap'];

              if (this.o.trigger === 'dblclick') {
                eventName = ['dblbtnclick', 'dbltap'];
              }

              this.eye.addEventToMainContainer(eventName, e => {
                this.hide();
              });
            }

            if (this.o.customZooming) {
              this.setMouseScrollEvent();
            }
          }

          mouseOut(e) {
            const p = e.clientXY;

            if (p.x < this.boundaries.left || p.x > this.boundaries.right || p.y < this.boundaries.top || p.y > this.boundaries.bottom) {
              this.hide(!this.getZoomData());
            }
          } // private
          // it works if trigger !== 'hover'


          addOutsideTouchDrag() {
            let isStart = false;
            this.eye.addEventToMainContainer(TOUCH, e => {
              e.stop();

              if (e.state === 'dragstart') {
                isStart = true;
              } else if (e.state === 'dragend') {
                isStart = false;
              } else if (isStart) {
                this.move(e.x, e.y);
              }
            });
          } // private


          setMouseScrollEvent() {
            this.eye.addEventToMainContainer('mousescroll', e => {
              const last = this.scale.x;
              e.stop();

              if (e.isMouse) {
                const percent = 37;
                const v = e.delta / getPercentValue(e.deltaFactor, percent);
                this.scale.x += v;
                this.scale.y += v;
              } else {
                let delta = e.delta;

                if (Math.abs(delta) > 15) {
                  delta = 15;

                  if (e.delta < 0) {
                    delta *= -1;
                  }
                }

                delta /= 350;
                this.scale.x += delta;
                this.scale.y += delta;
              }

              this.scale.x = checkRange(this.scale.x, this.baseScale.x, 1);
              this.scale.y = checkRange(this.scale.y, this.baseScale.y, 1);
              this.calcPositionOfImage(this.scale);

              if (last !== this.scale.x) {
                this.sendZoomingAction();
                this.setCursorState();

                if (!this.o.smoothing) {
                  this.dScale.x = this.scale.x;
                  this.dScale.y = this.scale.y;
                  this.iDPos.x = this.iPos.x;
                  this.iDPos.y = this.iPos.y;
                  this.deepZoomAction();
                  this.setImagePosition(this.iPos, this.scale);
                }

                this.setEyesParams();
              }
            });
          }

          setLensStyleOnResize() {
            this.view.lensPosition = this.lensPosition;
            this.view.setCanvasNodeSize(this.lensSize);
          }

          onResize() {
            super.onResize();

            if (this.state !== globalVariables.APPEARANCE.HIDDEN && this.state !== globalVariables.APPEARANCE.HIDING) {
              this.eye.resize();
            }
          }

          destroy() {
            this.eye.destroy();
            this.view.removeMouseMoveEvent(this.mouseOutHandler);
            super.destroy();
          }

        }

        return OController;
      })();
      /* eslint-env es6 */

      /* global InnerView */

      /* global EventEmitter */

      /* global InnerController */

      /* global MagnifierController */

      /* global MagnifierView */

      /* global OutsideController */

      /* global OutsideView */

      /* eslint-disable indent */

      /* eslint no-unused-vars: ["error", { "args": "none" }] */

      /* eslint guard-for-in: "off"*/

      /* eslint no-restricted-syntax: ["error",  "WithStatement", "BinaryExpression[operator='in']"] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars


      class ImageZoom extends EventEmitter {
        constructor(parentNode, o) {
          super();
          this.zoomType = o.type;

          if (o.type === 'inner') {
            this.view = new InnerView(parentNode);
            this.view.addClassToWrapper('inner');
            this.controller = new InnerController(this.view, o);
          } else if (['circle', 'square'].includes(o.type)) {
            this.view = new MagnifierView(parentNode);
            this.view.addClassToWrapper(o.type);
            this.controller = new MagnifierController(this.view, o);
          } else {
            // outside
            this.view = new OutsideView(parentNode);
            this.view.addClassToWrapper('outside');
            this.controller = new OutsideController(this.view, o);
          }

          this.controller.parentClass = this;
          this.controller.init();
        }
        /**
         * @param {nodeElement} lensContainer
         */


        set lensContainer(lensContainer) {
          this.controller.lensContainer = lensContainer;
        }

        get shown() {
          return this.controller.shown;
        }

        get showing() {
          return this.controller.showing;
        }

        getZoomData(scale) {
          return this.controller.getZoomData(scale);
        }

        get nextMinZoom() {
          return this.controller.nextMinZoom;
        }

        get nextMaxZoom() {
          return this.controller.nextMaxZoom;
        }

        zoomUp(x, y) {
          return this.controller.zoomUp(x, y);
        }

        zoomDown(x, y) {
          return this.controller.zoomDown(x, y);
        }

        showCenter(smallImg, largeImg, toLevel) {
          return this.controller.showCenter(smallImg, largeImg, toLevel);
        }
        /**
         * @param {{ indexY: number; indexX: number; node: nodeElement; src: string, srcset: string, callbackData: { map: boolean } }} data
         */


        addLoadedImage(data) {
          this.controller.setImage(data);
        }

        show(smallImg, bigImageOptions, x, y, actionEndHide, toLevel) {
          return this.controller.show(smallImg, bigImageOptions, x, y, actionEndHide, toLevel);
        }

        hide(force) {
          return this.controller.hide(force);
        }

        customMove(x, y) {
          this.controller.customMove(x, y);
        }

        get baseScale() {
          return this.controller.baseScale;
        }
        /**
         * @param {{ x: number; y: number; }} point
         */


        set basePercent(point) {
          if (this.zoomType === 'inner') {
            this.controller.basePercent = point;
          }
        }

        setScale(scale, x, y) {
          if (this.zoomType === 'inner') {
            this.controller.setScale(scale, x, y);
          }
        }

        onResize() {
          this.controller.onResize();
        }

        destroy() {
          this.view.destroy();
          this.controller.destroy();
        }

      }

      return ImageZoom;
    });
    Sirv.define('Hint', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper'], (bHelpers, magicJS, globalVariables, globalFunctions, helper) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('Hint', () => {
        return '.sirv-hint{position:absolute;display:inline-block;top:50%;left:0;width:100%;transform:translate3d(0,-50%,1px);transition:opacity .3s linear;text-align:center;opacity:0;z-index:42;pointer-events:none;-webkit-font-smoothing:antialiased}.sirv-hint.show{opacity:1}.sirv-hint-message{position:relative;display:inline-block;padding:.35em 1.5em;border-radius:2px;background:rgba(55,58,60,.8);color:#fff;font:normal 16px/1.5 \'Lucida Grande\',\'Lucida Sans Unicode\',Verdana,\'Helvetica Neue\',Arial,Helvetica,sans-serif;text-decoration:none}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */
      // eslint-disable-next-line no-unused-vars

      class HintInstance {
        constructor(parent, options) {
          this.parent = $(parent);
          this.options = Object.assign({
            html: 'hint',
            showClass: 'show',
            additionalClass: [],
            autohide: 3500
          }, options || {});
          this.instanceNode = $J.$new('div').addClass('sirv-hint');
          this.hintContainer = $J.$new('span').addClass('sirv-hint-message');
          this.inDoc = false;
          this.isShown = false;
          this.timer = null;
          this.instanceNode.addClass(...this.options.additionalClass);
          this.hintContainer.node.innerHTML = this.options.html;
          this.instanceNode.append(this.hintContainer);
        }

        get autoHideTime() {
          return this.options.autohide;
        }

        get actionTime() {
          let result = 0;
          let value = this.instanceNode.getCss('transition');

          try {
            value = value.split(' ')[1];
          } catch (e) {
            value = 0;
          }

          if (value) {
            value = value.trim();

            if (/m?s$/.test(value)) {
              if (/s$/.test(value)) {
                result = parseFloat(value);
                result *= 1000;
              } else {
                result = parseInt(value, 10);
              }
            }
          }

          return result;
        }

        get movingTime() {
          return this.autoHideTime + this.actionTime;
        }

        append() {
          if (!this.inDoc) {
            this.inDoc = true;
            this.parent.append(this.instanceNode);
          }
        }

        removeEvent() {
          this.instanceNode.removeEvent('transitionend');
        }

        show() {
          this.append();
          clearTimeout(this.timer);
          this.timer = null;
          this.instanceNode.render();
          this.removeEvent();
          this.instanceNode.addClass(this.options.showClass);
          this.isShown = true;

          if (this.options.autohide) {
            this.timer = setTimeout(() => {
              this.hide();
            }, this.options.autohide);
          }
        }

        hide() {
          if (this.inDoc) {
            this.removeEvent();
            clearTimeout(this.timer);
            this.timer = null;
            this.instanceNode.addEvent('transitionend', e => {
              e.stop();
              this.removeEvent();
              this.inDoc = false;
              this.instanceNode.remove();
            });
            this.instanceNode.removeClass(this.options.showClass);
            this.isShown = false;
          }
        }

        destroy() {
          this.instanceNode.setCssProp('transitionend', 'none');
          this.hide();
          this.removeEvent();
          this.hintContainer.remove();
          this.hintContainer.node.innerHTML = '';
          this.instanceNode.remove();
          this.inDoc = false;
        }

      }

      return HintInstance;
    });
    Sirv.define('ProgressLoader', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'RoundLoader'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, RoundLoader) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('ProgressLoader', () => {
        return '.smv-progress-loader{pointer-events:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.smv-progress-loader .smv-pl-circle-wrapper,.smv-progress-loader .smv-pl-indicator,.smv-progress-loader .smv-pl-indicator .smv-pl-pie,.smv-progress-loader .smv-pl-indicator .smv-pl-slice,.smv-progress-loader .smv-pl-text-wrapper,.smv-progress-loader .smv-pl-wrapper{top:0;left:0;width:100%;height:100%}.smv-progress-loader .smv-pl-text-wrapper,.smv-progress-loader .smv-pl-wrapper{display:inline-block;position:relative}.smv-progress-loader .smv-pl-wrapper{transform:scale(0);transition:transform .15s cubic-bezier(.17,.67,.57,1.47),opacity .2s linear;border-radius:50%;background-color:rgba(0,0,0,.55);opacity:0}.smv-progress-loader .smv-pl-circle-wrapper,.smv-progress-loader .smv-pl-indicator,.smv-progress-loader .smv-pl-indicator .smv-pl-pie,.smv-progress-loader .smv-pl-indicator .smv-pl-slice{position:absolute}.smv-progress-loader .smv-pl-circle-wrapper,.smv-progress-loader .smv-pl-indicator{z-index:1}.smv-progress-loader .smv-pl-circle-wrapper{animation:sirv-pl-loader-rotate 2s infinite linear}.smv-progress-loader .smv-pl-indicator .smv-pl-pie,.smv-progress-loader .smv-pl-indicator .smv-pl-slice{stroke-width:2;fill:transparent}.smv-progress-loader .smv-pl-indicator .smv-pl-pie{z-index:1;stroke:rgba(255,255,255,.3)}.smv-progress-loader .smv-pl-indicator .smv-pl-slice{z-index:2;stroke:#fff;stroke-linecap:round}.smv-progress-loader .smv-pl-text-wrapper{display:inline-flex;position:relative;align-items:center;justify-content:center;font-size:12px;text-align:center;z-index:2}.smv-progress-loader .smv-pl-text-wrapper::after{display:inline-block;height:100%;content:\'\';vertical-align:middle}.smv-progress-loader .smv-pl-text-wrapper .smv-pl-text{display:inline;position:relative;color:#fff;font-weight:700}.smv-progress-loader .smv-pl-text-wrapper .smv-pl-text .smv-pl-text-percent{font-size:.7em}@keyframes sirv-pl-loader-rotate{from{transform:rotateZ(0)}to{transform:rotateZ(360deg)}}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* global RoundLoader, helper, $J, $ */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const svgNS = 'http://www.w3.org/2000/svg';

      const setDefaultOptions = options => {
        if (!options) {
          options = {};
        }

        if (!options.width) {
          options.width = 44;
        }

        if (!options.height) {
          options.height = 44;
        }

        if (!options.max) {
          options.max = 0;
        }

        return options;
      };

      const createSvg = (name, attributes) => {
        const el = $($J.D.node.createElementNS(svgNS, name));

        if (!attributes) {
          attributes = {};
        }

        Object.entries(attributes).forEach(attr => el.attr(...attr));
        return el;
      };

      const getStrokeDashoffset = (max, percent) => {
        return max - max / 100 * percent;
      };

      const getPercent = (max, value) => {
        return Math.round(100 / (max / value));
      };

      const PROGRESS = {
        START: 0,
        LOADING: 1,
        END: 2
      }; // eslint-disable-next-line no-unused-vars

      class ProgressLoader extends RoundLoader {
        constructor(parent, options) {
          options = setDefaultOptions(options);
          super(parent, options);
          this.type = 'progress';
          this.lineSize = 125;
          this.currentLineSize = 125;
          this.currentPersent = 0;
          this.currentValue = 0;
          this.progressState = PROGRESS.START;
          this.maxOpacityFlag = false;
          this.maxOpacity = 1;
          this.circles = [];
          this.size = {
            width: this.options.width,
            height: this.options.height
          };
          this.state = globalVariables.APPEARANCE.HIDDEN;

          this._createCircles();
        }

        addClass() {
          this.node.addClass('smv-progress-loader');
        }

        _createCircles() {
          this.p = '<span class="smv-pl-text-percent">%</span>';
          this.loaderElement.addClass('smv-pl-wrapper');
          this.circleWrapper = $J.$new('div').addClass('smv-pl-circle-wrapper');
          const size = this.size.width;
          const halfSize = size / 2;
          this.circles.push(createSvg('circle', {
            'class': 'smv-pl-pie',
            r: halfSize - 2,
            cx: halfSize,
            cy: halfSize
          }));
          this.circles.push(createSvg('circle', {
            'class': 'smv-pl-slice',
            r: halfSize - 2,
            cx: halfSize,
            cy: halfSize
          }));
          this.svg = createSvg('svg', {
            'class': 'smv-pl-indicator',
            viewBox: '0 0 ' + size + ' ' + size
          });
          this.circles[1].node.style.strokeDasharray = this.lineSize;
          this.circles[1].node.style.strokeDashoffset = this.lineSize;
          $(this.circles[1]).addEvent('transitionend', e => {
            e.stop();
          }).setCssProp('transition', 'stroke-dashoffset .1s linear');
          $(this.svg).append(this.circles[0]);
          $(this.svg).append(this.circles[1]);
          this.textWrapper = $J.$new('div').addClass('smv-pl-text-wrapper');
          this.text = $J.$new('span').addClass('smv-pl-text');
          this.text.changeContent(this.currentPersent + this.p);
          this.textWrapper.append(this.text);
          this.circleWrapper.append(this.svg);
          this.loaderElement.append(this.circleWrapper);
          this.loaderElement.append(this.textWrapper);
        }

        append() {
          if (this.progressState !== PROGRESS.END) {
            super.append();
          }
        }

        progress() {
          if (this.progressState !== PROGRESS.END) {
            this.progressState = PROGRESS.LOADING;
            this.currentValue += 1;
            this.currentPersent = getPercent(this.options.max, this.currentValue);
            this.currentLineSize = getStrokeDashoffset(this.lineSize, this.currentPersent);
            this.circles[1].node.style.strokeDashoffset = this.currentLineSize;
            this.text.node.innerHTML = this.currentPersent + this.p;

            if (this.currentValue === this.options.max) {
              this.progressState = PROGRESS.END;
              this.hide();
            }
          }
        }

        setMaxOpacity(opacity) {
          if (!this.maxOpacityFlag && this.loaderElement) {
            this.maxOpacity = opacity;
            this.maxOpacityFlag = true;
            this.loaderElement.setCssProp('opacity', opacity);
          }
        }

        isEnded() {
          return this.currentValue === this.options.max;
        }

        isStarted() {
          return this.currentValue > 0;
        }

        finishOff() {
          this.currentValue = this.options.max;
        }

        isShow() {
          return this.state === globalVariables.APPEARANCE.SHOWN;
        }

        show() {
          if (this.state === globalVariables.APPEARANCE.SHOWN) {
            return;
          }

          this.state = globalVariables.APPEARANCE.SHOWN;
          this.append();
          this.loaderElement.render();
          this.loaderElement.removeEvent('transitionend');
          this.loaderElement.addEvent('transitionend', e => {
            e.stop();
          });
          this.loaderElement.setCss({
            display: 'block',
            opacity: this.maxOpacity,
            transform: 'scale(1)'
          });
        }

        hide(force) {
          if (this.state === globalVariables.APPEARANCE.HIDDEN && !force || !this.inDoc) {
            return;
          }

          let countOfTransitionEvents = 0;
          this.state = globalVariables.APPEARANCE.HIDDEN;
          clearTimeout(this.timer);
          this.timer = setTimeout(() => {
            this.loaderElement.removeEvent('transitionend');
            this.loaderElement.addEvent('transitionend', e => {
              e.stop();
              countOfTransitionEvents += 1;

              if (countOfTransitionEvents < 2) {
                return;
              }

              this.loaderElement.removeEvent('transitionend');
              this.loaderElement.setCssProp('display', 'none');
            });
            this.loaderElement.setCss({
              opacity: 0,
              transform: 'scale(0)'
            });
          }, force ? 0 : 400);
        }

        getProgressState() {
          return this.progressState;
        }

        destroy() {
          this.hide(true);
          clearTimeout(this.timer);
          this.currentPersent = 0;
          this.currentValue = 0;
          this.progressState = PROGRESS.START;
          this.state = globalVariables.APPEARANCE.HIDDEN;
          this.loaderElement.removeEvent('transitionend');
          this.loaderElement.node.innerHTML = '';
          this.loaderElement = null;
          this.circleWrapper = null;
          this.textWrapper = null;
          this.circles = [];
          this.svg = null;
          this.text = null;
          this.inDoc = false;
          super.destroy();
        }

      }

      return ProgressLoader;
    });
    Sirv.define('Spin', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter', 'Zoominstance', 'ResponsiveImage', 'Hint', 'ProgressLoader', 'SpinHotspots'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter, Zoominstance, ResponsiveImage, Hint, ProgressLoader, SpinHotspots) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('Spin', () => {
        return '.sirv-spin{-ms-user-select:none!important;user-select:none!important;display:inline-block;position:relative;width:100%;max-width:100%;height:100%;padding:0!important;transform:translate3d(0,0,0);outline:0;outline:0!important;color:#000;font-size:0!important;line-height:100%!important;text-decoration:none;overflow:hidden;vertical-align:middle;visibility:visible;backface-visibility:hidden;user-select:none;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none!important}.sirv-spin::before{display:inline-block;height:0;content:\'\';vertical-align:top}.sirv-spin .spin-canvas-container{position:absolute}.sirv-spin .spin-canvas-container,.sirv-spin canvas{top:0;right:0;bottom:0;left:0;margin:auto}.sirv-spin canvas{transition:opacity 1s linear,filter 2s linear;opacity:0;z-index:1}.sirv-spin canvas.smv-shown{opacity:1!important}.sirv-spin canvas.smv-zoomed-in{visibility:hidden!important}.sirv-spin-message{display:block;position:absolute;top:50%;left:33%;width:33%;padding:6px;border:1px solid #aaa;border-radius:15px;background-color:#fff;background-image:none;color:#000;font-size:10px;text-align:center;border-collapse:separate;box-shadow:0 0 10px #000;overflow:hidden;z-index:100}.sirv-hint .spin-hint-animation{display:none;position:relative;width:40px;height:40px;margin-right:10px;transform-style:preserve-3d;vertical-align:middle;perspective:200px}.sirv-hint .sirv-hint-message .spin-hint-animation::before{display:inline-block;position:absolute;top:0;right:0;bottom:0;left:0;width:40%;height:30%;margin:auto;transform-origin:50% 50% -15px;border:1px solid #fff;box-shadow:inset 0 0 1px 1px rgba(255,255,255,.5);content:\'\';box-sizing:border-box}.sirv-hint.spin-hint-horizontal-animation .sirv-hint-message .spin-hint-animation::before{transform:translateZ(0) rotateY(0);animation:sirv-spin-hint-horizontal-rotate 3s infinite linear}@keyframes sirv-spin-hint-horizontal-rotate{0%{transform:translateZ(0) rotateY(0)}5%{transform:translateZ(100px) rotateY(0)}7%{transform:translateZ(75px) rotateY(0)}20%{transform:translateZ(75px) rotateY(0)}30%{transform:translateZ(75px) rotateY(45deg)}40%{transform:translateZ(75px) rotateY(0)}50%{transform:translateZ(75px) rotateY(-45deg)}60%{transform:translateZ(75px) rotateY(0)}63%{transform:translateZ(75px) rotateY(0)}68%{transform:translateZ(-25px) rotateY(0)}70%{transform:translateZ(0) rotateY(0)}80%{transform:translateZ(0) rotateY(0)}100%{transform:translateZ(0) rotateY(0)}}.sirv-hint.spin-hint-vertical-animation .spin-hint-message .spin-hint-animation::before{transform:translateZ(0) rotateX(0);animation:sirv-spin-hint-vertical-rotate 3s infinite linear}@keyframes sirv-spin-hint-vertical-rotate{0%{transform:translateZ(0) rotateX(0)}5%{transform:translateZ(100px) rotateX(0)}7%{transform:translateZ(75px) rotateX(0)}20%{transform:translateZ(75px) rotateX(0)}30%{transform:translateZ(75px) rotateX(45deg)}40%{transform:translateZ(75px) rotateX(0)}50%{transform:translateZ(75px) rotateX(-45deg)}60%{transform:translateZ(75px) rotateX(0)}63%{transform:translateZ(75px) rotateX(0)}68%{transform:translateZ(-25px) rotateX(0)}70%{transform:translateZ(0) rotateX(0)}80%{transform:translateZ(0) rotateX(0)}100%{transform:translateZ(0) rotateX(0)}}.sirv-hint.spin-hint-horizontal-animation.spin-hint-vertical-animation .sirv-hint-message .spin-hint-animation::before{transform:translateZ(0) rotateX(0) rotateY(0);animation:sirv-spin-hint-double-rotate 5s infinite linear}@keyframes sirv-spin-hint-double-rotate{0%{transform:translateZ(0) rotateX(0) rotateY(0)}4%{transform:translateZ(100px) rotateX(0) rotateY(0)}5%{transform:translateZ(75px) rotateX(0) rotateY(0)}10%{transform:translateZ(75px) rotateX(0) rotateY(0)}19%{transform:translateZ(75px) rotateX(0) rotateY(45deg)}28%{transform:translateZ(75px) rotateX(0) rotateY(0)}37%{transform:translateZ(75px) rotateX(0) rotateY(-45deg)}45%{transform:translateZ(75px) rotateX(0) rotateY(0)}54%{transform:translateZ(75px) rotateX(45deg) rotateY(0)}63%{transform:translateZ(75px) rotateX(0) rotateY(0)}72%{transform:translateZ(75px) rotateX(-45deg) rotateY(0)}81%{transform:translateZ(75px) rotateX(0) rotateY(0)}85%{transform:translateZ(-25px) rotateX(0) rotateY(0)}86%{transform:translateZ(0) rotateX(0) rotateY(0)}90%{transform:translateZ(0) rotateX(0) rotateY(0)}100%{transform:translateZ(0) rotateX(0) rotateY(0)}}.smv-progress-loader{bottom:0;left:0;margin-bottom:5px;margin-left:5px}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* eslint-disable no-unused-vars */

      /* eslint-disable no-extra-semi */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const defaultOptions = {
        // Swap rows and columns, i.e. "2 rows x 36 columns" spin behaves like "36 rows x 2 columns".
        swapSides: {
          type: 'boolean',
          defaults: false
        },
        wheel: {
          type: 'boolean',
          defaults: true
        },
        initialize: {
          type: 'string',
          'enum': ['load', 'hover', 'click', 'tap'],
          defaults: 'load'
        },
        freeDrag: {
          type: 'boolean',
          defaults: false
        },
        tappingFirst: {
          type: 'boolean',
          defaults: false
        },
        thumbnail: {
          // thumbnail.type
          type: {
            type: 'string',
            'enum': ['image', 'gif'],
            defaults: 'image'
          },
          // thumbnail.gifParams
          gifParams: {
            type: 'string',
            defaults: ''
          }
        },
        zoom: {
          // zoom.enable
          enable: {
            type: 'boolean',
            defaults: true
          },
          // zoom.ratio
          ratio: {
            oneOf: [{
              type: 'number',
              minimum: 0
            }, {
              type: 'string',
              'enum': ['max']
            }],
            defaults: 2.5
          },
          // zoom.tiles
          tiles: {
            type: 'boolean',
            defaults: true
          },
          // zoom.pan
          pan: {
            type: 'boolean',
            defaults: true
          }
        },
        inactivity: {
          type: 'number',
          minimum: 1000,
          defaults: 3000
        },
        autospin: {
          // autospin.enable
          enable: {
            type: 'boolean',
            defaults: false
          },
          // autospin.type
          type: {
            type: 'string',
            'enum': ['row', 'sphere', 'full', 'helix'],
            defaults: 'sphere'
          },
          // autospin.resume
          resume: {
            type: 'number',
            minimum: 0,
            defaults: 3000
          },
          // autospin.duration
          duration: {
            type: 'number',
            minimum: 0,
            defaults: 3600
          }
        },
        hint: {
          message: {
            // hint.message.enable
            enable: {
              type: 'boolean',
              defaults: true
            },
            // hint.message.text
            text: {
              type: 'string',
              defaults: 'Drag to spin'
            }
          },
          onStart: {
            // hint.onStart.enable
            enable: {
              type: 'boolean',
              defaults: true
            },
            // hint.onStart.effect
            effect: {
              oneOf: [{
                type: 'string',
                'enum': ['intro', 'twitch', 'spin', 'momentum', 'sphere', 'none']
              }, {
                type: 'boolean',
                'enum': [false]
              }],
              defaults: 'intro'
            }
          },
          onVisible: {
            // hint.onVisible.enable
            enable: {
              type: 'boolean',
              defaults: true
            },
            // hint.onVisible.effect
            effect: {
              oneOf: [{
                type: 'string',
                'enum': ['intro', 'twitch', 'spin', 'momentum', 'sphere', 'none']
              }, {
                type: 'boolean',
                'enum': [false]
              }],
              defaults: 'twitch'
            }
          },
          onInactive: {
            // hint.onInactive.enable
            enable: {
              type: 'boolean',
              defaults: true
            },
            // hint.onInactive.effect
            effect: {
              oneOf: [{
                type: 'string',
                'enum': ['intro', 'twitch', 'spin', 'momentum', 'sphere', 'none']
              }, {
                type: 'boolean',
                'enum': [false]
              }],
              defaults: 'twitch'
            }
          }
        },
        row: {
          // Row/Column from which to start spin. 'auto' means to fetch these from the image filename (img.src)
          // row.start
          start: {
            type: 'number',
            minimum: 1,
            defaults: 1
          },
          // should the spin loop rows (y)
          // row.loop
          loop: {
            type: 'boolean',
            defaults: false
          },
          // whether photos are taken in the reverse order
          // row.increment
          increment: {
            type: 'number',
            minimum: 1,
            defaults: 1
          },
          // whether photos are taken in the reverse order
          // row.reverse
          reverse: {
            type: 'boolean',
            defaults: false
          },
          //row.sensitivity
          sensitivity: {
            type: 'number',
            'minimum': 1,
            'maximum': 100,
            defaults: 50
          } // speed of spin (1 - 100)

        },
        column: {
          // Row/Column from which to start spin. 'auto' means to fetch these from the image filename (img.src)
          // col.start
          start: {
            type: 'number',
            minimum: 1,
            defaults: 1
          },
          // should the spin loop columns in row (x)
          // col.loop
          loop: {
            type: 'boolean',
            defaults: true
          },
          // whether photos are taken in the reverse order
          // col.increment
          increment: {
            type: 'number',
            minimum: 1,
            defaults: 1
          },
          // whether photos are taken in the reverse order
          // col.reverse
          reverse: {
            type: 'boolean',
            defaults: false
          },
          //column.sensitivity
          sensitivity: {
            type: 'number',
            'minimum': 1,
            'maximum': 100,
            defaults: 50
          } // speed of spin (1 - 100)

        }
      };
      const mobileDefaults = {// hint: {
        //     message: {
        //         text: { type: 'string', defaults: 'Tap to spin' }
        //     }
        // }
      };
      /* eslint-env es6 */

      /* global ResponsiveImage */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "SpinResponsiveImage" }] */

      class SpinResponsiveImage extends ResponsiveImage {
        constructor(source, o, col, row) {
          super(source, o);
          this.col = col;
          this.row = row;
        }

        _createImageData(img, callbackData) {
          const data = super._createImageData(img, callbackData);

          data.col = this.col;
          data.row = this.row;
          return data;
        }

        getThumbnail(imageSettings) {
          const data = super.getThumbnail(imageSettings);
          data.col = this.col;
          data.row = this.row;
          return data;
        }

      }
      /* eslint-env es6 */

      /* global helper */

      /* eslint operator-assignment: 0 */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "INTRO_QUEUE" }] */


      const INTRO_QUEUE = (() => {
        const CUBICBEZIER = $([0.45, 0.19, 0.56, 0.86]);
        const DEFAULTDURATION = 600;

        const isNull = v => {
          return v === null;
        };

        const getBresenhamsLine = (point1, point2) => {
          const result = {
            x: [],
            y: []
          };

          const plotLineLow = (x0, y0, x1, y1) => {
            const dx = x1 - x0;
            let dy = y1 - y0;
            let yi = 1;
            let x,
                y = y0;
            let D;

            if (dy < 0) {
              yi = -1;
              dy = -dy;
            }

            D = 2 * dy - dx;

            for (x = x0; x <= x1; x++) {
              result.x.push(x);
              result.y.push(y);

              if (D > 0) {
                y = y + yi;
                D = D - 2 * dx;
              }

              D = D + 2 * dy;
            }
          };

          const plotLineHigh = (x0, y0, x1, y1) => {
            let dx = x1 - x0;
            const dy = y1 - y0;
            let xi = 1;
            let y;
            let x = x0;
            let D;

            if (dx < 0) {
              xi = -1;
              dx = -dx;
            }

            D = 2 * dx - dy;
            x = x0;

            for (y = y0; y <= y1; y++) {
              result.x.push(x);
              result.y.push(y);

              if (D > 0) {
                x = x + xi;
                D = D - 2 * dy;
              }

              D = D + 2 * dx;
            }
          };

          if (Math.abs(point2.y - point1.y) < Math.abs(point2.x - point1.x)) {
            if (point1.x > point2.x) {
              plotLineLow(point2.x, point2.y, point1.x, point1.y);
            } else {
              plotLineLow(point1.x, point1.y, point2.x, point2.y);
            }
          } else if (point1.y > point2.y) {
            plotLineHigh(point2.x, point2.y, point1.x, point1.y);
          } else {
            plotLineHigh(point1.x, point1.y, point2.x, point2.y);
          }

          return result;
        };

        const getLineSegment = (from, to, forward, length, loop) => {
          const arr = [];
          let start = false;
          let currentIndex = from;

          while (currentIndex !== to || !start && loop) {
            start = true;

            if (forward) {
              currentIndex += 1;
            } else {
              currentIndex -= 1;
            }

            currentIndex = helper.getArrayIndex(currentIndex, length);
            arr.push(currentIndex);
          }

          return arr;
        };

        const getQueue = (source, sides) => {
          let side = 'col';

          if (isNull(sides.row)) {
            side = 'row';
          }

          const result = [];
          source.forEach(v => {
            const s = {
              col: sides.column,
              row: sides.row
            };
            s[side] = v;
            result.push(s);
          });
          return result;
        };

        const getLoopSegment = (startIndex, count, length, loop) => {
          const getEndIndex = value => {
            let result;

            if (loop) {
              result = helper.getArrayIndex(value, length);
            } else {
              result = value;

              if (result < 0) {
                result = 0;
              }

              if (result > length - 1) {
                result = length - 1;
              }
            }

            return result;
          };

          let tmp = [startIndex];
          let endIndex;
          let dir = true;
          [startIndex + count, startIndex - count, startIndex].forEach(value => {
            endIndex = getEndIndex(value);
            tmp = tmp.concat(getLineSegment(tmp[tmp.length - 1], endIndex, dir, length, loop));
            dir = !dir;
          });
          return tmp;
        };

        const getLine = (from, length, loop) => {
          let result = [];

          if (loop) {
            result = getLineSegment(from, helper.getArrayIndex(from + length, length), true, length, loop);
          } else {
            result = getLoopSegment(from, length, length, false);
          }

          return result;
        };

        const axelerate = arr => {
          const max = 6;
          const l = arr.length;

          const getCount = value => {
            return Math.round((max - 1) * $J.FX.cubicBezierAtTime(value / l, DEFAULTDURATION, CUBICBEZIER)) + 1;
          };

          const result = [];
          arr.forEach((point, index) => {
            let count = getCount(index);

            while (count > 0) {
              count -= 1;
              result.push(point);
            }
          });
          return result;
        };

        const getOptions = options => {
          const opt = helper.deepExtend({
            degree: 30,
            swapSides: false,
            axelerate: false,
            isBackward: false,
            justFirstLine: false,
            row: {
              length: 1,
              loop: false,
              current: 1,
              jumpCount: 0
            },
            column: {
              length: 36,
              loop: true,
              current: 1,
              jumpCount: 0
            },
            firstSide: 'column',
            secondSide: 'row'
          }, options || {});
          ['row', 'column'].forEach(value => {
            if (opt[value].current > opt[value].length - 1) {
              opt[value].current = 0;
            }
          });

          if (opt.swapSides) {
            opt.secondSide = opt.firstSide;
            opt.firstSide = 'row';
          }

          return opt;
        };

        const api = {
          lib: {
            getRightIndex: (index, length, loop) => {
              let result;

              if (loop) {
                result = helper.getArrayIndex(index, length);
              } else {
                if (index >= length) {
                  index = length - 1;
                } else if (index < 0) {
                  index = 0;
                }

                result = index;
              }

              return result;
            }
          },
          twitch: options => {
            const opt = getOptions(options);
            const count = {
              column: 0,
              row: 0
            };
            let tmp;
            let result = [];
            [opt.firstSide, opt.secondSide].forEach(side => {
              const otherSide = side === opt.firstSide ? opt.secondSide : opt.firstSide;

              if (opt[side].length > 1) {
                count[side] = Math.floor(opt[side].length / 360 * opt.degree) || 1;
              }

              if (count[side]) {
                tmp = {};
                tmp[side] = null;
                tmp[otherSide] = opt[otherSide].current;
                result = result.concat(getQueue(getLoopSegment(opt[side].current, count[side], opt[side].length, opt[side].loop), tmp));
              }
            });
            return result;
          },
          sphere: options => {
            const opt = getOptions(options);
            let result = [];
            (opt.justFirstLine ? [opt.firstSide] : [opt.firstSide, opt.secondSide]).forEach(side => {
              const otherSide = side === opt.firstSide ? opt.secondSide : opt.firstSide;
              const tmp = {};

              if (opt[side].length === 1) {
                return;
              }

              tmp[side] = null;
              tmp[otherSide] = opt[otherSide].current;
              const arr = getQueue(getLine(opt[side].current, opt[side].length, opt[side].loop), tmp);

              if (opt.isBackward) {
                arr.reverse();
              }

              result = result.concat(arr);
            });

            if (opt.axelerate) {
              result = axelerate(result);
            }

            return result;
          },
          intro: options => {
            const opt = getOptions(options);
            const copiedOpt = {
              swapSides: opt.swapSides,
              justFirstLine: true,
              isBackward: opt.isBackward,
              row: helper.deepExtend({}, opt.row),
              column: helper.deepExtend({}, opt.column)
            };
            let result = [];
            result = api.sphere(copiedOpt);
            result = result.concat(api.twitch(copiedOpt));
            return result;
          },
          full: options => {
            let arr;
            const opt = getOptions(options);
            const l = opt[opt.secondSide].length;

            if (l > 1) {
              arr = getLine(opt[opt.secondSide].current, l, opt[opt.secondSide].loop);
            } else {
              arr = [opt[opt.secondSide].current];
            }

            const firstSideOpt = helper.deepExtend({}, opt[opt.firstSide]);
            const secondSideOpt = helper.deepExtend({}, opt[opt.secondSide]);
            let result = [];
            arr.forEach(item => {
              const circleOption = {
                swapSides: opt.swapSides,
                justFirstLine: true
              };
              secondSideOpt.current = item;
              circleOption[opt.firstSide] = firstSideOpt;
              circleOption[opt.secondSide] = secondSideOpt;
              result = result.concat(api.sphere(circleOption));
            });

            if (opt.isBackward) {
              result.reverse();
            }

            return result;
          },
          custom: options => {
            const opt = getOptions(options);
            const point1 = {
              x: opt.column.current,
              y: opt.row.current
            };
            const point2 = {
              x: opt.column.current + opt.column.jumpCount,
              y: opt.row.current + opt.row.jumpCount
            };

            const convert = points => {
              const r = [];

              if (points.x[0] !== point1.x) {
                points.x.reverse();
              }

              if (points.y[0] !== point1.y) {
                points.y.reverse();
              }

              for (let i = 0, l = points.x.length; i < l; i++) {
                r.push({
                  col: points.x[i],
                  row: points.y[i]
                });
              }

              return r;
            };

            let result = [];
            result = getBresenhamsLine(point1, point2);
            result = convert(result);
            result = $(result).map(point => {
              return {
                col: api.lib.getRightIndex(point.col, opt.column.length, opt.column.loop),
                row: api.lib.getRightIndex(point.row, opt.row.length, opt.row.loop)
              };
            });
            return result;
          }
        };
        return api;
      })();
      /* eslint-env es6 */

      /* global helper */

      /* eslint-disable no-loop-func */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "LOADING_QUEUE" }] */


      const LOADING_QUEUE = (() => {
        const _insideLib = {
          getStep: l => {
            let result = 1;

            if (l > 24) {
              result = Math.floor(l / 24);

              if (result > 3) {
                result = 3;
              }
            }

            return result;
          },
          getIndexes: length => {
            const result = [];
            const arr = [];
            let flag = true;

            let step = _insideLib.getStep(length);

            do {
              const tmp = [];

              for (let i = 0; i < length; i += step) {
                if (!arr[i]) {
                  tmp.push(i);
                  arr[i] = 1;
                }
              }

              if (step === 1) {
                flag = false;
              }

              result.push(tmp);
              step = Math.ceil(step / 2);
            } while (step >= 1 && flag);

            return result;
          },
          // print: (arr) => {
          //     let str = '';
          //     arr.forEach((_arr, index) => {
          //         let str2;
          //         if (index < 10) {
          //             str2 = index + ' - ';
          //         } else {
          //             str2 = index + '- ';
          //         }
          //         _arr.forEach(v => {
          //             str2 += v + ' ';
          //         });
          //         str2 += '\n';
          //         str += str2;
          //     });
          //     console.log(str);
          // },
          getRightIdexes: (arr, startPos, length, callback) => {
            arr.forEach(indexOfLine => {
              const index = indexOfLine + startPos;
              const rightIndex = helper.getArrayIndex(index, length);

              if (index < length || rightIndex < startPos) {
                callback(rightIndex);
              }
            });
          },
          getOptions: options => {
            // images[row][col]

            /*
                options {
                    images: 36,
                    startRow: 0,
                    startCol: 0
                }
            */
            const opt = helper.deepExtend({}, options);
            opt.schemaOfImages = opt.images.map(line => line.map(v => 0));
            opt.rowLength = opt.images.length;
            opt.colLength = opt.images[opt.startRow].length;
            return opt;
          },
          all: (images, schema, index) => {
            const result = [];

            for (let i = 0, l = images.length; i < l; i++) {
              for (let j = 0, len = images[i].length; j < len; j++) {
                if (!schema[i][j]) {
                  result.push([i, j]);
                  schema[i][j] = index + 1;
                }
              }
            }

            return result;
          },
          getSideOpt: opt => {
            const result = {
              length: opt.colLength,
              start: opt.startCol,
              otherLength: opt.rowLength,
              otherStart: opt.startRow
            };

            if (opt.swapSides) {
              let tmp = result.length;
              result.length = result.otherLength;
              result.otherLength = tmp;
              tmp = result.start;
              result.start = result.otherStart;
              result.otherStart = tmp;
            }

            return result;
          }
        };
        const api = {
          _: _insideLib,
          all: options => {
            const result = [];

            const opt = _insideLib.getOptions(options);

            const indexesOfCols = _insideLib.getIndexes(opt.colLength);

            const tmp = [];
            const index = 1;
            opt.images.forEach((line, i) => {
              const l = line.length;

              _insideLib.getRightIdexes(indexesOfCols[0], opt.startCol, l, col => {
                const row = helper.getArrayIndex(i + opt.startRow, opt.rowLength);
                tmp.push([row, col]);
                opt.schemaOfImages[row][col] = 1;
              });
            });
            result.push(tmp);
            result.push([].concat(_insideLib.all(opt.images, opt.schemaOfImages, index))); // _insideLib.print(opt.schemaOfImages);

            return result;
          },
          fastLine: options => {
            const result = [];

            const opt = _insideLib.getOptions(options);

            const sideOpt = _insideLib.getSideOpt(opt);

            const tmp = [];
            const index = 1;

            for (let i = 0, l = sideOpt.length; i < l; i++) {
              const _i = helper.getArrayIndex(i + sideOpt.start, sideOpt.length);

              if (opt.swapSides) {
                tmp.push([_i, opt.startCol]);
                opt.schemaOfImages[_i][opt.startCol] = index;
              } else {
                tmp.push([opt.startRow, _i]);
                opt.schemaOfImages[opt.startRow][_i] = index;
              }
            }

            result.push(tmp);
            result.push([].concat(_insideLib.all(opt.images, opt.schemaOfImages, index))); // _insideLib.print(opt.schemaOfImages);

            return result;
          },
          line: options => {
            const result = [];

            const opt = _insideLib.getOptions(options);

            const sideOpt = _insideLib.getSideOpt(opt);

            const indexes = _insideLib.getIndexes(sideOpt.length);

            let tmp = [];
            let index = 1;

            _insideLib.getRightIdexes(indexes[0], sideOpt.start, sideOpt.length, i => {
              if (opt.swapSides) {
                tmp.push([i, opt.startCol]);
                opt.schemaOfImages[i][opt.startCol] = 1;
              } else {
                tmp.push([opt.startRow, i]);
                opt.schemaOfImages[opt.startRow][i] = 1;
              }
            });

            result.push(tmp);
            tmp = [];

            while (index < indexes.length) {
              if (indexes[index]) {
                _insideLib.getRightIdexes(indexes[index], sideOpt.start, sideOpt.length, i => {
                  if (opt.swapSides) {
                    tmp.push([i, opt.startCol]);
                    opt.schemaOfImages[i][opt.startCol] = index + 1;
                  } else {
                    tmp.push([opt.startRow, i]);
                    opt.schemaOfImages[opt.startRow][i] = index + 1;
                  }
                });
              }

              index += 1;
            }

            result.push(tmp.concat(_insideLib.all(opt.images, opt.schemaOfImages, index))); // _insideLib.print(opt.schemaOfImages);

            return result;
          },
          sphere: options => {
            const result = [];

            const opt = _insideLib.getOptions(options);

            const sideOpt = _insideLib.getSideOpt(opt);

            const indexes = _insideLib.getIndexes(sideOpt.length);

            const otherIndexes = _insideLib.getIndexes(sideOpt.otherLength);

            const max = Math.max(indexes.length, otherIndexes.length);
            let tmp = [];
            let index = 1;

            _insideLib.getRightIdexes(indexes[0], sideOpt.start, sideOpt.length, i => {
              if (opt.swapSides) {
                tmp.push([i, opt.startCol]);
                opt.schemaOfImages[i][opt.startCol] = 1;
              } else {
                tmp.push([opt.startRow, i]);
                opt.schemaOfImages[opt.startRow][i] = 1;
              }
            });

            _insideLib.getRightIdexes(otherIndexes[0], sideOpt.otherStart, sideOpt.otherLength, i => {
              if (opt.swapSides) {
                if (!opt.schemaOfImages[opt.startRow][i]) {
                  tmp.push([opt.startRow, i]);
                  opt.schemaOfImages[opt.startRow][i] = 1;
                }
              } else if (!opt.schemaOfImages[i][opt.startCol]) {
                tmp.push([i, opt.startCol]);
                opt.schemaOfImages[i][opt.startCol] = 1;
              }
            });

            result.push(tmp);
            tmp = [];

            while (index < max) {
              if (indexes[index]) {
                _insideLib.getRightIdexes(indexes[index], sideOpt.start, sideOpt.length, i => {
                  if (opt.swapSides) {
                    tmp.push([i, opt.startCol]);
                    opt.schemaOfImages[i][opt.startCol] = index + 1;
                  } else {
                    tmp.push([opt.startRow, i]);
                    opt.schemaOfImages[opt.startRow][i] = index + 1;
                  }
                });
              }

              if (otherIndexes[index]) {
                _insideLib.getRightIdexes(otherIndexes[index], sideOpt.otherStart, sideOpt.otherLength, i => {
                  if (opt.swapSides) {
                    tmp.push([opt.startRow, i]);
                    opt.schemaOfImages[opt.startRow][i] = index + 1;
                  } else {
                    tmp.push([i, opt.startCol]);
                    opt.schemaOfImages[i][opt.startCol] = index + 1;
                  }
                });
              }

              index += 1;
            }

            result.push(tmp.concat(_insideLib.all(opt.images, opt.schemaOfImages, index))); // _insideLib.print(opt.schemaOfImages);

            return result;
          }
        };
        return api;
      })();
      /* eslint-env es6 */

      /* global EventEmitter */

      /* global helper */

      /* global SpinResponsiveImage, INTRO_QUEUE, LOADING_QUEUE */

      /* eslint no-multi-assign: 0 */

      /* eslint operator-assignment: 0 */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "ImagesMap" }] */

      /* eslint class-methods-use-this: "off" */


      const ImagesMap = (() => {
        const getPointsString = (row, col) => {
          return row + '.' + col;
        };

        const checkIndex = (index, increment) => {
          return index % increment === 0;
        };

        const getRoot = url => {
          let result = [];
          result = $(url.split('//'));
          url = result[1];
          result = result[0];
          url = url.split('/')[0];
          result = [result, url];
          result = result.join('//');
          return result;
        };

        const getImageUrl = (absoluteURL, baseURL, imageUrl) => {
          let result;

          if (/^\//.test(imageUrl)) {
            result = absoluteURL + imageUrl;
          } else {
            result = baseURL + '/' + imageUrl;
          }

          return result;
        };

        class ImagesMap_ extends EventEmitter {
          constructor(o) {
            super();
            this.o = o;
            this._startColumn = 0;
            this._startRow = 0;
            this._currentColumn = 0;
            this._currentRow = 0;
            this.nextColumn = 0;
            this.nextRow = 0;
            this.futureColumn = 0;
            this.futureRow = 0;
            this.imgMap = [];
            this.isAvailableOfLoading = true;
            this.images = [];
            this.isStartedFullInit = false;
            this.imageInfoPromise = null;
            this.loadingMap = {
              queue: []
            };
            this.url = helper.spinLib.getUrl(this.o.url);
            this.absoluteURL = getRoot(this.url);
            this.infoImg = null;
            this.imageInfoId = 'img-' + helper.generateUUID();
            this.addEvents();
          }

          createImageInfo() {
            const getItemFromObject = () => {
              const key1 = Object.keys(this.o.layers)[0];
              const key2 = Object.keys(this.o.layers[key1])[0];
              return this.o.layers[key1][key2];
            };

            if (!this.infoImg) {
              this.infoImg = new SpinResponsiveImage(globalFunctions.normalizeURL(getImageUrl(this.absoluteURL, this.url, getItemFromObject())), {
                imageSettings: this.o.imageSettings,
                infoId: this.imageInfoId,
                round: true,
                referrerPolicy: this.o.referrerPolicy
              }, null, null);
              this.infoImg.parentClass = this;
            }

            return this.infoImg;
          }

          loadImageInfo() {
            if (!this.imageInfoPromise) {
              this.imageInfoPromise = new Promise((resolve, reject) => {
                this.createImageInfo(); // this.infoImg

                this.infoImg.loadInfo().then(info => {
                  if (this.isStartedFullInit) {
                    this.createQueue();
                  }

                  resolve({
                    size: this.infoImg.originSize
                  });
                }).catch(err => {
                  reject({
                    error: err
                  });
                });
              });
            }

            return this.imageInfoPromise;
          }

          startFullInit(o) {
            if (this.isStartedFullInit) {
              return;
            }

            this.isStartedFullInit = true;
            this.o = Object.assign(this.o, o);
            this.o.layers = helper.spinLib.checkLayers(this.o.layers);
            this.o.layers = helper.spinLib.swapLayers(this.o.layers, this.o.swapSides);
            this.imgMap = Object.values(this.o.layers).filter((row, index) => checkIndex(index, this.o.rowIncrement)).map(row => Object.values(row).filter((frame, index) => checkIndex(index, this.o.columnIncrement)).map(frame => globalFunctions.normalizeURL(getImageUrl(this.absoluteURL, this.url, frame))));
            helper.spinLib.reverse(this.o.reverseColumn, this.o.reverseRow, this.imgMap);
            this.createImages(this.imgMap);
            this.setFirstImage();

            if (this.imageInfoPromise) {
              this.infoImg.loadInfo().then(info => {
                if (!this.loadingMap.queue.length) {
                  this.createQueue();
                }
              }).catch(err => {// empty
              });
            }
          }

          setImageSettings(options) {
            if (!options) {
              options = {};
            }

            if (!options.imageSettings) {
              options.imageSettings = {};
            }

            if (!options.imageSettings.scale) {
              options.imageSettings.scale = {};
            }

            if (!options.callbackData) {
              options.callbackData = {};
            }

            options.imageSettings.scale.option = 'fill';

            if (!options.srcset) {
              options.srcset = {};
            }

            if (this.o.quality !== null) {
              if (!options.src) {
                options.src = {};
              }

              options.src = this.o.quality;
            }

            if (options.dppx >= 1.5) {
              options.srcset.quality = this.o.hdQuality;
            } else if (this.o.quality !== null) {
              options.srcset.quality = this.o.quality;
            }

            return options;
          }

          getImage(row, col) {
            let val1 = row;
            let val2 = col;

            if (!$J.defined(row)) {
              val1 = this._currentRow;
              val2 = this._currentColumn;
            }

            return this.images[val1][val2];
          }

          getThumbnail(imageOptions) {
            return this.getImage(this._startRow, this._startColumn).getThumbnail(imageOptions);
          }

          get map() {
            return this.imgMap.map(row => row.map(col => false));
          }

          addEvents() {
            let firstIsLoaded = false;
            let partIsLoaded = false;
            let allIsLoaded = false;

            const allCheck = data => {
              if (firstIsLoaded && partIsLoaded && allIsLoaded || data.lens) {
                return;
              }

              if (!firstIsLoaded && data.col === this._currentColumn && data.row === this._currentRow) {
                firstIsLoaded = true;
                this.emit('mapFirstImageLoaded', {
                  data: data
                });
              }

              if (!partIsLoaded && this.loadingMap.checkOfFirstPartImagesLoading(data.row, data.col)) {
                partIsLoaded = true;
                this.emit('mapImagesReady');
              }

              if (!allIsLoaded && this.loadingMap.checkOtherImagesLoading(data.row, data.col)) {
                allIsLoaded = true;
              }

              if (firstIsLoaded && partIsLoaded && allIsLoaded) {
                this.emit('mapAllImagesLoaded');
              }
            };

            this.on('imageOnload', e => {
              e.stopAll();

              const _data = Object.assign({
                isCurrent: this.isCurrent(e.data)
              }, e.data);

              this.emit('mapImageLoaded', {
                data: _data
              });
              allCheck(_data);
            });
            this.on('imageOnerror', e => {
              e.stopAll();
              e.data.error = true;
              this.emit('mapImageLoaded', {
                data: e.data
              });
              allCheck(e.data);
              console.log('image error');
            });
          }

          getHintType() {
            let result;
            const r = this.countOfRows;
            const c = this.countOfFrames;

            if (r > 1 && c > 1) {
              result = 'multi-row';
            } else if (r > 1) {
              result = 'col';
            } else {
              result = 'row';
            }

            return result;
          }

          isLoaded(imageOptions) {
            const img = this.getImage();
            imageOptions = this.setImageSettings(imageOptions);
            return img.isLoaded(imageOptions);
          }

          isExist(imageOptions) {
            const img = this.getImage();
            imageOptions = this.setImageSettings(imageOptions);
            return img.isExist(imageOptions);
          }

          isCurrent(position) {
            return position.row === this._currentRow && position.col === this._currentColumn;
          }

          get countOfImages() {
            return this.countOfFrames * this.countOfRows;
          }

          get countOfFrames() {
            const result = this.images[0].length || 0;
            return result;
          }

          get countOfRows() {
            const result = this.images.length;
            return result;
          }

          pixelPerFrame(width) {
            let min = width;
            const cols = this.countOfFrames;

            if (cols > 1) {
              if (!this.o.loopColumn) {
                min = min / 2;
              }

              min = min / cols;
            } else {
              min = min / this.countOfRows;
            } // eslint-disable-next-line


            min = min / Math.pow(this.o.columnSpeed / 50, 2);
            return min;
          }

          pixelPerRow(height) {
            let min = height;
            const rows = this.countOfRows;

            if (rows > 1) {
              if (!this.o.loopRow) {
                min = min / 2;
              }

              min = min / rows;
            } else {
              min = min / this.countOfFrames;
            } // eslint-disable-next-line


            min = min / Math.pow(this.o.rowSpeed / 50, 2);
            return min;
          }

          createImages(arr) {
            for (let i = 0, l = arr.length; i < l; i++) {
              const _arr = [];

              for (let j = 0, len = arr[i].length; j < len; j++) {
                const img = new SpinResponsiveImage(globalFunctions.adjustURL(arr[i][j]), {
                  imageSettings: this.o.imageSettings,
                  infoId: this.imageInfoId,
                  round: true,
                  referrerPolicy: this.o.referrerPolicy
                }, j, i);
                img.parentClass = this;

                _arr.push(img);
              }

              this.images.push(_arr);
            }
          }

          setFirstImage() {
            let sr = this.o.startRow;
            let sc = this.o.startColumn;

            if (this.o.reverseRow) {
              sr = this.images.length + 1 - sr;
            }

            if (this.o.reverseColumn) {
              sc = this.images[0].length + 1 - sc;
            }

            this._currentRow = sr - 1;
            this._currentColumn = sc - 1;

            if (this._currentRow > this.images.length - 1) {
              this._currentRow = 0;
            }

            if (this._currentColumn > this.images[0].length - 1) {
              this._currentColumn = 0;
            }

            this._startColumn = this.futureColumn = this.nextColumn = this._currentColumn;
            this._startRow = this.futureRow = this.nextRow = this._currentRow;
          }

          loadImage(imageOptions, row, col) {
            const img = this.getImage(row, col);
            imageOptions = this.setImageSettings(imageOptions);
            img.getImage(imageOptions);
          }

          loadFirstImage(imageOptions) {
            if (!this.loadingMap.queue.length) {
              return;
            }

            const point = this.loadingMap.queue[0].shift();
            this.loadImage(imageOptions, point[0], point[1]);
          }

          loadFirstPartOfImages(imageOptions) {
            if (!this.loadingMap.queue.length) {
              return;
            }

            this.loadingMap.queue[0].forEach(point => {
              this.loadImage(imageOptions, point[0], point[1]);
            });
          }

          loadOtherImages(imageOptions) {
            if (this.isAvailableOfLoading && this.loadingMap.queue.length) {
              imageOptions = this.setImageSettings(imageOptions);
              this.loadingMap.queue[1].forEach(point => {
                this.loadImage(imageOptions, point[0], point[1]);
              });
            }
          }

          loadImages(imageOptions) {
            const cc = this._currentColumn;

            if (this.isAvailableOfLoading) {
              imageOptions = this.setImageSettings(imageOptions);

              if (this.o.swapSides) {
                this.images.forEach(line => {
                  const img = line[cc];

                  if (!img.isExist(imageOptions)) {
                    img.getImage(imageOptions);
                  } else {
                    img.sendLoad(imageOptions);
                  }
                });
              } else {
                this.images.forEach(line => {
                  line.forEach(img => {
                    if (!img.isExist(imageOptions)) {
                      img.getImage(imageOptions);
                    } else {
                      img.sendLoad(imageOptions);
                    }
                  });
                });
              }
            }
          }

          isImagesExist(imageOptions) {
            imageOptions = this.setImageSettings(imageOptions);
            return !this.images.some(row => row.some(col => !col.isExist(imageOptions)));
          } // isImageExist(imageOptions) {
          //     return this.images[this._currentRow][this._currentColumn]
          //         .isExist(imageOptions.width, imageOptions.height, imageOptions.additionalImageSettings ? imageOptions.additionalImageSettings.tile : null);
          // }


          createQueue() {
            let name;

            switch (this.o.loadingSchema) {
              case 'momentum':
                name = 'fastLine';
                break;

              case 'full':
                name = 'all';
                break;

              case 'row':
              case 'spin':
                name = 'line';
                break;

              case 'sphere':
              case 'intro':
              case 'twitch':
                name = 'sphere';
                break;

              default:
                name = 'all';
            }

            this.loadingMap.queue = LOADING_QUEUE[name]({
              swapSides: this.o.swapSides,
              images: this.images,
              startRow: this._currentRow,
              startCol: this._currentColumn
            });

            this.loadingMap.checkOfFirstPartImagesLoading = (() => {
              let firstPartOfImages = [];
              this.loadingMap.queue[0].forEach(indexes => {
                firstPartOfImages.push(getPointsString(indexes[0], indexes[1]));
              });
              firstPartOfImages.shift(); // first image

              let count = firstPartOfImages.length;
              let areLoaded = false;

              if (!count) {
                areLoaded = true;
              }

              return (row, col) => {
                if (!areLoaded) {
                  if (firstPartOfImages.indexOf(getPointsString(row, col)) >= 0) {
                    count -= 1;

                    if (count === 0) {
                      firstPartOfImages = [];
                      areLoaded = true;
                    }
                  }
                }

                return areLoaded;
              };
            })();

            this.loadingMap.checkOtherImagesLoading = (() => {
              let otherImages = [];
              this.loadingMap.queue[1].forEach(indexes => {
                otherImages.push(getPointsString(indexes[0], indexes[1]));
              });
              let count;
              let areLoaded = false;
              count = otherImages.length;

              if (!count) {
                areLoaded = true;
              }

              return (row, col) => {
                if (!areLoaded) {
                  if (otherImages.indexOf(getPointsString(row, col)) >= 0) {
                    count -= 1;

                    if (count === 0) {
                      otherImages = [];
                      areLoaded = true;
                    }
                  }
                }

                return areLoaded;
              };
            })();
          }

          prepareFutureImage(direction, count) {
            if (!count) {
              count = 1;
            }

            let index;
            let length;
            let loop;

            if (['next', 'prev'].includes(direction)) {
              loop = this.o.loopColumn;
              index = this.futureColumn;
              length = this.countOfFrames;

              if (direction === 'next') {
                index += count;
              } else {
                index -= count;
              }

              this.futureColumn = INTRO_QUEUE.lib.getRightIndex(index, length, loop);
            } else {
              loop = this.o.loopRow;
              index = this.futureRow;
              length = this.countOfRows;

              if (direction === 'down') {
                index += count;
              } else {
                index -= count;
              } // loop = false;


              this.futureRow = INTRO_QUEUE.lib.getRightIndex(index, length, loop);
            }
          }

          setPreparedNextImage() {
            this.futureColumn = this._currentColumn = this.nextColumn;
            this.futureRow = this._currentRow = this.nextRow;
            this.emit('frameChange', {
              data: {
                column: this._currentColumn,
                row: this._currentRow
              }
            });
          }

          setPreparedFutureImage() {
            const img = this.getImage(this.futureRow, this.futureColumn);

            if (img && img.ready) {
              this._currentColumn = this.futureColumn;
              this._currentRow = this.futureRow;
              this.emit('frameChange', {
                data: {
                  column: this._currentColumn,
                  row: this._currentRow
                }
              });
            }
          }

          resetPreparedImage() {
            this.futureColumn = this.nextColumn = this._currentColumn;
            this.futureRow = this.nextRow = this._currentRow;
          }

          getCurrentImage(imageOptions) {
            imageOptions = this.setImageSettings(imageOptions);
            const c = this._currentColumn;
            const r = this._currentRow;
            let img = this.getImage(r, c);
            img = img.getImage(imageOptions);
            return img;
          }

          get originImageUrl() {
            const c = this._currentColumn;
            const r = this._currentRow;
            let url = this.getImage(r, c);
            url = url.originUrl;
            return url;
          }

          jump(axis, value
          /* count or index */
          , direction) {
            let result = false;
            let row;
            let col;

            const checkImg = (r, c) => {
              let res = false;

              if (this.getImage(r, c).ready) {
                this.nextRow = r;
                this.nextColumn = col;
                this.setPreparedNextImage();
                res = true;
              }

              return res;
            };

            switch (axis) {
              case 'row':
                row = helper.spinLib.getNextIndex(this._currentRow, value, direction, this.countOfRows, this.o.loopRow);
                col = this._currentColumn;
                result = checkImg(row, col);
                break;

              case 'col':
                col = helper.spinLib.getNextIndex(this._currentColumn, value, direction, this.countOfFrames, this.o.loopColumn);
                row = this._currentRow;
                result = checkImg(row, col);
                break;
              // no default
            }

            return result;
          }

          setNextAnimationFrame(index) {
            const point = this._imagesBuffer[index];
            const img = this.getImage(point.row, point.col);

            if (img && img.ready) {
              this.nextColumn = point.col;
              this.nextRow = point.row;
            }
          }

          getNextBufferIndex(fromIndex) {
            let count = 0;
            const l = this._imagesBuffer.length;

            const check = point => {
              const img = this.getImage(point.row, point.col);
              let result = false;

              if (img && img.ready) {
                result = true;
              }

              return result;
            };

            let point;

            do {
              count += 1;
              fromIndex += 1;

              if (fromIndex >= l) {
                count = 0;
              } else {
                point = this._imagesBuffer[fromIndex];
              }
            } while (count > 0 && (!point || !check(point)));

            return count;
          }

          createAnimation(typeOfBuffer, isBackward) {
            let jfl = false;
            let a = false;
            let cols = 0;
            let rows = 0;

            switch (typeOfBuffer) {
              case 'as-row':
                typeOfBuffer = 'sphere';
                jfl = true;
                break;

              case 'as-sphere':
                typeOfBuffer = 'sphere';
                break;

              case 'as-full':
                typeOfBuffer = 'full';
                break;

              case 'as-helix':
                // TODO do the effect
                typeOfBuffer = 'sphere';
                break;

              case 'intro':
                typeOfBuffer = 'intro';
                jfl = true;
                break;

              case 'twitch':
                typeOfBuffer = 'twitch';
                break;

              case 'spin':
                typeOfBuffer = 'sphere';
                jfl = true;
                break;

              case 'momentum':
                typeOfBuffer = 'sphere';
                jfl = true;
                a = true;
                break;

              case 'sphere':
                typeOfBuffer = 'sphere';
                break;

              default:
                cols = typeOfBuffer.cols;
                rows = typeOfBuffer.rows;
                typeOfBuffer = 'custom';
            }

            this._imagesBuffer = INTRO_QUEUE[typeOfBuffer]({
              justFirstLine: jfl,
              swapSides: this.o.swapSides,
              axelerate: a,
              isBackward: isBackward,
              count: typeOfBuffer,
              row: {
                length: this.countOfRows,
                loop: this.o.loopRow,
                current: this._currentRow,
                jumpCount: rows
              },
              column: {
                length: this.countOfFrames,
                loop: this.o.loopColumn,
                current: this._currentColumn,
                jumpCount: cols
              }
            });
            return this._imagesBuffer.length;
          }

          clearFramesQueue() {
            this._imagesBuffer = [];
          }

          cancelLoadingImage(imageOptions) {
            const img = this.getImage();

            if (img) {
              imageOptions = this.setImageSettings(imageOptions);
              img.cancelLoadingImage(imageOptions);
            }
          }

          get startRow() {
            return this._startRow;
          }

          get startColumn() {
            return this._startColumn;
          }

          get currentRow() {
            return this._currentRow;
          }

          get currentColumn() {
            return this._currentColumn;
          }

          get imagesBuffer() {
            return this._imagesBuffer;
          }

          destroy(last) {
            this.isAvailableOfLoading = false;
            this.resetPreparedImage();
            this.clearFramesQueue();
            this.images.forEach(row => {
              row.forEach(frame => {
                frame.destroy();
              });
            });
            this.off('imageOnload');
            this.off('imageOnerror');
            this.loadingMap = {
              queue: []
            };
            this.imgMap = [];
            this.images = $([]);
            this._currentColumn = 0;
            this._currentRow = 0;
            super.destroy();
          }

        }

        return ImagesMap_;
      })();
      /* eslint-env es6 */

      /* global defaultOptions, ImagesMap, SpinHotspots, Animation, Zoominstance, helper, ResponsiveImage, ProgressLoader, Hint, $J, globalFunctions, globalVariables */

      /* eslint-disable indent */

      /* eslint-disable no-lonely-if */

      /* eslint-disable class-methods-use-this */

      /* eslint operator-assignment: 0 */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Spin" }] */


      const SPIN_CONF_VER = 1;
      const P = 'smv';
      const CSS_CLASS_NAME = P + '-spin';
      const BRAND_LANDING = 'https://sirv.com/about-spin/?utm_source=client&utm_medium=sirvembed&utm_content=typeofembed(spin)&utm_campaign=branding'; // const calcScalePosition = (scale, size) => {
      //     return (size - size * scale) / 2;
      // };

      class ActivatedCurtain {
        constructor(parentNode, activeNode) {
          this.parentNode = parentNode;
          this.activeNode = activeNode;
          this.activatedCurtain = $J.$new('div').addClass('spin-activated-curtain').setCss({
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            position: 'absolute',
            'z-index': 999999999
          });
          this.state = 0; // 0 - deactivated, 1 - activated
        }

        show() {
          if (this.state) {
            this.activatedCurtain.setCssProp('display', 'block');
            this.activeNode.addClass(P + '-activated');
          }
        }

        hide() {
          if (this.state) {
            this.activatedCurtain.setCssProp('display', 'none');
            this.activeNode.removeClass(P + '-activated');
          }
        }

        activateCurtain() {
          if (!this.state) {
            this.state = 1;
            this.activeNode.addClass(P + '-sleeping');
            this.parentNode.append(this.activatedCurtain);
          }
        }

        deactivateCurtain() {
          if (this.state) {
            this.state = 0;
            this.activeNode.removeClass(P + '-sleeping');
            this.activatedCurtain.remove();
          }
        }

        addTapEvents(callback) {
          this.activatedCurtain.addEvent('tap', e => {
            if (this.state) {
              e.action = 'activate';
              callback(e);
            }
          });
          this.activeNode.addEvent('tap', e => {
            if (this.state) {
              e.action = 'deactivate';
              callback(e);
            }
          });
        }

        addPinchEvent(handler) {
          this.activeNode.addEvent('pinch', handler);
        }

        removePinchEvent(handler) {
          this.activeNode.removeEvent('pinch', handler);
        }

        destroy() {
          this.state = 1;
          this.hide();
          this.deactivateCurtain();
          this.removePinchEvent();
          this.activeNode.removeEvent('tap');
          this.activatedCurtain.remove();
          this.activatedCurtain.removeEvent('tap');
          this.activatedCurtain = null;
        }

      }

      const checkProps = obj => {
        if (!obj.common) {
          obj.common = {};
        }

        if (!obj.common.common) {
          obj.common.common = {};
        }

        if (!obj.common.mobile) {
          obj.common.mobile = {};
        }

        if (!obj.local) {
          obj.local = {};
        }

        if (!obj.local.common) {
          obj.local.common = '';
        }

        if (!obj.local.mobile) {
          obj.local.mobile = '';
        }

        return obj;
      };

      const fnStopTouchMove = e => {
        e.stopDefaults();
      };

      class Spin extends Zoominstance {
        constructor(node, options) {
          super(node, options, defaultOptions);
          this.type = globalVariables.SLIDE.TYPES.SPIN; // this.instanceOptions = this.makeOptions();

          this.canvas = null;
          this.canvasContainer = $J.$new('div').addClass('spin-canvas-container');
          this.coreNode = $J.$new('div').addClass('sirv-spin');
          this.instanceNode.append(this.coreNode); // this.additionalCanvases = [];

          this.ctx = null;
          this.isSmoothing = false;
          this.smooseTimeout = null;
          this.minSizeOfFrame = 0;
          this.minSizeOfRow = 0;
          this.size = {
            width: 0,
            height: 0
          };
          this.isDragMove = false;
          this.longTapTimer = false;
          this.imagesMap = null;
          this.isInited = false;
          this.loader = null;
          this.hint = null;
          this.openedImg = null;
          this.scale = 1;
          this.cssId = -1;
          this.boxBoundaries = null;
          this.hotspots = null;
          this.animationFX = null;
          this.loadedImages = [];
          this.currentSize = {
            width: 0,
            height: 0
          };
          this.currentImageSize = {
            width: 0,
            height: 0
          };
          this.standardSize = {
            width: 0,
            height: 0
          };
          this.lastImg = null;
          this.startLoadingTime = null;
          this.isOver = false;
          this.isSpinActivated = !$J.browser.mobile;
          this.canvasPromise = null;
          this.firstImageLoaded = false;
          this.firstPartOfImagesLoaded = false;
          this.isInfoLoaded = false;
          this.customActionWas = false;
          this.isAutoplayPaused = false; // the variable is inside option which is hidden

          this.reflectDirection = false;
          this.configURL = this.instanceNode.attr('data-src') || this.instanceNode.attr('data-config') || '';
          this.imageBaseURL = globalFunctions.normalizeURL(this.configURL.replace(/([^#?]+)\/.*$/, '$1/'));
          this.absoluteURL = this.imageBaseURL.replace(/(^https?:\/\/[^/]*).*/, '$1/');
          this.configHash = $J.getHashCode(this.configURL.replace(/^http(s)?:\/\//, ''));
          this.configPath = '/' + this.configURL.replace(this.absoluteURL, '');
          this.imageInfoCallbackName = 'sirv_spin_image_info_';
          this.sessionId = $J.getHashCode(this.configURL.replace(/^http(s)?:\/\//, '') + $J.D.node.location.href.replace(/^http(s)?:\/\//, '') + +new Date());
          this.layers = {};
          this.imageSettings = {};
          this.hotspotsData = [];
          this.fullscreenStartTime = 0;
          this.meta = {};
          this.isFullscreen = options.isFullscreen;
          this.nativeFullscreen = options.nativeFullscreen;
          this.infoSettings = {};
          this.autospinResumeTimer = null;
          this.isHidden = false;
          this.sessionStartTime = 0;
          this.animationCloud = null;
          this.touchDragCloud = null;
          this.slideDragEventStart = false;
          this.dppx = null;
          this.startTimeForZommEvent = null;
          this.resizeAnimationTimer = helper.debounce(() => {
            this.animate('inactive');
          }, 1000);
          this.keyPressHandlerForShiftButton = null;
          this.firstUserInteraction = false;
          this.userColumn = 0;
          this.userRow = 0;
          this.placeholder = this.instanceNode.node.querySelector('img');

          if (this.placeholder) {
            this.placeholder = $(this.placeholder);
          }

          this.replaceTextParamURLFromMetadata();

          this.trackUnload = () => {
            this.sendStats('Page Unload', +new Date() - this.sessionStartTime, {
              message: 'Stopped'
            }, true);
          }; // Handle window resize to prevent page dragging on mobile devices when spin fills the entire page.


          this.disableScrollOnMobile = () => {
            const docFullSize = $J.D.fullSize;
            const placeholderSize = this.instanceNode.size;

            if (Math.abs(placeholderSize.height - docFullSize.height) <= 50) {
              this.instanceNode.addEvent('touchmove', fnStopTouchMove);
            } else {
              this.instanceNode.removeEvent('touchmove', fnStopTouchMove);
            }
          };

          this.resizeWindowTimer = null;

          this.windowResizeCallback = () => {
            clearTimeout(this.resizeWindowTimer);
            this.resizeWindowTimer = setTimeout(() => {
              this.disableScrollOnMobile();
            }, 10);
          };

          this.api = Object.assign(this.api, {
            isInitialized: this.isInitialized.bind(this),
            // new
            play: this.play.bind(this),
            pause: this.pause.bind(this),
            rotate: this.rotateXY.bind(this),
            rotateX: this.rotateX.bind(this),
            rotateY: this.rotateY.bind(this),
            jump: this.jump.bind(this),
            jumpRows: this.jumpRows.bind(this),
            // new
            jumpCols: this.jumpCols.bind(this),
            // new
            // resize: this.resize.bind(this), // parent class
            // zoomIn: this.zoomIn.bind(this), // parent class
            // zoomOut: this.zoomOut.bind(this), // parent class
            // isZoomed: this.isZoomed.bind(this), // new, parent class
            // isReady: this.isReady.bind(this), // parent class
            // getOptions: this.getOptions.bind(this), // parent class
            // hotspots: {}, // parent class, hotspots api
            currentFrame: this.currentFrame.bind(this)
          });
          this.createHotspotsClass(SpinHotspots);
          this.getInfo().then(() => {
            if ($J.browser.mobile && this.option('tappingFirst')) {
              this.activatedCurtain = new ActivatedCurtain(this.instanceNode, this.coreNode);
            } else {
              this.isSpinActivated = true;
            }

            this.createMap(this.quality, this.hdQuality, this.isHDQualitySet);
          }).catch(e => {});
        } // API


        isInitialized() {
          return this.isInited;
        } // API


        rotateXY(x, y) {
          if (this.ready && !this.isZoomed()) {
            return this.rotate(x, y);
          }

          return false;
        } // API


        rotateX(frames) {
          if (this.ready && !this.isZoomed()) {
            return this.rotate(frames, null);
          }

          return false;
        } // API


        rotateY(frames) {
          if (this.ready && !this.isZoomed()) {
            return this.rotate(null, frames);
          }

          return false;
        }
        /**
         * Jump up/down by certain number of rows
         * @param  {int} rows Number of rows to jump
         * @return
         */
        // API


        jump(rows) {
          return this.jumpRows(rows);
        } // API


        jumpRows(frame) {
          if (this.ready && !this.isZoomed()) {
            return this.jumpTo(frame, 'row');
          }

          return false;
        } // API


        jumpCols(frame) {
          if (this.ready && !this.isZoomed()) {
            return this.jumpTo(frame, 'col');
          }

          return false;
        }
        /**
         * Retrieve current visible frame
         * @return
         */
        // API


        currentFrame() {
          if (this.ready) {
            return this.getCurrentFrame();
          }

          return null;
        } // API


        isActive() {
          return this.isSpinActivated;
        }

        makeGlobalOptions(optionsInstance) {
          const o = this._options.options;
          optionsInstance.fromJSON(o.common.common);

          if (this.infoSettings) {
            Object.entries(this.infoSettings).forEach(infoSetting => {
              if (!['images', 'hotspots'].includes(infoSetting[0])) {
                optionsInstance.set(...infoSetting);
              }
            });
          }

          optionsInstance.fromString(o.local.common);
          optionsInstance.fromString(this.instanceNode.attr('data-options') || '');
          return optionsInstance;
        }

        makeOptions() {
          this._options.options = checkProps(this._options.options);
          return super.makeOptions();
        }

        sendStats(name, time, additionalData, useBeacon) {
          const data = {
            account: this.config.account,
            useBeacon: !!useBeacon,
            event: name,
            eventTime: time,
            sessionId: this.sessionId,
            origin: this.configPath
          };

          if (additionalData) {
            data.data = additionalData;
          }

          this.emit('stats', {
            data: data
          });
        }

        getInfo() {
          if (!this.gettingInfoPromise) {
            this.gettingInfoPromise = new Promise((resolve, reject) => {
              this.waitGettingInfo.wait(() => {
                const cfCallbackName = 'sirv_spin_info_v' + SPIN_CONF_VER + '_' + this.configHash;
                const url = this.configURL + ($J.stringHas(this.configURL, '?') ? '&' : '?') + 'info=' + cfCallbackName;
                helper.getRemoteData(url, cfCallbackName, this.referrerPolicy).then(config => {
                  if (!this.destroyed) {
                    if (config.layers) {
                      this.config = config;
                      this.layers = this.config.layers;
                      this.meta = this.config._file.meta || null;
                      this.infoSettings = this.config.settings;
                      this.hotspotsData = this.config.settings.hotspots || [];
                      this.imageSettings = this.config.settings.images.main;
                      this.accountInfo = {
                        account: this.config.account,
                        branded: this.config.branded
                      };
                      this.sessionStartTime = +new Date();
                      this.sendStats('sessionStart', this.sessionStartTime);
                      $J.W.addEvent('beforeunload', this.trackUnload);
                      resolve();
                    } else if (config.contentType && /image/.test(config.contentType) || config._isplaceholder) {
                      reject({
                        error: 'changeSpinToImage',
                        isPlaceholder: config._isplaceholder,
                        account: config.account
                      });
                    } else {
                      reject({
                        error: {
                          status: 404
                        }
                      });
                    }
                  }
                }).catch(err => {
                  if (!this.destroyed) {
                    reject({
                      error: err
                    });
                  }
                });
              });
            });
          }

          return this.gettingInfoPromise;
        }

        replaceTextParamURLFromMetadata() {
          if (this.imageSettings.text && this.imageSettings.text.text) {
            this.imageSettings.text.text = this.imageSettings.text.text.replace(/\$\{spin\.(title|description)\}/g, (m, p1) => {
              const t = this.meta[p1] || '';

              if (typeof t === 'string') {
                return t;
              }

              return p1;
            });

            if (this.imageSettings.text.text === '') {
              delete this.imageSettings.text;
            }
          }
        }

        getDPPX(size) {
          const side = size.height > size.width ? 'height' : 'width';
          const tmp = {};
          tmp[side] = size[side];
          this.dppx = helper.getDPPX(ResponsiveImage.roundImageSize(tmp)[side], this.infoSize[side], this.upscale);
        }

        showHint() {
          let result = false;

          if (this.hint) {
            if ((!this.always || [globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState)) && (!this.option('autospin.enable') || !this.firstUserInteraction) // do not show hint again after first user interaction if the autospin.enable is true
            ) {
                result = true;
                this.hint.show();
              }
          }

          return result;
        }

        onStartActions() {
          if (this.ready) {
            this.animate('slideIn');
          } else {
            if (this.isStarted) {
              if (this.isInited && !this.initNameEvent) {
                this.loadFirstPartOfImages();
              } else {
                // if (this.isInView || this.preload) {
                if (this.isInView) {
                  this.loadFirstImage();
                }
              }
            }
          }
        }

        onStopActions() {
          this.zoomOut();
          this.stopSmoothing();
          this.stopAnimation();
          this.deactivateSpin();
          this.setUserFrame();
          this.customActionWas = false;

          if (this.hint) {
            this.hint.hide();
          }

          super.onStopActions();
        }

        onInView(value) {
          if (value) {
            if (!this.isInView) {
              if (this.ready) {
                this.isInView = true;
                this.animate('inView');
              } else {
                if (this.preload || this.isSlideShown) {
                  this.isInView = true;

                  if (this.isInited) {
                    if (this.isSlideShown && !this.initNameEvent) {
                      this.loadFirstPartOfImages();
                    }
                  } else {
                    this.loadFirstImage();
                  }
                }
              }
            }
          } else {
            if (this.isInView && this.ready) {
              if (this.option('autospin.enable')) {
                this.animationCloud.pause();
              } else {
                this.stopAnimation();
                this.setUserFrame();
              }

              this.deactivateSpin();
            }
          }
        }

        startFullInit(options) {
          if (this.isStartedFullInit) {
            return;
          } // if (options) {
          //     this.instanceOptions = options.options;
          //     options.options = this.makeOptions();
          // }


          super.startFullInit(options);
          this.getInfo().then(() => {
            this.normalizeOptions();
            this.getId('spin-');
            const option = this.option;
            this.imagesMap.startFullInit({
              swapSides: option('swapSides'),
              startColumn: option('column.start'),
              startRow: option('row.start'),
              reverseColumn: option('column.reverse'),
              reverseRow: option('row.reverse'),
              loopColumn: option('column.loop'),
              loopRow: option('row.loop'),
              rowSpeed: option('row.sensitivity'),
              columnSpeed: option('column.sensitivity'),
              columnIncrement: option('column.increment'),
              rowIncrement: option('row.increment')
            });
            this.loadedImages = this.imagesMap.map;
            this.loader = new ProgressLoader(this.coreNode, {
              max: this.imagesMap.countOfImages,
              'class': 'spin-loader'
            });
            this.loader.parentClass = this;
            this.coreNode.addEvent(['btnclick', 'tap'], e => {
              e.stop();
            });
            this.on('isSingleSlide', e => {
              e.stop();

              if (this.activatedCurtain) {
                if (e.data.isSingle) {
                  this.activatedCurtain.deactivateCurtain();
                } else {
                  this.activatedCurtain.activateCurtain();
                }
              }
            });

            if (this.hotspots) {
              this.hotspots.Options = {
                columnsRevers: this.option('column.reverse'),
                rowsRevers: this.option('row.reverse'),
                rows: this.imagesMap.countOfRows,
                columns: this.imagesMap.countOfFrames
              };
            }

            this.initAnimation();
          }).catch(() => {});

          if ($J.browser.touchScreen) {
            this.on('dragEvent', e => {
              if (e.data.type === 'dragstart') {
                this.slideDragEventStart = true;

                if (this.touchDragCloud) {
                  this.touchDragCloud.removeEvent();
                }
              } else if (e.data.type === 'dragend') {
                this.slideDragEventStart = false;

                if (this.touchDragCloud) {
                  this.touchDragCloud.addEvent();
                }
              }
            });
          }
        }

        getThumbnailData(opt) {
          return this.imagesMap.getThumbnail(opt);
        }

        setUserFrame() {
          this.jumpTo(this.userRow, 'row');
          this.jumpTo(this.userColumn, 'col');
        }

        getSocialButtonData(data, isSpin) {
          let url = null;

          if (isSpin) {
            url = this.instanceNode.attr('data-src');
          } else {
            url = super.getSocialButtonData(data);
          }

          return url;
        }

        turnOnOff() {
          if (!$J.browser.mobile || !this.activatedCurtain) {
            return;
          }

          this.activatedCurtain.addTapEvents(e => {
            if (e.action === 'activate') {
              if (!this.isSpinActivated) {
                e.stop();
                this.activateSpin();
              }

              if (this.hotspots) {
                this.hotspots.hideActiveHotspotBox(true);
              }
            } else {
              if (this.isSpinActivated) {
                e.stop();
                this.stopSmoothing();
                this.stopAnimation();

                if (this.hotspots && this.hotspots.isHotspotActivated()) {
                  this.hotspots.hideActiveHotspotBox(true);
                } else {
                  this.deactivateSpin();
                }
              }
            }
          });
        }

        activateSpin() {
          if (!this.isSpinActivated) {
            this.isSpinActivated = true;

            if ($J.browser.mobile) {
              this.stopAnimation();
              this.customActionWas = true;

              if (this.hint) {
                this.hint.hide();
              }

              if (this.activatedCurtain) {
                this.activatedCurtain.hide();
              }
            }
          }
        }

        deactivateSpin() {
          if (this.isSpinActivated) {
            this.isSpinActivated = false;

            if ($J.browser.mobile) {
              if (!this.customActionWas) {
                this.showHint();
              }

              if (this.activatedCurtain) {
                this.activatedCurtain.show();
              } // this.customActionWas = false;
              // this.animate('inactive');

            }
          }
        } // setActiveAction() {
        //     if ($J.browser.mobile) { return; }
        //     this.canvasContainer.addEvent('mouseover', e => {
        //         if (this.isSlideShown) {
        //             this.isOver = true;
        //             if (this.ready) {
        //                 this.activateSpin();
        //             }
        //         }
        //     });
        //     this.canvasContainer.addEvent('mouseout', e => {
        //         if (this.isSlideShown) {
        //             this.isOver = false;
        //             this.deactivateSpin();
        //         }
        //     });
        // }


        createPinchEvent() {
          // difference between scale
          const OPEN_ZOOM = 1.1;
          const FS_OUT = 0.2;
          const FS_IN = 2;
          let saveValue;
          let scale;
          let baseMin;
          let compensation;
          let maxCompensation;
          let minCompensation;
          let max;
          let min;
          let basePercent;

          const setDefaultsValues = () => {
            maxCompensation = 1;
            minCompensation = 1;
            baseMin = this.zoom.baseScale.x;
            max = 1;
            min = baseMin;
            saveValue = 1 - baseMin;
          };

          super.createPinchEvent(this.coreNode);

          this.pinchCloud.onPinchStart = e => {
            if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
              return;
            }

            this.pinchCloud.pinch = true;
            clearTimeout(this.longTapTimer);
            this.stopSmoothing();
            this.stopAnimation();

            if (this.touchDragCloud) {
              this.touchDragCloud.removeEvent();
            }

            if (this.hotspots) {
              this.hotspots.hideActiveHotspotBox(true);
            }

            this.customActionWas = true;
            basePercent = false;
            this.pinchCloud.scale = e.scale;
            compensation = 1;

            if (this.openedImg) {
              compensation = this.zoom.scale.x;

              if (baseMin === $J.U) {
                setDefaultsValues();
              }

              compensation /= baseMin;
            }

            this.sendEvent('pinchStart');
          };

          this.pinchCloud.onPinchResize = e => {
            if (this.pinchCloud.pinch && !this.pinchCloud.block) {
              if (this.zoom && this.fullscreenState === globalVariables.FULLSCREEN.OPENED && this.openedImg) {
                this.pinchCloud.scale = e.scale;
                this.zoom.basePercent = e.centerPoint;
              }
            }
          };

          this.pinchCloud.onPinchMove = e => {
            if (this.pinchCloud.pinch && !this.pinchCloud.block) {
              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.isFullscreenEnabled) {
                if (!this.openedImg) {
                  if (e.scale > OPEN_ZOOM) {
                    this.firstUserInteraction = true;
                    this.openLens(e.centerPoint.x, e.centerPoint.y, false, 'zero');
                    setDefaultsValues();
                    compensation = 1;
                  } else if (e.scale < FS_OUT) {
                    this.pinchCloud.block = true;
                    this.sendEvent('fullscreenOut');
                  }
                } else if (this.zoom) {
                  if (!basePercent) {
                    basePercent = true;
                    this.zoom.basePercent = e.centerPoint;
                  } else {
                    scale = e.scale;
                    scale *= baseMin;

                    if (max < scale) {
                      max = scale;
                      min = baseMin;
                      minCompensation = 1;
                      maxCompensation = saveValue / (max - baseMin);
                    }

                    if (min > scale) {
                      min = scale;
                      max = 1;
                      maxCompensation = 1;
                      minCompensation = baseMin / min;
                    }

                    scale *= compensation;
                    scale = (baseMin + (scale - baseMin) * maxCompensation) * minCompensation;
                    this.zoom.setScale(scale, e.centerPoint.x, e.centerPoint.y);
                  }

                  this.pinchCloud.scale = e.scale;
                }
              } else if (e.scale >= FS_IN) {
                this.pinchCloud.block = true;
                this.sendEvent('fullscreenIn');
              }
            }
          };

          this.pinchCloud.onPinchEnd = e => {
            if (this.pinchCloud.pinch) {
              this.pinchCloud.pinch = false;

              if (this.openedImg) {
                this.activateSpin();
              }

              setTimeout(() => {
                if (this.touchDragCloud) {
                  this.touchDragCloud.addEvent();
                }
              }, 16);
              this.sendEvent('pinchEnd');
            }

            if (this.openedImg) {
              this.pinchCloud.removeEvent();
            }

            this.pinchCloud.block = false;
            this.pinchCloud.scale = 0;
          };
        }

        onStopContext() {
          this.stopSmoothing();
          this.stopAnimation();

          if (this.hint) {
            this.hint.hide();
          }
        }

        onSecondSelectorClick() {
          this.zoomOut();
        }

        setGlobalEvents() {
          this.on('zoomUp', e => {
            const pos = e.data;
            e.stop();

            if (this.ready && this.zoom) {
              if (!this.isDragMove && this.isFullscreenActionEnded()) {
                this.firstUserInteraction = true;
                this.openLens(pos.x, pos.y);
              }
            }
          });
          this.on('zoomDown', e => {
            e.stop();

            if (this.ready && this.zoom && this.isZoomed()) {
              this.zoom.hide();
            }
          });
        }

        normalizeOptions() {
          if (!this.option('autospin.enable')) {
            this.option('autospin.duration', 0);
          }

          if (this.option('swapSides')) {
            ['start', 'loop', 'increment', 'reverse', 'sensitivity'].forEach(param => {
              const tmp = this.option('row.' + param);
              this.option('row.' + param, this.option('column.' + param));
              this.option('column.' + param, tmp);
            });
          }

          ['onStart', 'onVisible', 'onInactive'].forEach(v => {
            const o = 'hint.' + v + '.effect';

            if (this.option(o) === 'none') {
              this.option(o, false);
            }
          });

          if ($J.browser.mobile) {
            if (this.option('initialize') !== 'load') {
              this.option('initialize', 'tap');
            }
          }

          this.setDefaultZoomOptions();

          if (this.option('zoom.enable') && this.option('zoom.ratio') !== 'max' && this.option('zoom.ratio') < globalVariables.MIN_RATIO) {
            this.option('zoom.enable', false);
          }
        }

        setDefaultZoomOptions() {
          super.setDefaultZoomOptions();
          this.defaultZoomOptions = Object.assign(this.defaultZoomOptions, {
            tiles: this.option('zoom.tiles'),
            pan: this.option('zoom.pan'),
            trigger: $J.browser.mobile ? 'dblclick' : 'click',
            type: 'inner',
            height: 'auto'
          });
        }

        loadFirstPartOfImages() {
          if (!this.firstPartOfImagesLoaded) {
            this.firstPartOfImagesLoaded = true;
            this.startLoadingTime = +new Date();
            this.imagesMap.loadFirstPartOfImages({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height,
              dppx: this.dppx
            });

            if (this.loader) {
              this.loader.show();
            }
          }
        }

        isThumbnailGif() {
          return this.option('thumbnail.type') === 'gif';
        }

        init() {
          if (!this.infoSize || this.isInited) {
            return;
          }

          this.isInited = true; // this.setActiveAction();

          this.initNameEvent = null;

          this.initFnEvent = e => {
            e.stop();
            this.coreNode.removeEvent(e.type, this.initFnEvent);

            if (this.activatedCurtain) {
              this.activatedCurtain.activatedCurtain.removeEvent(this.initNameEvent, this.initFnEvent);
            }

            this.loadFirstPartOfImages();
          };

          switch (this.option('initialize')) {
            case 'hover':
              this.initNameEvent = 'mouseover';
              break;

            case 'click':
              this.initNameEvent = 'btnclick';
              break;

            case 'tap':
              this.initNameEvent = 'tap';
              break;

            default:
          }

          if (this.initNameEvent) {
            this.coreNode.addEvent(this.initNameEvent, this.initFnEvent);

            if (this.activatedCurtain) {
              this.activatedCurtain.activatedCurtain.addEvent(this.initNameEvent, this.initFnEvent);
            }

            this.loadFirstImage();
          } else {
            if (this.isInView && this.isSlideShown) {
              this.loadFirstPartOfImages();
            }
          }

          this.sendEvent('init');
        }

        run(isShown, preload, firstSlideAhead) {
          const result = super.run(isShown, preload, firstSlideAhead);

          if (result) {
            $J.W.addEvent('resize', this.windowResizeCallback);
            this.initCanvas();
            this.startGettingInfo();
          }

          return result;
        }

        initCanvas() {
          this.canvas = $J.$new('canvas');

          if (this.canvas.node.getContext) {
            this.ctx = this.canvas.node.getContext('2d'); // for (let i = 0; i < 2; i++) {
            //     const canvas = $J.$new('canvas');
            //     this.additionalCanvases.push({
            //         node: canvas,
            //         ctx: canvas.node.getContext('2d')
            //     });
            // }
          }

          const alt = this.rightAlt;

          if (alt) {
            this.canvas.attr('role', 'img');
            this.canvas.attr('aria-label', alt);
            this.canvas.attr('alt', alt);
          }

          let w = this.infoSize.width;
          let h = this.infoSize.height;
          const size = this.coreNode.size;

          if (w < size.width) {
            w = size.width;
          }

          if (h < size.height) {
            h = size.height;
          } // broke html if image less then viewer
          // I do not know why I added it
          // this.coreNode.setCss({
          //     'max-width': w + 'px',
          //     'max-height': h + 'px'
          // });


          if (size.height === 0) {
            this.cssId = $J.addCSS('#' + this.id + ' .' + CSS_CLASS_NAME + ':before', {
              'padding-top': this.infoSize.height / this.infoSize.width * 100 + '%'
            }, this.id + '-css');
            size.height = size.width * (this.infoSize.height / this.infoSize.width);
          }

          this.currentSize = helper.spinLib.calcProportionSize(size, this.infoSize);
          this.getDPPX(this.currentSize);
          this.standardSize.width = this.currentSize.width;
          this.standardSize.height = this.currentSize.height;
          this.setImageSize();
          this.canvas.setCss({
            top: '0',
            left: '0',
            zIndex: 10,
            position: 'absolute'
          });
          this.setCanvasSize();
          this.canvasContainer.append(this.canvas);
          this.coreNode.append(this.canvasContainer);

          if (this.isInView && (this.preload || this.isSlideShown)) {
            this.loadFirstImage();
          }
        }

        loadContent() {
          this.loadFirstImage();
        }

        loadFirstImage() {
          if (!this.firstImageLoaded && this.isInfoLoaded) {
            // fix for if the viewer was with display none
            if (!this.currentImageSize.width || !this.currentImageSize.height) {
              this.currentSize = helper.spinLib.calcProportionSize(this.coreNode.size, this.infoSize);
              this.getDPPX(this.currentSize);

              if (this.currentSize.width && this.currentSize.height) {
                this.setImageSize();

                if (this.isStarted && this.currentImageSize.width && this.currentImageSize.height) {
                  this.setCanvasSize();
                  this.draw();
                }
              }
            }

            if (!this.currentImageSize.width || !this.currentImageSize.height) {
              return;
            }

            this.waitToStart.start();
            this.firstImageLoaded = true;
            this.imagesMap.loadFirstImage({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height,
              dppx: this.dppx
            });
          }
        }

        get rightAlt() {
          let description = null;

          if (!this.dataAlt && this.meta && this.meta.description) {
            description = this.meta.description;
          } else {
            description = this.dataAlt;
          }

          return description;
        }

        createMap(quality, hdQuality, isHDQualitySet) {
          const option = this.option;
          let loadingSchema = null;

          if (option('autospin.enable')) {
            loadingSchema = option('autospin.type');
          } else if (option('hint.onStart.enable') && option('hint.onStart.effect')) {
            loadingSchema = option('hint.onStart.effect');
          }

          this.imagesMap = new ImagesMap({
            url: this.configURL,
            imageSettings: this.imageSettings,
            layers: this.layers,
            swapSides: option('swapSides'),
            startColumn: option('column.start'),
            startRow: option('row.start'),
            reverseColumn: option('column.reverse'),
            reverseRow: option('row.reverse'),
            loopColumn: option('column.loop'),
            loopRow: option('row.loop'),
            rowSpeed: option('row.sensitivity'),
            columnSpeed: option('column.sensitivity'),
            columnIncrement: option('column.increment'),
            rowIncrement: option('row.increment'),
            loadingSchema: loadingSchema,
            quality: quality,
            hdQuality: hdQuality,
            isHDQualitySet: isHDQualitySet,
            referrerPolicy: this.referrerPolicy
          });
          this.imagesMap.parentClass = this;
          this.userColumn = this.imagesMap.startColumn;
          this.userRow = this.imagesMap.startRow;
          this.on('mapFirstImageLoaded', e => {
            e.stopAll();

            if (this.placeholder) {
              this.placeholder.setCssProp('display', 'none');
            }

            if (!this.isInited) {
              if (this.firstImageLoaded) {
                this.draw();
                this.canvas.setCssProp('transition', 'none');
                this.canvas.render();
                this.canvas.setCssProp('transition', '');
              }

              if (this.loader) {
                this.loader.progress();
              }

              this.setCanvas().finally(() => {
                this.init();
              });
            }

            if (this.hotspots) {
              const img = this.imagesMap.getCurrentImage({
                width: this.currentSize.width,
                height: this.currentSize.height
              });
              this.hotspots.setFramePosition(img.row, img.col);
              this.hotspots.updateAndShow();

              if (this.isInView && this.isSlideShown) {
                this.hotspots.showNeededElements();
              }
            }
          });
          this.on('mapImagesReady', e => {
            e.stopAll();
            this.imagesMap.loadOtherImages({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height,
              dppx: this.dppx
            });
            this.calcMinSizeForDrag();
            const now = +new Date();
            this.sendStats('framesPreloaded', now - this.sessionStartTime, {
              duration: now - this.startLoadingTime
            });
            this.done();
            this.sendContentLoadedEvent();
          });
          this.on('mapImageLoaded', e => {
            e.stopAll();

            if (this.loader) {
              if (!this.loadedImages[e.data.row][e.data.col]) {
                this.loadedImages[e.data.row][e.data.col] = true;
                this.loader.progress();
              }
            }

            if (!e.data.error) {
              if (e.data.isCurrent) {
                if (e.data.callbackData.lens) {
                  // if (this.option('zoom.magnify.enable') && this.zoom) { // the option was removed
                  if (this.zoom) {
                    if ((this.zoom.shown || this.zoom.showing) && this.openedImg) {
                      if (this.openedImg.col === e.data.col && this.openedImg.row === e.data.row) {
                        this.zoom.addLoadedImage(e.data);
                      }
                    }
                  }
                } else {
                  if (this.lastImg && (this.lastImg.width !== e.data.width || this.lastImg.height !== e.data.height) && this.firstImageLoaded) {
                    this.draw();
                  }
                }
              }
            }
          });
          this.on('mapAllImagesLoaded', e => {
            e.stopAll();
            const now = +new Date();
            this.sendStats('framesLoaded', now - this.sessionStartTime, {
              duration: now - this.startLoadingTime
            });

            if (this.loader && this.loader.getProgressState() !== 2) {
              this.loader.hide();
            }
          });
          this.on('frameChange', e => {
            e.stop();

            if (this.ready) {
              this.sendEvent('frameChange', {
                row: e.data.row,
                column: e.data.column
              });
            }
          });
          this.imagesMap.loadImageInfo().then(originSize => {
            this.isInfoLoaded = true;
            const size = Object.assign({}, originSize.size);
            this.infoSize = size;

            if (this.hotspots) {
              this.hotspots.originImageSize = this.infoSize;
            }
          }).catch(err => {
            this.isInfoLoaded = true;
          });
        }

        getSelectorImgUrl(data) {
          return new Promise((resolve, reject) => {
            this.getInfo().then(() => {
              this.imagesMap.loadImageInfo().then(originSize => {
                this.waitToStart.wait(() => {
                  const defOpt = this.imagesMap.setImageSettings({
                    dppx: this.dppx
                  });

                  if (defOpt.src) {
                    data.src = defOpt.src;
                  }

                  data.srcset = defOpt.srcset;

                  if (this.option('thumbnail.type') === 'gif') {
                    data.originUrl = this.configURL.split('?')[0];
                    data.imageSettings = {
                      image: 24
                    };

                    if (this.option('thumbnail.gifParams')) {
                      data.imageSettings = helper.paramsFromQueryString(this.option('thumbnail.gifParams'));
                    }
                  }

                  resolve(Object.assign(this.imagesMap.getThumbnail(data), {
                    alt: this.rightAlt
                  }));
                });
              }).catch(reject);
            }).catch(reject);
          });
        }

        getInfoSize() {
          return new Promise((resolve, reject) => {
            this.getInfo().then(() => {
              this.imagesMap.loadImageInfo().then(resolve).catch(reject);
            }).catch(reject);
          });
        }

        onHotspotActivate(data) {
          this.customActionWas = true;
          this.stopAnimation();
          super.onHotspotActivate(data);
        }

        onHotspotDeactivate(data) {
          super.onHotspotDeactivate(data);
          this.animateWithDelay();
        }

        createHint() {
          if (!this.option('hint.message.enable')) {
            return;
          }

          let hintMessage = '<div class="spin-hint-animation"></div>';
          const horizontal = ['spin-hint-horizontal-animation'];
          const vertical = ['spin-hint-vertical-animation'];
          let hintClass = [];
          hintMessage += '<span>';
          hintMessage += this.option('hint.message.text');
          hintMessage += '</span>';

          switch (this.imagesMap.getHintType()) {
            case 'multi-row':
              hintClass = horizontal.concat(vertical);
              break;

            case 'row':
              hintClass = horizontal;
              break;

            case 'col':
              hintClass = vertical;
              break;
            // no default
          }

          const hintOptions = {
            html: hintMessage,
            additionalClass: hintClass
          };

          if ($J.browser.mobile || this.option('autospin.enable')) {
            hintOptions.autohide = 0;
          }

          this.hint = new Hint(this.coreNode, hintOptions);

          if (this.isSlideShown && this.isInView && this.option('autospin.type') === 'infinite') {
            this.showHint();
          }
        }

        get imageClassContainer() {
          return this.imagesMap;
        }

        createZoom() {
          let result = null;

          if (!this.destroyed && this.option('zoom.enable')) {
            result = super.createZoom(this.coreNode, {});

            if (this.zoomContainer) {
              this.zoom.lensContainer = this.zoomContainer;
            }

            this.coreNode.addEvent(['btnclick', 'dbltap'], e => {
              if (this.isFullscreenActionEnded()) {
                this.firstUserInteraction = true;
                this.openLens(e.x, e.y);
              }
            });

            if ($J.browser.mobile) {// this.setLongTapEvents();
            }
          }

          return result;
        }

        onZoomGetImage(e) {
          super.onZoomGetImage(e);

          if (this.checkImage(e.data, e.data.dontLoad)) {
            this.zoom.addLoadedImage(this.imagesMap.getCurrentImage(e.data));
          } else {
            this.imagesMap.loadImage(e.data);
          }
        }

        onZoomCancelLoadingOfTiles(e) {
          super.onZoomGetImage(e);
          e.data.round = false;
          this.imagesMap.cancelLoadingImage(e.data);
        }

        onZoomBeforeShow(e) {
          this.canvas.addClass(this.zoomClassName);

          if (this.hotspots) {
            this.hotspots.hideAll();
          }
        }

        onZoomShown(e) {
          if (this.isSlideShown) {
            this.startTimeForZommEvent = +new Date();

            if (this.openedImg) {
              this.sendStats('zoomIn', +new Date() - this.sessionStartTime, {
                frame: {
                  row: this.openedImg.row,
                  column: this.openedImg.col
                },
                clientX: e.data.clientPosition.x,
                clientY: e.data.clientPosition.y,
                pageX: e.data.pagePosition.x,
                pageY: e.data.pagePosition.y
              });
            }

            this.sendEvent('zoomIn');
          } else {
            this.zoom.hide(true);
          }
        }

        onZoomHidden(e) {
          if (this.openedImg) {
            this.canvas.removeClass(this.zoomClassName);
            const now = +new Date();
            this.sendStats('zoomOut', now - this.sessionStartTime, {
              duration: now - this.startTimeForZommEvent,
              frame: {
                row: this.openedImg.row,
                column: this.openedImg.col
              },
              clientX: e.data.clientPosition.x,
              clientY: e.data.clientPosition.y,
              pageX: e.data.pagePosition.x,
              pageY: e.data.pagePosition.y
            });

            if (this.hotspots) {
              this.hotspots.showAll();

              if (this.isInView && this.isSlideShown) {
                this.hotspots.showNeededElements();
              }
            }
          }

          this.sendEvent('zoomOut');

          if (this.isSlideShown) {
            this.animateWithDelay();
          }

          this.startTimeForZommEvent = null;
          this.openedImg = null;

          if (this.pinchCloud) {
            this.pinchCloud.addEvent();
          }
        }

        setLongTapEvents() {
          const pe = $J.W.node.navigator.pointerEnabled;
          let move = false;
          let touchDown = false;
          let events = ['touchstart'];

          if (pe) {
            events.push('pointerdown');
          } else {
            events.push('MSPointerDown');
          }

          this.coreNode.addEvent(events, e => {
            if (!this.isDragMove && !this.pinchCloud.pinch && this.isFullscreenActionEnded()) {
              clearTimeout(this.longTapTimer);
              this.longTapTimer = setTimeout(() => {
                e.stop();
                move = true;
                this.customActionWas = true;
                const p = e.pageXY;

                if (this.touchDragCloud) {
                  this.touchDragCloud.removeEvent();
                }

                this.firstUserInteraction = true;
                this.openLens(p.x, p.y, true);
              }, 500);
              touchDown = true;
            }
          });
          events = ['touchmove'];

          if (pe) {
            events.push('pointermove');
          } else {
            events.push('MSPointerMove');
          }

          this.coreNode.addEvent(events, e => {
            if (move && this.isFullscreenActionEnded()) {
              e.stop();
              const p = e.pageXY;
              this.zoom.customMove(p.x, p.y);
            }
          }, 1);
          events = ['touchend'];

          if (pe) {
            events.push('pointerup');
          } else {
            events.push('MSPointerUp');
          }

          this.coreNode.addEvent(events, e => {
            if (touchDown) {
              e.stop();
              touchDown = false;
              clearTimeout(this.longTapTimer);
            }

            if (move && this.isFullscreenActionEnded()) {
              e.stop();
              move = false; // clearTimeout(this.longTapTimer);

              this.zoom.hide(true);

              if (this.touchDragCloud) {
                this.touchDragCloud.addEvent();
              }
            }
          });
        }

        get zoomSize() {
          const r = this.option('zoom.ratio');
          const originWidth = this.infoSize.width;
          const originHeight = this.infoSize.height;
          let size = {
            width: originWidth,
            height: originHeight
          };

          if (r !== 'max') {
            size.width = this.currentImageSize.width * r;
            size.height = this.currentImageSize.height * r;
            size = ResponsiveImage.roundImageSize(size);
          }

          size.width = Math.min(originWidth, size.width);
          size.height = Math.min(originHeight, size.height);
          return {
            width: size.width,
            height: size.height,
            originWidth: originWidth,
            originHeight: originHeight
          };
        }

        openLens(x, y, longTap, toLevel) {
          let result = false;

          if (this.isZoomSizeExist()) {
            const zoomSize = this.zoomSize;
            result = true;
            this.stopSmoothing();
            this.stopAnimation();

            if (this.hint) {
              this.hint.hide();
            }

            if (this.hotspots) {
              this.hotspots.hideActiveHotspotBox(true);
            }

            let round = false;
            let lensImgWidth;
            let lensImgHeight;

            if (this.isFullscreenActionEnded() && this.imagesMap.isLoaded({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height
            })) {
              lensImgWidth = this.currentImageSize.width;
              lensImgHeight = this.currentImageSize.height;
              round = true;
            } else {
              lensImgWidth = this.lastImg.serverWidth;
              lensImgHeight = this.lastImg.serverHeight;
            }

            const img = this.imagesMap.getCurrentImage({
              width: lensImgWidth,
              height: lensImgHeight,
              round: round
            });
            this.openedImg = img;

            if (x === undefined) {
              result = this.zoom.showCenter(img.node, zoomSize);
            } else {
              result = this.zoom.show(img.node, zoomSize, x, y, longTap, toLevel);
            }
          }

          return result;
        }

        done() {
          const rows = this.imagesMap.countOfRows;
          const cols = this.imagesMap.countOfFrames;

          if (this.loader) {
            this.loader.setMaxOpacity(0.5);
          }

          this.setBrowserEvents();
          this.createHint();
          this.createZoom();
          this.setZoomEvents();

          if (rows > 1 && cols > 1) {
            this.coreNode.setCssProp('touch-action', 'none');
          } else {
            if (rows > 1) {
              this.coreNode.setCssProp('touch-action', 'pan-x');
            } else {
              this.coreNode.setCssProp('touch-action', 'pan-y');
            }
          }

          this.boxBoundaries = this.coreNode.rect;
          this.animate('start');

          if (this.accountInfo.branded) {
            const nodeWithSirvClassName = globalFunctions.getNodeWithSirvClassName(this.instanceNode) || $J.D.node.head || $J.D.node.body;
            globalFunctions.rootDOM.showSirvAd(nodeWithSirvClassName, this.instanceNode, BRAND_LANDING, '360-degree viewer by Sirv');
          }

          this.sendStats('viewerReady', +new Date() - this.sessionStartTime, {
            rows: this.imagesMap.countOfRows,
            columns: this.imagesMap.countOfFrames,
            viewerSize: {
              width: this.currentSize.width,
              height: this.currentSize.height
            }
          });

          if (this.isZoomSizeExist()) {
            this.coreNode.addClass(globalVariables.CSS_CURSOR_ZOOM_IN);
          }

          this.setGlobalEvents();
          this.turnOnOff();
          super.done();

          if (this.hotspots) {
            this.hotspots.instanceComponentNode = this.canvasContainer;
            this.hotspots.containerSize = this.canvasContainer.node.getBoundingClientRect();
          }
        }

        setBrowserEvents() {
          this.setDrag(this.coreNode);
          this.setMouseWheel(this.coreNode);
        }

        setCanvas() {
          if (!this.canvasPromise) {
            let _resolve;

            let canvasOpacityHandler;
            let _timer = null;
            this.canvasPromise = helper.makeQueryblePromise(new Promise((resolve1, reject) => {
              _resolve = resolve1;

              if (this.firstImageLoaded) {
                this.draw();
              }

              if (!this.isInView || !this.isSlideShown) {
                this.canvas.addClass(P + '-shown');
                resolve1();
              } else {
                _timer = setTimeout(() => {
                  // some times transitionend does not work
                  if (this.canvas) {
                    // we can remove slide from slider by API much faster then this animation
                    this.canvas.removeEvent('transitionend', canvasOpacityHandler);
                  }

                  resolve1();
                }, 1100);

                canvasOpacityHandler = e => {
                  if (e.propertyName === 'opacity') {
                    e.stop();
                    clearTimeout(_timer);
                    this.canvas.removeEvent(e.type, canvasOpacityHandler);
                    resolve1();
                  }
                };

                this.canvas.addEvent('transitionend', canvasOpacityHandler);
                this.canvas.render();
                this.canvas.addClass(P + '-shown');
              }
            }));

            this.canvasPromise.resolve = () => {
              this.canvas.removeEvent('transitionend', canvasOpacityHandler);

              _resolve();
            };
          }

          return this.canvasPromise;
        }

        clearCanvas() {
          if (this.ctx) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          }
        }

        draw(neededSize) {
          if (this.ctx) {
            const size = neededSize || this.currentImageSize;
            const imageData = {
              width: size.width,
              height: size.height,
              maxSize: true,
              dppx: this.dppx
            };
            const img = this.imagesMap.getCurrentImage(imageData);
            this.lastImg = img;

            if (!img) {
              return;
            }

            this.ctx.imageSmoothingQuality = 'high';

            if (this.hotspots) {
              this.hotspots.changeHotspotsPosition(img.row, img.col);
            }

            this.clearCanvas();
            this.canvas.node.width = img.node.node.width;
            this.canvas.node.height = img.node.node.height;
            this.ctx.drawImage(img.node.node, 0, 0, this.canvas.node.width, this.canvas.node.height);
          }
        }
        /*
        draw(neededSize) {
            const size = neededSize || this.currentImageSize;
             const imageData = {
                width: size.width,
                height: size.height,
                maxSize: true,
                dppx: this.dppx
            };
             const img = this.imagesMap.getCurrentImage(imageData);
            const ac = this.additionalCanvases;
            let steps = 0;
            let posX;
            let posY;
            let i;
             if (!img || !size.width || !size.height) { return; }
             this.lastImg = img;
             // s.width = Math.min(s.width * 2, img.width * $J.DPPX);
            // s.height = Math.min(s.height * 2, img.height * $J.DPPX);
             const s = {
                width: img.width * this.dppx,
                height: img.height * this.dppx
            };
             // steps = Math.ceil(Math.log(Math.max(img.width / s.width, img.height / s.height)) / Math.LN2);
            steps = Math.ceil(Math.log(Math.max(s.width / img.width, s.height / img.height)) / Math.LN2);
             ac[0].node.node.width = s.width;
            ac[0].node.node.height = s.height;
            ac[1].node.node.width = s.width;
            ac[1].node.node.height = s.height;
             ac[0].ctx.drawImage(img.node.node, 0, 0, s.width, s.height);
             for (i = steps - 1; i > 0; i--) {
                // Scale down in tmp canvas
                ac[1].node.node.width *= 0.5;
                ac[1].node.node.height *= 0.5;
                ac[1].ctx.drawImage(ac[0].node.node, 0, 0, ac[0].node.node.width, ac[0].node.node.height,
                                            0, 0, ac[1].node.node.width, ac[1].node.node.height);
                 // Copy back
                ac[0].node.node.width *= 0.5;
                ac[0].node.node.height *= 0.5;
                ac[0].ctx.drawImage(ac[1].node.node, 0, 0, ac[1].node.node.width, ac[1].node.node.height,
                                            0, 0, ac[0].node.node.width, ac[0].node.node.height);
            }
             // this.ctx.setTransform(1, 0, 0, 1, 0, 0);
             this.canvas.node.width = s.width;
            this.canvas.node.height = s.height;
             // this.canvas.setCss({
            //     width: (s.width / 2) + 'px',
            //     height: (s.height / 2) + 'px'
            // });
             if (this.hotspots) {
                this.hotspots.changeHotspotsPosition(img.row, img.col);
            }
             this.clearCanvas();
             if (this.ctx) {
                posX = calcScalePosition(this.scale, s.width);
                posY = calcScalePosition(this.scale, s.height);
                 this.ctx.drawImage(ac[0].node.node, 0, 0, ac[0].node.node.width, ac[0].node.node.height, posX, posY, s.width * this.scale, s.height * this.scale);
            }
        }
        */


        setCanvasSize() {
          const s = this.currentSize;
          this.canvas.setCss({
            width: s.width,
            height: s.height
          });
          this.canvasContainer.setCss({
            width: s.width,
            height: s.height
          });
          this.canvas.width = s.width;
          this.canvas.height = s.height;
        }

        calcMinSizeForDrag() {
          const s = this.currentSize;
          this.minSizeOfFrame = this.imagesMap.pixelPerFrame(s.width);
          this.minSizeOfRow = this.imagesMap.pixelPerRow(s.height);
        }

        smoothing(distance, time, direction) {
          // direction - next, prev, down, up
          if (!time) {
            return;
          }

          let speed = distance / time;

          const move = () => {
            speed *= 0.97;
            this.smooseTimeout = setTimeout(() => {
              this.imagesMap.prepareFutureImage(direction);
              this.imagesMap.setPreparedFutureImage();
              this.draw();

              if (speed > 0.3) {
                move();
              }
            }, this.minSizeOfFrame / speed);
          };

          if (!this.isSmoothing) {
            this.isSmoothing = true;
            move();
          }
        }

        stopSmoothing() {
          if (this.isSmoothing) {
            this.isSmoothing = false;
            clearTimeout(this.smooseTimeout);
            this.smooseTimeout = null;
            this.imagesMap.resetPreparedImage();
          }
        }

        animateWithDelay(action) {
          let animateAction = 'inactive';

          if (action) {
            animateAction = action;
          }

          if (this.option('autospin.enable')) {
            clearTimeout(this.autospinResumeTimer);
            this.autospinResumeTimer = setTimeout(() => {
              this.animate(animateAction);
            }, this.option('autospin.resume'));
          } else {
            this.animate(animateAction);
          }
        }

        setDrag(node) {
          const rows = this.imagesMap.countOfRows;
          const cols = this.imagesMap.countOfFrames;
          const multi = rows > 1 && cols > 1;
          const sphereValues = {
            x: {
              minSize: this.minSizeOfFrame,
              count: cols
            },
            y: {
              minSize: this.minSizeOfRow,
              count: rows
            }
          };
          const onAnyDrag = this.option('freeDrag');
          let lastPoint = {
            x: 0,
            y: 0
          };
          let lastPartOfDistance = {
            x: 0,
            y: 0
          };
          let canMoveAxis = null;

          if (!multi) {
            canMoveAxis = cols > 1 ? 'x' : 'y';
          }

          let lastTime = null;
          let axis;
          const fns = {};
          let otherAxis;
          let queue = {
            x: {
              next: 0,
              prev: 0
            },
            y: {
              up: 0,
              down: 0
            }
          };
          let startTime;
          let rotate = false;
          const rotateDebounce = helper.debounce(() => {
            rotate = false;
          }, 50);
          const G = 9.8;
          const COEFFICIENT_OF_FRICTION = 0.00065;
          const FRICTION_FORCE = {
            x: COEFFICIENT_OF_FRICTION * cols * G,
            y: COEFFICIENT_OF_FRICTION * rows * G
          };
          const DIRECTIONS = {
            x: ['prev', 'next'],
            y: ['down', 'up']
          };

          if (!multi && onAnyDrag) {
            if (cols > 1) {
              DIRECTIONS.y = DIRECTIONS.x;
            } else {
              DIRECTIONS.x = DIRECTIONS.y;
            }
          }

          const onDrag = e => {
            clearTimeout(this.longTapTimer);
            fns[e.state](e);
          };

          const addPoint = (_axis, _speed, _distance, _direction) => {
            queue[_axis][_direction] += _distance;
          };

          const getPoints = _axis => {
            const a = queue[_axis];
            let result;
            const dir = _axis === 'x' ? ['next', 'prev'] : ['up', 'down'];

            if (a[dir[0]] > a[dir[1]]) {
              result = {
                distance: a[dir[0]],
                direction: dir[0]
              };
            } else {
              result = {
                distance: a[dir[1]],
                direction: dir[1]
              };
            }

            return result;
          };

          const getCountOfItems = (frictionForce, weight, distance, time, sizeOfItem) => {
            let result; // eslint-disable-next-line no-restricted-properties

            result = weight * Math.pow(distance / time, 2) / (2 * frictionForce);
            result = Math.floor(result / sizeOfItem);
            return result;
          };

          const getTime = (frictionForce, weight, distance, time) => {
            return weight * (distance / time) / frictionForce;
          };

          const getDirection = (value, _axis) => {
            return DIRECTIONS[_axis][value >= 0 ? 0 : 1];
          };

          fns.dragstart = e => {
            this.firstUserInteraction = true;
            this.isDragMove = true;
            this.stopSmoothing();
            this.stopAnimation();

            if (this.hint) {
              this.hint.hide();
            }

            if (this.hotspots) {
              this.hotspots.hideNeededElements(true);
            }

            this.userColumn = this.imagesMap.startColumn;
            this.userRow = this.imagesMap.startRow;

            if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
              e.stop();
            }

            lastPoint.x = e.x;
            lastPoint.y = e.y;
            lastTime = e.timeStamp;
            startTime = +new Date();
            const t = +new Date() - this.sessionStartTime;
            this.sendStats('dragStart', t, {
              clientX: e.x - this.boxBoundaries.left,
              clientY: e.y - this.boxBoundaries.top,
              pageX: e.x,
              pageY: e.y
            });
            this.sendEvent('spinStart');
            this.sendEvent('rotate');
            this.sendStats('rotate', t, {});
            this.pinchCloud.removeEvent();
          };

          fns.dragend = e => {
            let time;
            let values;
            let countOfItems;
            let timeOfAnimation;
            let timeOfAnimation2;
            const animationValues = [];

            if (this.isDragMove) {
              e.stop();
              this.isDragMove = false;
              rotateDebounce.cancel();

              if (rotate && canMoveAxis === axis || rotate && (multi || onAnyDrag)) {
                time = +new Date() - startTime;
                values = getPoints(axis);
                countOfItems = getCountOfItems(FRICTION_FORCE[axis], cols, values.distance, time, sphereValues[axis].minSize);
                timeOfAnimation = getTime(FRICTION_FORCE[axis], cols, values.distance, time);
                animationValues.push({
                  items: countOfItems,
                  direction: values.direction
                });

                if (multi) {
                  values = getPoints(otherAxis);
                  countOfItems = getCountOfItems(FRICTION_FORCE[otherAxis], cols, values.distance, time, sphereValues[otherAxis].minSize);
                  timeOfAnimation2 = getTime(FRICTION_FORCE[otherAxis], cols, values.distance, time);

                  if (timeOfAnimation2 > timeOfAnimation) {
                    timeOfAnimation = timeOfAnimation2;
                  }

                  animationValues.push({
                    items: countOfItems,
                    direction: values.direction
                  });
                }

                this.animateTo(timeOfAnimation, animationValues);
                this.pinchCloud.addEvent();
              } else {
                if (this.hotspots && this.isInView && this.isSlideShown) {
                  this.hotspots.showNeededElements();
                }

                this.animateWithDelay();
              }

              this.sendEvent('spinEnd');
              const now = +new Date();
              this.sendStats('dragEnd', now - this.sessionStartTime, {
                duration: now - startTime,
                clientX: e.x - this.boxBoundaries.left,
                clientY: e.y - this.boxBoundaries.top,
                pageX: e.x,
                pageY: e.y
              });
              lastPoint = {
                x: 0,
                y: 0
              };
              lastTime = null;
              lastPartOfDistance = {
                x: 0,
                y: 0
              };
              queue = {
                x: {
                  next: 0,
                  prev: 0
                },
                y: {
                  up: 0,
                  down: 0
                }
              };
              rotate = false;
            }
          };

          const setFrame = (currentAxis, direction) => {
            let result = false;

            if (lastPartOfDistance[currentAxis] > sphereValues[currentAxis].minSize) {
              result = true;
              const count = Math.floor(lastPartOfDistance[currentAxis] / sphereValues[currentAxis].minSize);
              lastPartOfDistance[currentAxis] = lastPartOfDistance[currentAxis] % sphereValues[currentAxis].minSize;
              this.imagesMap.prepareFutureImage(direction, count);
              this.imagesMap.setPreparedFutureImage();
            }

            return result;
          };

          fns.dragmove = e => {
            const directions = {};
            const currentDistance = {
              x: 0,
              y: 0
            };
            const absCurrentDistance = {
              x: 0,
              y: 0
            };
            let currentSpeed;

            if (this.isDragMove) {
              rotate = true;
              this.customActionWas = true;
              currentDistance.x = e.x - lastPoint.x; // +prev, -next

              currentDistance.y = e.y - lastPoint.y; // +down, -up

              absCurrentDistance.x = Math.abs(currentDistance.x);
              absCurrentDistance.y = Math.abs(currentDistance.y);
              currentSpeed = e.timeStamp - lastTime;
              lastTime = e.timeStamp;
              axis = absCurrentDistance.x >= absCurrentDistance.y ? 'x' : 'y';
              otherAxis = axis === 'x' ? 'y' : 'x';

              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || multi || onAnyDrag || axis === 'x' && cols > 1 || axis === 'y' && rows > 1) {
                e.stop();
              }

              directions[axis] = getDirection(currentDistance[axis], axis);
              directions[otherAxis] = getDirection(currentDistance[otherAxis], otherAxis);
              addPoint(axis, currentSpeed, absCurrentDistance[axis], directions[axis]);
              addPoint(otherAxis, currentSpeed, absCurrentDistance[otherAxis], directions[otherAxis]);

              if (multi || onAnyDrag) {
                lastPartOfDistance.x += absCurrentDistance.x;
                lastPartOfDistance.y += absCurrentDistance.y;
              } else if (canMoveAxis) {
                if (canMoveAxis === axis && canMoveAxis === 'x') {
                  lastPartOfDistance.x += absCurrentDistance.x;
                } else if (canMoveAxis === axis && canMoveAxis === 'y') {
                  lastPartOfDistance.y += absCurrentDistance.y;
                }
              }

              if (setFrame(axis, directions[axis]) && onAnyDrag) {
                lastPartOfDistance[otherAxis] = 0;
              }

              if (multi) {
                setFrame(otherAxis, directions[otherAxis]);
              }

              this.userColumn = this.imagesMap.currentColumn;
              this.userRow = this.imagesMap.currentRow;
              lastPoint.x = e.x;
              lastPoint.y = e.y;
              this.draw();
              rotateDebounce();
            }
          };

          const cloud = {
            eventAdded: false
          };

          cloud.addEvent = () => {
            if (!cloud.eventAdded) {
              cloud.eventAdded = true;
              node.addEvent(['mousedrag', 'touchdrag'], onDrag);
            }
          };

          cloud.removeEvent = () => {
            if (cloud.eventAdded) {
              cloud.eventAdded = false;
              node.removeEvent(['mousedrag', 'touchdrag'], onDrag);
            }
          };

          this.touchDragCloud = cloud;

          if (!this.slideDragEventStart) {
            this.touchDragCloud.addEvent();
          }
        }

        animateTo(time, values) {
          const last = [];
          const dirs = [];
          const startObj = {};
          clearTimeout(this.autospinResumeTimer);

          if (this.animationFX) {
            this.animationFX.stop();
          }

          for (let i = 0, l = values.length; i < l; i++) {
            dirs.push(values[i].direction);
            last.push(0);
            startObj[values[i].direction] = [0, values[i].items];
          }

          this.animationFX = new $J.FX($J.$new('div'), {
            duration: Math.abs(time),
            transition: $J.FX.getTransition().inCubic,
            onBeforeRender: $((ds, value) => {
              let _i;

              let frame;

              for (_i = 0; _i < ds.length; _i++) {
                frame = Math.round(value[ds[_i]]);

                if (last[_i] !== frame) {
                  this.imagesMap.prepareFutureImage(ds[_i], frame - last[_i]);
                  this.imagesMap.setPreparedFutureImage();
                  this.userColumn = this.imagesMap.currentColumn;
                  this.userRow = this.imagesMap.currentRow;
                  last[_i] = frame;
                }
              }

              this.draw();
            }).bind(this, dirs),
            onComplete: () => {
              this.stopAnimation();
              this.animateWithDelay();

              if (this.hotspots && this.isInView && this.isSlideShown) {
                this.hotspots.showNeededElements();
              }
            }
          }).start(startObj);
        }

        setMouseWheel(node) {
          let delta;
          let direction;
          const correction = 8 / 54;
          let count = 0;
          let spinOnWheel = false; // let stack = [];

          const wheelStep = 3;
          const wheelDebounce = helper.debounce(isMouse => {
            spinOnWheel = false; // stack = [];

            this.sendEvent('spinEnd');

            if (isMouse) {
              count = 0;
            } else {
              this.animateWithDelay();
            }
          }, 200);
          const rows = this.imagesMap.countOfRows;
          const cols = this.imagesMap.countOfFrames;
          const multi = rows > 1 && cols > 1;
          const onAnyDrag = this.option('freeDrag');

          if (this.option('wheel')) {
            let _shiftButtonIsPressed = false;

            this.keyPressHandlerForShiftButton = e => {
              if (e.oe.keyCode === 16) {
                // shift
                _shiftButtonIsPressed = e.type === 'keydown';
              }
            };

            $J.W.addEvent(['keydown', 'keyup'], this.keyPressHandlerForShiftButton);
            node.addEvent('mousescroll', e => {
              this.firstUserInteraction = true;
              const shiftButtonIsPressed = e.isMouse ? _shiftButtonIsPressed : false;
              const isX = Math.abs(e.deltaY) < Math.abs(e.deltaX); // TODO chrome on windows 10 has just Y axis
              // if (!isX && rows === 1) { return; }

              if (!isX && !multi && !onAnyDrag) {
                return;
              }

              this.customActionWas = true;
              e.stop();

              if (this.animationFX) {
                this.animationFX.stop();
                this.animationFX = null;
              }

              this.stopSmoothing();
              this.stopAnimation();

              if (this.hotspots) {
                this.hotspots.hideActiveHotspotBox();
              }

              if (!spinOnWheel) {
                spinOnWheel = true;
                this.sendEvent('spinStart');
                this.sendEvent('rotate');
                this.sendStats('rotate', +new Date() - this.sessionStartTime, {});
              }

              if (isX) {
                delta = e.deltaX;
                direction = delta >= 0 ? 'next' : 'prev';
              } else {
                delta = e.deltaY;

                if (rows > 1 && !shiftButtonIsPressed) {
                  direction = delta >= 0 ? 'down' : 'up';
                } else {
                  direction = delta >= 0 ? 'next' : 'prev';
                }
              }

              if (e.isMouse) {
                delta = delta / Math.abs(delta) * wheelStep;
                count += Math.abs(delta);
                this.animateTo(200, [{
                  direction: direction,
                  items: count
                }]);
              } else {
                delta = delta * correction;
                count += delta;

                if (Math.abs(count) > 1) {
                  delta = parseInt(count, 10);
                  count -= delta;
                  this.imagesMap.prepareFutureImage(direction, Math.abs(delta));
                  this.imagesMap.setPreparedFutureImage();
                  this.draw();
                }
              }

              wheelDebounce(e.isMouse);
            });
          }
        }

        animate(action, autoplayDuration, autoplayType, fromAPI) {
          const isAutospin = action === 'autoplay' || this.option('autospin.enable');

          if (!this.isInView || !this.isSlideShown || this.animationCloud.isMoving() || this.isDragMove || this.customActionWas && !isAutospin && !fromAPI || this.openedImg) {
            return;
          }

          if (this.animationCloud.isPaused()) {
            this.animationCloud.resume();
            return;
          }

          clearTimeout(this.animationCloud.hintTimer);
          clearTimeout(this.autospinResumeTimer);
          let delay = false;
          let effect = null;

          if (isAutospin) {
            if (this.isAutoplayPaused) {
              return;
            }

            effect = 'as-' + (autoplayType || this.option('autospin.type'));

            if (action !== 'start') {
              delay = true;
            }
          } else {
            let nameOfEvent;

            switch (action) {
              case 'start':
                nameOfEvent = 'onStart';
                break;

              case 'inView':
              case 'slideIn':
                nameOfEvent = 'onVisible';
                break;

              case 'inactive':
                delay = true;
                nameOfEvent = 'onInactive';
                break;

              default:
                effect = action;
            }

            if (nameOfEvent && this.option('hint.' + nameOfEvent + '.enable')) {
              const tmp = this.option('hint.' + nameOfEvent + '.effect');

              if (tmp) {
                effect = tmp;
              }
            } // showTextHint = false;

          }

          this.animationCloud.start({
            speed: autoplayDuration || this.option('autospin.duration'),
            type: effect,
            infinite: isAutospin,
            delay: delay,
            isBackward: this.reflectDirection,
            userInteraction: fromAPI
          }, () => {
            const r = this.showHint();

            if (this.hotspots && this.isInView && this.isSlideShown) {
              this.hotspots.showNeededElements();
            }

            if (this.option('hint.onInactive.enable')) {
              if (r) {
                this.animationCloud.hintTimer = setTimeout(() => {
                  this.animationCloud.hintTimer = null;
                  this.animate('inactive');
                }, this.hint.movingTime);
              } else {
                this.animate('inactive');
              }
            }
          });
        }

        initAnimation() {
          let isMoving = false;
          let isPaused = false;
          let isStopped = false;
          let timer = null;
          let delayTimer = null;
          let step;
          let currentIndex = 0;
          let callback = null;
          let framesLength = this.imagesMap.countOfFrames;
          let options;

          if (this.option('swapSides')) {
            framesLength = this.imagesMap.countOfRows;
          }

          const clear = () => {
            isMoving = false;
            currentIndex = 0;
          };

          const end = () => {
            clear();

            if (callback) {
              callback();
            }
          };

          const move = () => {
            let count = this.imagesMap.getNextBufferIndex(currentIndex);

            if (count || options.infinite) {
              if (!count && options.infinite) {
                count = 1;

                if (options.infinite) {
                  currentIndex = -1;
                } else {
                  currentIndex = 0;
                }
              }

              currentIndex = currentIndex + count;
              this.imagesMap.setNextAnimationFrame(currentIndex);
              timer = setTimeout(() => {
                this.imagesMap.setPreparedNextImage();
                this.draw();
                move();
              }, count * step);
            } else {
              end();
            }
          };

          const getSpeed = (currentSpeed, typeOfAnimation) => {
            let r = currentSpeed;

            if (!r) {
              switch (typeOfAnimation) {
                case 'intro':
                  r = 3600;
                  break;

                case 'twitch':
                  r = 2200;
                  break;

                case 'spin':
                  r = 3600;
                  break;

                case 'momentum':
                  r = 10;
                  break;

                default:
                  r = 3600;
              }
            }

            return r;
          };

          const animationCloud = {
            hintTimer: null,
            isMoving: () => {
              return isMoving;
            },
            isPaused: () => {
              return isPaused;
            },
            start: (_options, cb) => {
              if (isMoving) {
                return;
              }

              isMoving = true;
              isStopped = false;

              const _move = () => {
                delayTimer = null;

                if (options.type) {
                  if (!this.imagesMap) {
                    return;
                  }

                  this.imagesMap.createAnimation(options.type, options.isBackward);

                  if (options.userInteraction && this.imagesMap.imagesBuffer && this.imagesMap.imagesBuffer.length) {
                    const last = this.imagesMap.imagesBuffer[this.imagesMap.imagesBuffer.length - 1];
                    this.userColumn = last.col;
                    this.userRow = last.row;
                  }

                  step = options.speed / framesLength;

                  if (options.infinite) {
                    this.showHint();
                  }

                  move();
                } else {
                  end();
                }
              };

              callback = cb;
              options = Object.assign({
                speed: 3600,
                type: 'row',
                delay: false,
                infinite: false,
                isBackward: false,
                userInteraction: false
              }, _options);
              options.speed = getSpeed(options.speed, options.type);

              if (options.delay && !options.infinite) {
                delayTimer = setTimeout(_move, this.option('inactivity'));
              } else {
                _move();
              }
            },
            resume: () => {
              if (isPaused) {
                isMoving = true;
                isPaused = false;
                move();
              }
            },
            pause: () => {
              if (!isPaused && !isStopped) {
                isMoving = false;
                isPaused = true;
                clearTimeout(animationCloud.hintTimer);
                clearTimeout(delayTimer);
                clearTimeout(timer);
              }
            },
            stop: () => {
              animationCloud.pause();
              isStopped = true;
              isPaused = false;
              currentIndex = 0;
              callback = null;
              this.imagesMap.clearFramesQueue();
              this.imagesMap.resetPreparedImage();
            }
          };
          this.animationCloud = animationCloud;
        }

        stopAnimation() {
          if (this.animationFX) {
            this.animationFX.stop();
            this.animationFX = null;
          }

          clearTimeout(this.autospinResumeTimer);

          if (this.animationCloud) {
            this.animationCloud.stop();
          }
        } // eslint-disable-next-line no-unused-vars


        onBeforeFullscreenIn(data) {
          this.stopSmoothing();
          this.stopAnimation();

          if (this.zoom) {
            this.zoom.hide(true);
          }

          this.deactivateSpin();
          this.boxBoundaries = this.coreNode.rect;
          super.onBeforeFullscreenIn(data);

          if (this.hotspots) {
            this.hotspots.hideAll();
          }

          if (this.isInited && this.isInView && this.isSlideShown) {
            this.isHidden = true;
            this.canvas.setCss({
              opacity: 0,
              visibility: 'hidden'
            });
          }
        } // eslint-disable-next-line no-unused-vars


        onAfterFullscreenIn(data) {
          if (!this.infoSize) {
            return;
          } // const insideIFrame = $J.W.node.parent !== $J.W.node.window;
          // const pseudo = data.pseudo;
          // if we use it, we do not have pinchend event and touchdrag after that
          // if (this.pinchCloud) {
          //     this.pinchCloud.removeEvent();
          //     this.pinchCloud.addEvent();
          // }


          if (this.canvasPromise && this.canvasPromise.isPending()) {
            this.canvasPromise.resolve();
          }

          const screenSize = this.coreNode.size;
          this.currentSize = helper.spinLib.calcProportionSize(screenSize, this.infoSize, true, this.standardSize);
          this.getDPPX(this.currentSize);
          this.setImageSize();
          this.setCanvasSize();

          if (this.ready) {
            if (!this.imagesMap.isImagesExist({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height
            })) {
              this.imagesMap.loadImages({
                width: this.currentImageSize.width,
                height: this.currentImageSize.height,
                dppx: this.dppx
              });
            }
          }

          if (this.firstImageLoaded) {
            this.draw();
          }

          if (this.isHidden) {
            this.isHidden = false;
            setTimeout(() => {
              this.canvas.setCss({
                opacity: '',
                visibility: ''
              });
            }, 0);
          }

          if (this.hotspots) {
            if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
              this.hotspots.showAll();

              if (this.isInView && this.isSlideShown) {
                this.hotspots.showNeededElements();
              }
            }
          }

          if (this.ready) {
            this.animate('inactive');

            if (!$J.browser.mobile) {
              this.showHint();
            }

            this.fullscreenStartTime = +new Date();
            this.sendStats('fullscreenOpen', +new Date() - this.sessionStartTime);
          }
        } // eslint-disable-next-line no-unused-vars


        onBeforeFullscreenOut(data) {
          this.stopSmoothing();
          this.stopAnimation();

          if (this.zoom) {
            this.zoom.hide(true);
          }

          this.deactivateSpin();

          if (this.hint && this.always) {
            this.hint.hide();
          }

          super.onBeforeFullscreenOut(data);

          if (this.isInited && this.isInView && this.isSlideShown) {
            this.isHidden = true;
            this.canvas.setCss({
              opacity: 0,
              visibility: 'hidden'
            });
          }
        } // eslint-disable-next-line no-unused-vars


        onAfterFullscreenOut(data) {
          if (!this.infoSize) {
            return;
          } // const pseudo = data.pseudo;
          // if we use it, we do not have pinchend event and touchdrag after that
          // if (this.pinchCloud) {
          //     this.pinchCloud.removeEvent();
          //     this.pinchCloud.addEvent();
          // }


          if (this.canvasPromise && this.canvasPromise.isPending()) {
            this.canvasPromise.resolve();
          }

          this.currentSize = helper.spinLib.calcProportionSize(this.coreNode.size, this.infoSize);
          this.getDPPX(this.currentSize);
          this.standardSize.width = this.currentSize.width;
          this.standardSize.height = this.currentSize.height;
          this.currentImageSize.width = this.currentSize.width;
          this.currentImageSize.height = this.currentSize.height;
          this.setCanvasSize();

          if (this.ready) {
            if (!this.imagesMap.isImagesExist({
              width: this.currentSize.width,
              height: this.currentSize.height
            })) {
              this.imagesMap.loadImages({
                width: this.currentSize.width,
                height: this.currentSize.height,
                dppx: this.dppx
              });
            }
          }

          if (this.firstImageLoaded) {
            this.draw();
          }

          if (this.isHidden) {
            this.isHidden = false;
            setTimeout(() => {
              if (!this.destroyed) {
                this.canvas.setCss({
                  opacity: '',
                  visibility: ''
                });
              }
            }, 0);
          }

          super.onAfterFullscreenOut(data);

          if (this.ready) {
            this.animate('inactive');

            if (!$J.browser.mobile) {
              this.showHint();
            }

            const now = +new Date();
            this.sendStats('fullscreenClose', now - this.sessionStartTime, {
              duration: now - this.fullscreenStartTime
            });
          }
        }

        play(duration, effect) {
          let result = false;

          if (this.ready && !this.isZoomed()) {
            this.isAutoplayPaused = false;
            this.stopSmoothing();
            this.stopAnimation();

            if (!this.instanceOptions.checkValue('autospin.duration', duration)) {
              duration = null;
            }

            if (!this.instanceOptions.checkValue('autospin.type', effect)) {
              effect = null;
            }

            this.animate('autoplay', duration, effect);
            result = true;
          }

          return result;
        }

        pause() {
          let result = false;

          if (this.ready && !this.isZoomed()) {
            this.isAutoplayPaused = true;
            this.stopSmoothing();
            this.stopAnimation();
            this.animateWithDelay();
            result = true;
          }

          return result;
        }

        rotate(countOfCols, countOfRows) {
          let result = false;

          const normalizeValue = value => {
            if (!value) {
              value = 0;
            } else if ($J.typeOf(value) === 'string') {
              value = parseInt(value, 10);

              if (isNaN(value)) {
                value = 0;
              }
            }

            return value;
          };

          if (this.ready) {
            countOfCols = normalizeValue(countOfCols);
            countOfRows = normalizeValue(countOfRows);

            if (countOfCols !== 0 || countOfRows !== 0) {
              this.stopAnimation();
              this.stopSmoothing();

              if (!this.isDragMove) {
                this.sendEvent('rotate');
                this.sendStats('rotate', +new Date() - this.sessionStartTime, {});
                this.animate({
                  cols: countOfCols,
                  rows: countOfRows
                }, $J.U, $J.U, true);
                result = true;
              }
            }
          }

          return result;
        }

        jumpTo(value, axis) {
          let result = false;
          let direction = null;

          if (this.ready) {
            if ($J.typeOf(value) === 'string') {
              value = value.trim();
              direction = /^-/.test(value) ? 'prev' : 'next';
            }

            value = parseInt(value, 10);

            if (!isNaN(value)) {
              result = this.imagesMap.jump(axis, value, direction);

              if (result && this.firstImageLoaded) {
                this.sendEvent('rotate');
                this.sendStats('rotate', +new Date() - this.sessionStartTime, {});
                this.draw();
              }
            }
          }

          return result;
        }

        zoomIn() {
          if (this.ready && this.zoom) {
            if (!this.isDragMove && this.isFullscreenActionEnded()) {
              return this.openLens();
            }
          }

          return false;
        }

        zoomOut() {
          if (this.ready && this.zoom) {
            return this.zoom.hide();
          }

          return false;
        }

        getCurrentFrame() {
          if (this.ready) {
            const img = this.imagesMap.getCurrentImage({
              width: this.currentSize.width,
              height: this.currentSize.height
            });
            return {
              row: img.row + 1,
              column: img.col + 1
            };
          }

          return false;
        }

        get originImageUrl() {
          if (this.ready) {
            return this.imagesMap.originImageUrl;
          }

          return null;
        }

        setCallback(name, fn) {
          if (this.ready) {
            this.option(name, fn);
            return true;
          }

          return false;
        }

        setImageSize() {
          this.currentImageSize.width = this.currentSize.width;
          this.currentImageSize.height = this.currentSize.height;
        }

        isZoomSizeExist() {
          let result = false; // const minZoom = 1.2;

          const minZoomFactor = 100; // like in deep zoom level calculation

          if (this.option('zoom.enable')) {
            const cs = this.currentImageSize;
            const zoomSize = this.zoomSize;

            if (zoomSize.originWidth - cs.width >= minZoomFactor) {
              result = true;
            }
          }

          return result;
        }

        get orientation() {
          return this.imagesMap.getHintType();
        }

        onResize() {
          if (this.fullscreenState === globalVariables.FULLSCREEN.OPENING || !this.isStarted) {
            return false;
          }

          const isFullscreen = this.fullscreenState === globalVariables.FULLSCREEN.OPENED;
          this.stopSmoothing();

          if (this.option('autospin.enable')) {
            this.animationCloud.pause();
          } else {
            this.stopAnimation();
          }

          this.boxBoundaries = this.coreNode.rect;
          this.currentSize = helper.spinLib.calcProportionSize($(this.coreNode.node.parentNode).size, this.infoSize, isFullscreen, this.standardSize);
          this.getDPPX(this.currentSize);
          this.standardSize.width = this.currentSize.width;
          this.standardSize.height = this.currentSize.height;
          this.setImageSize();
          this.setCanvasSize();
          this.calcMinSizeForDrag();

          if (this.isZoomSizeExist()) {
            this.coreNode.addClass(globalVariables.CSS_CURSOR_ZOOM_IN);
          } else {
            this.coreNode.removeClass(globalVariables.CSS_CURSOR_ZOOM_IN);
          }

          if (this.zoom) {
            this.zoom.onResize();
          }

          if (!this.imagesMap.isImagesExist({
            width: this.currentSize.width,
            height: this.currentSize.height
          })) {
            this.imagesMap.loadImages({
              width: this.currentSize.width,
              height: this.currentSize.height,
              dppx: this.dppx
            });
          }

          if (this.firstImageLoaded) {
            this.draw();
          }

          if (this.ready && this.hotspots) {
            this.hotspots.containerSize = this.canvasContainer.node.getBoundingClientRect();
            this.hotspots.updateAndShow();
          }

          this.resizeAnimationTimer();
          return true;
        } // @Override, HotspotInstance class


        getContainerForBoundengClientRect() {
          return this.canvasContainer;
        }

        destroy() {
          this.instanceNode.removeEvent('touchmove', fnStopTouchMove);
          $J.W.removeEvent('resize', this.windowResizeCallback);
          clearTimeout(this.resizeWindowTimer);

          if (this.isInited) {
            this.sendStats('sessionEnd', +new Date() - this.sessionStartTime, {
              message: 'Stopped'
            });
          }

          this.coreNode.removeEvent(['btnclick', 'tap']);
          this.coreNode.del('instance');
          this.resizeAnimationTimer.cancel();
          this.resizeAnimationTimer = null;

          if (this.touchDragCloud) {
            this.touchDragCloud.removeEvent();
            this.touchDragCloud = null;
          }

          if (this.placeholder) {
            this.placeholder.setCssProp('display', '');
          }

          if (this.keyPressHandlerForShiftButton) {
            $J.W.removeEvent(['keydown', 'keyup'], this.keyPressHandlerForShiftButton);
            this.keyPressHandlerForShiftButton = null;
          }

          if (this.cssId > -1) {
            $J.removeCSS(this.id + '-css', this.cssId);
            $J.$(this.id + '-css').remove();
          }

          this.cssId = -1;

          if (this.initNameEvent) {
            this.coreNode.removeEvent(this.initNameEvent, this.initFnEvent);
          }

          if (this.activatedCurtain) {
            this.activatedCurtain.destroy();
          }

          this.stopSmoothing();
          this.stopAnimation();

          if (this.hint) {
            this.hint.destroy();
            this.hint = null;
          }

          this.coreNode.removeEvent(['mousedrag', 'touchdrag', 'pinch']);

          if (this.loader) {
            this.loader.destroy();
            this.loader = null;
          }

          if (this.imagesMap) {
            this.imagesMap.destroy();
            this.imagesMap = null;
            this.off('mapFirstImageLoaded');
            this.off('mapImagesReady');
            this.off('mapImageLoaded');
            this.off('mapAllImagesLoaded');
          } // this.additionalCanvases = [];


          this.clearCanvas();

          if (this.canvas) {
            this.canvas.removeEvent('transform');
            this.canvas.removeClass(this.zoomClassName);
            this.canvas.remove();
          }

          this.canvasContainer.removeEvent('transform');
          this.canvasContainer.removeEvent('mouseover');
          this.canvasContainer.removeEvent('mouseout');
          this.canvasContainer.remove();
          this.canvasContainer = null;
          this.ctx = null;
          this.canvas = null;
          this.loadedImages = [];
          this.off('isSingleSlide');
          this.off('zoomUp');
          this.off('zoomDown');
          this.off('frameChange');
          this.coreNode.remove();
          this.infoSize = null;
          this.startLoadingTime = null;
          this.isInited = false;
          this.openedImg = null;
          this.coreNode = null;
          this.firstUserInteraction = false;

          if (this.animationCloud) {
            clearTimeout(this.animationCloud.hintTimer);
            this.animationCloud = null;
          }

          this.lastImg = null;
          this.hotspotsData = null;
          super.destroy();
          return true;
        }

      }

      return Spin;
    });
    Sirv.define('Zoom', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter', 'Zoominstance', 'Hint', 'ResponsiveImage', 'RoundLoader', 'Hotspots'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter, Zoominstance, Hint, ResponsiveImage, RoundLoader, Hotspots) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('Zoom', () => {
        return '.smv-zoom-view{display:inline-block;position:relative;top:0;left:0;width:100%;height:100%;outline:0!important;backface-visibility:hidden!important;-ms-user-select:none!important;user-select:none!important;-webkit-tap-highlight-color:transparent!important;-webkit-touch-callout:none!important;touch-action:pan-y}.smv-zoom-view::after{display:inline-block;height:100%;content:\'\';vertical-align:middle}.smv-zoom-view .zoom-loader{bottom:0;left:0;margin:5px}.smv-zoom-view>img.smv-zoomed-in{visibility:hidden!important}.smv-zoom-view .sirv-zoom{z-index:126}.smv .smv-slides-box .smv-zoom-view>img{display:inline-block!important;position:relative!important;width:auto;max-width:100%;height:auto;max-height:100%;margin:0;padding:0;vertical-align:middle}.zoom-controls{display:flex;position:absolute;right:16px;bottom:16px;flex-flow:row-reverse;height:28px;z-index:168}.zoom-controls>button{background-color:rgba(245,245,245,.9);color:#777}.zoom-controls>button::after,.zoom-controls>button::before{transition:opacity .2s linear;opacity:.65}.zoom-controls>button:hover::after,.zoom-controls>button:hover::before{opacity:1}.zoom-controls>button.disable::after,.zoom-controls>button.disable::before{opacity:.2}.zoom-controls>button+button{margin-right:4px}.zoom-controls .zoom-close,.zoom-controls .zoom-in,.zoom-controls .zoom-out{display:inline-block;position:relative;width:28px;height:28px;padding:0;border:1px solid #d7d7d7;border-radius:2px;outline:0;cursor:pointer}.zoom-controls .zoom-close::after,.zoom-controls .zoom-close::before,.zoom-controls .zoom-in::after,.zoom-controls .zoom-in::before,.zoom-controls .zoom-out::before{transform:translate3d(-50%,-50%,0);position:absolute;top:50%;left:50%;width:65%;border-top:2px solid currentcolor;font-size:0;line-height:100%;content:\'\'}.zoom-controls .zoom-close::after,.zoom-controls .zoom-in::after{transform-origin:center;border-left:1px solid}.zoom-controls .zoom-in::after{transform:translate3d(-50%,-50%,0) rotateZ(-90deg)}.zoom-controls .zoom-close{display:none!important}.zoom-controls .zoom-close::before{transform:translate3d(-50%,-50%,0) rotateZ(-45deg)}.zoom-controls .zoom-close::after{transform:translate3d(-50%,-50%,0) rotateZ(-135deg)}';
      });
      /* end-removable-module-css */

      /* eslint-env es6 */

      /* global helper */

      /* eslint-disable no-extra-semi */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      let defaults = {
        mode: {
          type: 'string',
          'enum': ['top', 'left', 'right', 'bottom', 'inner', 'magnifier', 'deep'],
          defaults: 'inner'
        },
        margin: {
          type: 'number',
          defaults: 9
        },
        width: {
          oneOf: [{
            type: 'number'
          }, {
            type: 'string',
            'enum': ['auto']
          }],
          defaults: 'auto'
        },
        height: {
          oneOf: [{
            type: 'number'
          }, {
            type: 'string',
            'enum': ['auto']
          }],
          defaults: 'auto'
        },
        pan: {
          type: 'boolean',
          defaults: false
        },
        ratio: {
          oneOf: [{
            type: 'number',
            minimum: 0
          }, {
            type: 'string',
            'enum': ['max']
          }],
          defaults: 2.5
        },
        wheel: {
          type: 'boolean',
          defaults: true
        },
        // Zoom in/out on mouse wheel
        tiles: {
          type: 'boolean',
          defaults: true
        },
        trigger: {
          oneOf: [{
            type: 'string',
            'enum': ['hover', 'click', 'dblclick']
          }, {
            type: 'boolean',
            'enum': [false]
          }],
          defaults: 'click'
        },
        hint: {
          // hint.enable
          enable: {
            type: 'boolean',
            defaults: true
          },
          text: {
            // hint.text.hover
            hover: {
              type: 'string',
              defaults: 'Hover to zoom'
            },
            // hint.text.click
            click: {
              type: 'string',
              defaults: 'Click to zoom'
            },
            // hint.text.dblclick
            dblclick: {
              type: 'string',
              defaults: 'Double click to zoom'
            }
          }
        },
        // Navigation map
        map: {
          // map.enable
          enable: {
            type: 'boolean',
            defaults: false
          },
          // map.size
          size: {
            type: 'number',
            'minimum': 0,
            'maximum': 50,
            defaults: 25
          } // in percentage

        }
      };

      if ($J.browser.touchScreen) {
        defaults = helper.deepExtend(defaults, {
          hint: {
            text: {
              // hint.text.hover
              hover: {
                defaults: 'Tap and hold to zoom'
              }
            }
          }
        });
      }

      const defaultsForMobileZoomOptions = {
        hint: {
          text: {
            // hint.text.hover
            hover: {
              type: 'string',
              defaults: 'Tap and hold to zoom'
            },
            // hint.text.click
            click: {
              type: 'string',
              defaults: 'Tap to zoom'
            },
            // hint.text.dblclick
            dblclick: {
              type: 'string',
              defaults: 'Double tap to zoom'
            }
          }
        }
      };
      const defaultsForOutsideMode = {
        trigger: {
          oneOf: [{
            type: 'string',
            'enum': ['hover', 'click', 'dblclick']
          }, {
            type: 'boolean',
            'enum': [false]
          }],
          defaults: 'hover'
        }
      };
      const defaultsForMobileInnerMode = {
        trigger: {
          oneOf: [{
            type: 'string',
            'enum': ['hover', 'click', 'dblclick']
          }, {
            type: 'boolean',
            'enum': [false]
          }],
          defaults: 'dblclick'
        }
      };
      const defaultsForDeepZoom = {
        ratio: {
          oneOf: [{
            type: 'number',
            minimum: 0
          }, {
            type: 'string',
            'enum': ['max']
          }],
          defaults: 'max'
        }
      };
      /* eslint-env es6 */

      /* global EventEmitter */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint dot-notation: ["error", { "allowKeywords": false }]*/
      // eslint-disable-next-line no-unused-vars

      class ButtonClass extends EventEmitter {
        constructor(parent, options, events) {
          super();
          this.parentNode = $(parent);
          this.options = Object.assign({
            'class': null,
            disabledClass: 'disable'
          }, options);
          this.events = events || {};
          this.disabled = false;
          this.isDisabledClassAdded = false;
          this.instanceNode = $J.$new('button');

          if (this.options['class']) {
            this.instanceNode.addClass(this.options['class']);
          }

          Object.entries(this.events).forEach(event => {
            this.instanceNode.addEvent(...event);
          });
        }

        append() {
          this.parentNode.append(this.instanceNode);
        }

        changeState(disable) {
          if (disable) {
            this.disable(true);

            if (!this.isDisabledClassAdded) {
              this.isDisabledClassAdded = true;
              this.instanceNode.addClass(this.options.disabledClass);
            }
          } else {
            if (this.isDisabledClassAdded) {
              this.isDisabledClassAdded = false;
              this.instanceNode.removeClass(this.options.disabledClass);
            }

            this.disable();
          }
        }

        disable(disable) {
          if (disable) {
            if (!this.disabled) {
              this.disabled = true;
              this.instanceNode.attr('disabled', 'disabled');
            }
          } else if (this.disabled) {
            this.disabled = false;
            this.instanceNode.removeAttr('disabled');
          }
        }

        destroy() {
          Object.entries(this.events).forEach(event => {
            this.instanceNode.removeEvent(...event);
          });
          this.events = {};
          this.changeState();
          this.instanceNode.remove();
          this.instanceNode = null;
          super.destroy();
        }

      } // eslint-disable-next-line no-unused-vars


      class ZoomControls extends EventEmitter {
        constructor(parent) {
          super();
          this.parentNode = $(parent);
          this.instanceNode = $J.$new('div').addClass('zoom-controls');
          this.zoomInButton = new ButtonClass(this.instanceNode, {
            'class': 'zoom-in'
          }, {
            'btnclick': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomin'
                }
              });
            },
            'tap': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomin'
                }
              });
            }
          });
          this.zoomInButton.parentClass = this;
          this.zoomOutButton = new ButtonClass(this.instanceNode, {
            'class': 'zoom-out'
          }, {
            'btnclick': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomout'
                }
              });
            },
            'tap': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomout'
                }
              });
            }
          });
          this.zoomOutButton.parentClass = this;
          this.zoomCloseButton = new ButtonClass(this.instanceNode, {
            'class': 'zoom-close'
          }, {
            'btnclick': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomclose'
                }
              });
            },
            'tap': e => {
              e.stop();
              this.emit('zoomControlsAction', {
                data: {
                  type: 'zoomclose'
                }
              });
            }
          });
          this.zoomCloseButton.parentClass = this;
          this.zoomInButton.append();
          this.zoomOutButton.append();
          this.zoomCloseButton.append();
        }

        show() {
          this.parentNode.append(this.instanceNode);
        }

        hide() {
          this.instanceNode.remove();
        }

        invisibleDisable(disable) {
          this.zoomInButton.disable(disable);
          this.zoomOutButton.disable(disable);
          this.zoomCloseButton.disable(disable);
        }

        disable(typeOfButton
        /* in, out */
        ) {
          if (typeOfButton) {
            if (typeOfButton === 'in') {
              this.zoomInButton.changeState(true);
              this.zoomOutButton.changeState();
              this.zoomCloseButton.changeState();
            } else {
              this.zoomOutButton.changeState(true);
              this.zoomCloseButton.changeState(true);
              this.zoomInButton.changeState();
            }
          } else {
            this.zoomInButton.changeState();
            this.zoomOutButton.changeState();
            this.zoomCloseButton.changeState();
          }
        }

        destroy() {
          this.zoomInButton.destroy();
          this.zoomOutButton.destroy();
          this.zoomCloseButton.destroy();
          this.hide();
          super.destroy();
        }

      }
      /* eslint-env es6 */

      /* global ZoomControls */

      /* global helper */

      /* global Zoominstance */

      /* global Hint */

      /* global Hotspots */

      /* global ResponsiveImage */

      /* global RoundLoader */

      /* global globalFunctions */

      /* global globalVariables */

      /* global defaults */

      /* global defaultsForDeepZoom */

      /* global defaultsForMobileZoomOptions */

      /* global defaultsForOutsideMode */

      /* global defaultsForMobileInnerMode */

      /* eslint-disable indent */

      /*eslint consistent-return: 0*/

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint class-methods-use-this: ["off", { "imageSettings": ["error"] }] */
      // eslint-disable-next-line no-unused-vars


      const Zoom = (() => {
        const P = 'smv';
        const BRAND_LANDING = 'https://sirv.com/about-zoom/?utm_source=client&utm_medium=sirvembed&utm_content=typeofembed(zoom)&utm_campaign=branding';

        const stopEvent = e => {
          e.stop();
        };

        const difference = (value1, value2) => {
          return Math.abs(value1 - value2);
        };

        const getContainerForZoom = container => {
          let result = null;

          while (container.node !== $J.D.node.body && !result) {
            container = $(container.node.parentNode);

            if (container.hasClass(P + '-slides-box')) {
              result = container;
            }
          }

          return result;
        };

        const getNodeSize = (node, count) => {
          return new Promise((resolve, reject) => {
            const size = $(node).size;

            if (!count) {
              count = 100;
            }

            count -= 1;

            if (size.width || size.height) {
              resolve(size);
            } else if (count > 0) {
              setTimeout(() => {
                getNodeSize(node, count).then(resolve).catch(reject);
              }, 16);
            } else {
              reject(null);
            }
          });
        };

        class Zoom_ extends Zoominstance {
          constructor(node, options) {
            super(node, options, defaults);
            this.type = globalVariables.SLIDE.TYPES.ZOOM;
            this.insideOptions = {
              type: 'outside',
              // inner, circle, square, outside
              position: 'right',
              // top, left, right, bottom
              hideZoomForClickTrigger: true,
              zooming: true,
              map: false,
              mapSize: 50,
              controls: false,
              trigger: 'click',
              outsideModeWasChanged: false
            };
            this.imageUrl = this.instanceNode.attr('data-src'); // Image URL

            this.src = globalFunctions.normalizeURL(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$1')); // Image default params

            this.queryParams = helper.paramsFromQueryString(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$2'));

            if (this.queryParams) {
              const q = parseInt(this.queryParams.quality, 10);

              if (isNaN(q)) {
                delete this.queryParams.quality;
              } else {
                this.queryParams.quality = q;
              }
            }

            this.isFullscreen = options.isFullscreen;
            this.nativeFullscreen = options.nativeFullscreen;
            this.queryParamsQuality = this.queryParams.quality || null;
            this.imageNode = null;
            this.loader = null;
            this.image = null;
            this.controls = null;
            this.differenceBetweenSizes = 100;
            this.currentSize = {
              width: 0,
              height: 0
            };
            this.currentImageSize = {
              width: 0,
              height: 0
            };
            this.isInfoLoaded = false;
            this.zoomIsOpened = false;
            this.imageShowPromise = null;
            this.hint = null;
            this.longTapTimer = null;
            this.setImageCss = false;
            this.lastTriggerAction = null;
            this.isNotMouse = false;
            this.accountInfo = {};
            this.postInitState = 0;
            this.clonedImage = null;
            this.isHidden = false;
            this.destroyed = false;
            this.waitingCallbacks = []; // just for outsize zoom

            this.lastImageSize = {
              width: 0,
              height: 0
            };
            this.hotspotsTurnedOn = true;
            this.scrollDebounce = helper.debounce(() => {
              this.replaceZoom();
            }, 16);
            this.zoomDebounce = helper.debounce(() => {
              if (this.controls) {
                this.controls.invisibleDisable();
                this.changeControlsState(this.zoom.getZoomData());
              }
            }, 42);
            this.onScrollHandler = this.onScroll.bind(this);
            this.instanceNode.addEvent('selectstart', e => {
              e.stop();
            }); // in order to not search it in different classes
            // this.api = Object.assign(this.api, {
            // resize: this.resize.bind(this), // parent class
            // zoomIn: this.zoomIn.bind(this), // parent class
            // zoomOut: this.zoomOut.bind(this), // parent class
            // isZoomed: this.isZoomed.bind(this), // parent class
            // isReady: this.isReady.bind(this), // parent class
            // getOptions: this.getOptions.bind(this), // parent class
            // hotspots: {} // parent class, hotspots api
            // });

            this.createHotspotsClass();
            this.createSirvImage();
          }

          makeOptions() {
            let options = new $J.Options(this.defaultSchema);
            options = this.makeGlobalOptions(options);

            if (['top', 'left', 'right', 'bottom', 'inner', 'magnifier'].includes(options.get('mode'))) {
              options.parseSchema(defaultsForOutsideMode, true);
            }

            if ($J.browser.touchScreen && $J.browser.mobile) {
              options.parseSchema(defaultsForMobileZoomOptions, true);
              options = this.makeMobileOptions(options);

              if (['inner', 'deep'].includes(options.get('mode'))) {
                options.parseSchema(defaultsForMobileInnerMode, true);
              }
            }

            if (options.get('mode') === 'deep') {
              options.parseSchema(defaultsForDeepZoom, true);
            }

            return options;
          }

          getInfo() {
            if (!this.gettingInfoPromise) {
              this.gettingInfoPromise = new Promise((resolve, reject) => {
                this.waitGettingInfo.wait(() => {
                  this.image.loadInfo().then(info => {
                    if (!this.destroyed) {
                      this.isInfoLoaded = true;
                      this.accountInfo = this.image.accountInfo;

                      if (!this.dataAlt) {
                        this.dataAlt = this.image.description;
                      }

                      this.hotspotsData = info.hotspots;
                      this.infoSize = this.image.originSize;

                      if (this.hotspots) {
                        this.hotspots.originImageSize = this.infoSize;
                      }

                      resolve();
                    }
                  }).catch(err => {
                    if (!this.destroyed) {
                      reject(err);
                    }
                  });
                });
              });
            }

            return this.gettingInfoPromise;
          }

          showHint() {
            if (this.hint) {
              if (!this.always || [globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState)) {
                this.hint.show();
              }
            }
          }

          onStartActions() {
            if (this.ready) {
              if (this.isInView && this.isZoomSizeExist()) {
                this.showHint();
              }
            } else if (this.isStarted) {
              if (this.isInView && this.isSlideShown && !this.preload) {
                this.postInit();
              }
            }

            super.onStartActions();
          }

          onStopActions() {
            this.zoomOut(true);

            if (this.hint) {
              this.hint.hide();
            }

            super.onStopActions();
          }

          onInView(value) {
            if (value) {
              if (this.ready) {
                if (this.isSlideShown && this.isZoomSizeExist()) {
                  this.showHint();
                }
              } else if (this.isStarted) {
                if (!this.isInView && (this.preload || this.isSlideShown)) {
                  this.isInView = true;
                  this.postInit();
                }
              }
            }
          }

          startFullInit(options) {
            if (this.isStartedFullInit) {
              return;
            }

            super.startFullInit(options); // if (options && options.lensContainer) {
            //     this.zoomContainer = options.lensContainer;
            // }

            this.normalizeOptions();
            this.getId('zoom-');
            this.instanceNode.addClass(P + '-zoom-view');
            this.instanceNode.addEvent('mousedown', stopEvent);
            this.createLoader();
          }

          imageSettings(options) {
            if (!options) {
              options = {};
            }

            if (!options.imageSettings) {
              options.imageSettings = {};
            }

            if (!options.imageSettings.scale) {
              options.imageSettings.scale = {};
            }

            if (!options.callbackData) {
              options.callbackData = {};
            }

            options.imageSettings.scale.option = 'fill';

            if (this.quality !== null && this.queryParamsQuality === null) {
              if (!options.src) {
                options.src = {};
              }

              options.src.quality = this.quality;
            }

            const hdQuality = this.hdQuality;

            if (this.queryParamsQuality === null || this.isHDQualitySet && hdQuality < this.queryParamsQuality) {
              options.srcset = {
                quality: hdQuality
              };
            }

            return options;
          }

          setHDQuality(data) {
            if (data.dppx > 1 && data.dppx < 1.5) {
              if (this.queryParamsQuality === null && this.quality !== null) {
                data.srcset.quality = this.quality;
              } else if (data.srcset) {
                delete data.srcset.quality;
              }
            }

            return data;
          }

          isOutsideZoom() {
            return ['top', 'left', 'right', 'bottom'].includes(this.option('mode'));
          }

          createHint(message) {
            if (this.option('hint.enable')) {
              this.hint = new Hint(this.instanceNode, {
                html: '<span>' + message + '<span>'
              });
              this.hint.append();
            }
          }

          clearZoom() {
            if (this.zoom) {
              this.off('zooming');
              this.off('zoomUp');
              this.off('zoomDown');

              if (this.imageNode) {
                this.imageNode.removeClass(this.zoomClassName);
              }
            }

            super.clearZoom();
          }

          replaceZoom() {
            let trigger = false;
            const currentTrigger = this.option('trigger');
            const zoomOptions = {
              clickBehavior: 'both'
            };

            if (!this.ready) {
              return;
            }

            if (currentTrigger === 'hover' && this.option('mode') !== 'magnifier') {
              if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState)) {
                trigger = 'click';
                zoomOptions.trigger = trigger;
              } else {
                trigger = currentTrigger;
              }
            }

            let createNewZoom = trigger && this.insideOptions.trigger !== trigger;

            if (trigger && this.insideOptions.trigger !== trigger) {
              createNewZoom = true;
            }

            let canIUse;

            if (this.insideOptions.type === 'outside') {
              canIUse = this.canIUseOutsideZoom();

              if (canIUse && this.insideOptions.outsideModeWasChanged || !canIUse && !this.insideOptions.outsideModeWasChanged) {
                this.insideOptions.outsideModeWasChanged = !this.insideOptions.outsideModeWasChanged;
                createNewZoom = true;
              } // if the image checnge size the window of outside zoom must chenge too


              const imageSize = this.imageNode.size;

              if (!createNewZoom && canIUse && this.lastImageSize.width !== imageSize.width) {
                this.lastImageSize = imageSize;
                createNewZoom = true;
              }
            }

            if (createNewZoom) {
              this.clearZoom();

              if (this.insideOptions.type === 'outside') {
                if (canIUse) {
                  zoomOptions.type = 'outside';
                } else {
                  zoomOptions.type = 'inner';

                  if ($J.browser.mobile) {
                    zoomOptions.pan = true;

                    if (currentTrigger === 'hover') {
                      trigger = 'dblclick';
                      zoomOptions.trigger = trigger;
                    }
                  }
                }
              }

              if (trigger) {
                this.insideOptions.trigger = trigger;
              }

              this.setTriggerAction(trigger);
              this.createZoom(zoomOptions);
              this.setZoomEvents();
            }
          }

          canIUseOutsideZoom() {
            let result = false;

            if (this.insideOptions.type === 'outside') {
              if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState)) {
                return result;
              }

              const margin = this.option('margin');
              const zoomSize = this.imageNode.size;
              const scroll = $J.W.scroll;
              const pos = this.imageNode.position;
              const w = this.option('width');
              const h = this.option('height');
              const size = {
                width: zoomSize.width,
                height: zoomSize.height
              };

              if (w !== 'auto') {
                if (/%$/.test(w)) {
                  zoomSize.width = zoomSize.width / 100 * parseInt(w, 10);
                } else {
                  zoomSize.width = parseInt(w, 10);
                }
              }

              if (h !== 'auto') {
                if (/%$/.test(h)) {
                  zoomSize.height = zoomSize.height / 100 * parseInt(h, 10);
                } else {
                  zoomSize.height = parseInt(h, 10);
                }
              }

              let tmp;

              switch (this.insideOptions.position) {
                case 'top':
                  tmp = pos.top - scroll.y - margin;

                  if (tmp > zoomSize.height) {
                    result = true;
                  }

                  break;

                case 'left':
                  tmp = pos.left - scroll.x - margin;

                  if (tmp >= zoomSize.width) {
                    result = true;
                  }

                  break;

                case 'right':
                  tmp = pos.left - scroll.x;
                  tmp += size.width + margin;

                  if ($J.W.node.innerWidth - tmp >= zoomSize.width) {
                    result = true;
                  }

                  break;

                case 'bottom':
                  tmp = pos.top - scroll.y;
                  tmp += size.height + margin;

                  if ($J.W.node.innerHeight - tmp >= zoomSize.height) {
                    result = true;
                  }

                  break;
                // no default
              }
            }

            return result;
          }

          createHotspotsClass() {
            if (this.option('mode') === 'magnifier') {
              return;
            }

            if (!$J.browser.mobile && this.option('trigger') === 'hover') {
              this.hotspotsTurnedOn = false;
            }

            super.createHotspotsClass(Hotspots);
          }

          run(isShown, preload, firstSlideAhead) {
            const result = super.run(isShown, preload, firstSlideAhead);

            if (result) {
              this.getInfo().finally(() => {
                this.calcContainerSize();

                if (this.isInView && (this.preload || this.isSlideShown)) {
                  this.postInit();
                }
              });
              this.startGettingInfo();
            }

            return result;
          }

          done() {
            if (!this.ready && !this.destroyed) {
              super.done();

              if (this.hotspots) {
                this.hotspots.instanceComponentNode = this.imageNode;
                this.hotspots.containerSize = this.imageNode.node.getBoundingClientRect();
              }

              this.createZoom();
              this.replaceZoom();
              this.createControls();
              const zoomable = this.isZoomSizeExist();

              if (this.controls) {
                this.controls.disable('out');

                if (zoomable) {
                  this.controls.show();
                }
              }

              if (this.imageNode && zoomable) {
                this.imageNode.addClass(globalVariables.CSS_CURSOR_ZOOM_IN);
              }

              this.setZoomEvents();

              if (this.isSlideShown && this.isInView && zoomable) {
                this.showHint();
              }

              if (this.accountInfo.branded) {
                const nodeWithSirvClassName = globalFunctions.getNodeWithSirvClassName(this.instanceNode) || $J.D.node.head || $J.D.node.body;
                globalFunctions.rootDOM.showSirvAd(nodeWithSirvClassName, this.instanceNode, BRAND_LANDING, 'Deep zoom image viewer by Sirv');
              }
            }
          }

          normalizeOptions() {
            if (this.option('mode') !== 'deep') {
              this.option('map.enable', false);
            }

            if (this.option('mode') === 'deep' || $J.browser.mobile) {
              this.option('pan', true);
            }

            if (this.option('mode') === 'magnifier' && !$J.browser.mobile) {
              this.option('pan', false);
            }

            if (!this.isOutsideZoom()) {
              if (this.option('width') === 'auto' && this.option('height') === 'auto') {
                this.option('width', '70%');
              }
            }

            switch (this.option('trigger')) {
              case 'hover':
                if (this.option('mode') === 'deep') {
                  this.option('trigger', 'click');
                }

                break;

              case 'click':
              case 'dblclick':
                break;

              default:
                this.option('trigger', false);
            }

            switch (this.option('mode')) {
              case 'top':
              case 'left':
              case 'right':
              case 'bottom':
                this.insideOptions.type = 'outside';
                this.insideOptions.position = this.option('mode');
                break;

              case 'magnifier':
                this.insideOptions.type = 'circle';
                break;

              case 'inner':
                this.insideOptions.type = 'inner';
                break;

              case 'deep':
                this.insideOptions.type = 'deep';
                this.insideOptions.controls = true;
                break;
              // no default
            }

            if (this.insideOptions.type === 'deep' && this.option('map.enable')) {
              this.insideOptions.map = this.option('map.size') !== 0;

              if (this.insideOptions.map) {
                this.insideOptions.mapSize = 100 / 50 * this.option('map.size');
              }
            }

            this.insideOptions.trigger = this.option('trigger');

            if ($J.browser.mobile) {
              this.insideOptions.hideZoomForClickTrigger = false;
            }

            if (this.option('ratio') !== 'max' && this.option('ratio') < globalVariables.MIN_RATIO) {
              this.option('ratio', 0);
            }

            this.setDefaultZoomOptions();
          }

          setDefaultZoomOptions() {
            const isDeep = this.insideOptions.type === 'deep';
            super.setDefaultZoomOptions();
            this.defaultZoomOptions = Object.assign(this.defaultZoomOptions, {
              trigger: this.option('trigger'),
              tiles: this.option('tiles'),
              width: this.option('width'),
              height: this.option('height'),
              map: this.insideOptions.map,
              clickBehavior: isDeep ? 'up' : 'both',
              outsidePosition: this.insideOptions.position,
              margin: this.option('margin'),
              type: isDeep ? 'inner' : this.insideOptions.type,
              pan: this.option('pan'),
              customZooming: this.option('wheel'),
              mapSize: this.insideOptions.mapSize
            });
          }

          onZoomGetImage(e) {
            super.onZoomGetImage(e);
            e.data = this.imageSettings(e.data);
            e.data = this.setHDQuality(e.data);
            const img = this.image.getImage(e.data);

            if (this.checkImage(e.data, e.data.dontLoad)) {
              this.zoom.addLoadedImage(img);
            }
          }

          onZoomCancelLoadingOfTiles(e) {
            super.onZoomCancelLoadingOfTiles(e);
            e.data = this.imageSettings(e.data);
            this.image.cancelLoadingImage(e.data);
          } // eslint-disable-next-line


          onZoomBeforeShow(e) {
            if (this.option('mode') !== 'magnifier') {
              if (this.insideOptions.type === 'outside' && !this.insideOptions.outsideModeWasChanged) {
                this.imageNode.addClass('sirv-filter-bw');
              } else {
                this.imageNode.addClass(this.zoomClassName);
              }

              if (this.hotspots) {
                this.hotspots.disableAll();
              }
            }
          } // eslint-disable-next-line


          onZoomShown(e) {
            if (this.isSlideShown) {
              this.sendEvent('zoomIn', {
                trigger: this.option('trigger'),
                isOutsideZoom: this.isOutsideZoom()
              });
            }
          } // eslint-disable-next-line


          onZoomHidden(e) {
            this.imageNode.removeClass(this.zoomClassName);
            this.imageNode.removeClass('sirv-filter-bw');
            this.sendEvent('zoomOut');
            this.isNotMouse = false;
            this.zoomIsOpened = false;

            if (this.pinchCloud) {
              this.pinchCloud.addEvent();
            }

            if (this.hotspots) {
              if (this.hotspotsTurnedOn && [globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.OPENING].includes(this.fullscreenState) || this.insideOptions.trigger !== 'hover' && [globalVariables.FULLSCREEN.OPENED, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
                this.hotspots.enableAll();

                if (this.isInView && this.isSlideShown) {
                  this.hotspots.showNeededElements();
                }
              }
            }
          }

          setZoomEvents() {
            super.setZoomEvents();
            this.on('zooming', e => {
              const zoom = e.data.zoom;
              e.stopAll();

              if (this.controls) {
                this.controls.invisibleDisable(true);
                this.changeControlsState(zoom);
                this.zoomDebounce();
              }
            });
            this.on('zoomUp', e => {
              e.stop();
              this.makeZoom('zoomin', e.data.x, e.data.y);
            });
            this.on('zoomDown', e => {
              e.stop();
              this.makeZoom('zoomout', e.data.x, e.data.y);
            });
          } // eslint-disable-next-line no-unused-vars


          onBeforeFullscreenIn(data) {
            if (this.zoomIsOpened) {
              this.zoom.hide(true);

              if (this.controls) {
                this.controls.disable('out');
              }
            }

            if (this.ready && this.isSlideShown && this.isInView && !!this.imageNode) {
              this.isHidden = true;
              this.imageNode.setCss({
                opacity: 0,
                visibility: 'hidden'
              });
            }

            super.onBeforeFullscreenIn(data);

            if (this.hotspots) {
              this.hotspots.disableAll();
            }
          } // eslint-disable-next-line no-unused-vars


          onAfterFullscreenIn(data) {
            this.calcContainerSize();
            this.replaceZoom();

            if (this.isHidden) {
              this.isHidden = false;
              setTimeout(() => {
                this.setImageWidthHeight();
                this.imageNode.setCss({
                  opacity: '',
                  visibility: ''
                });
              }, 0);
            } // if we use it, we do not have pinchend event and touchdrag after that
            // if (this.pinchCloud) {
            //     this.pinchCloud.removeEvent();
            //     this.pinchCloud.addEvent();
            // }


            if (this.hotspots) {
              setTimeout(() => {
                // we have to wait a little bit for 'onResize' function
                if (this.hotspotsTurnedOn && this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                  // if we will exit from fullscreen before the timeout end
                  this.hotspots.enableAll();

                  if (this.isInView && this.isSlideShown) {
                    this.hotspots.showNeededElements();
                  }
                }
              }, 100);
            }
          } // eslint-disable-next-line no-unused-vars


          onBeforeFullscreenOut(data) {
            if (this.zoomIsOpened) {
              this.zoom.hide(true);

              if (this.controls) {
                this.controls.disable('out');
              }
            }

            super.onBeforeFullscreenOut(data);

            if (this.hotspots) {
              if (!this.hotspotsTurnedOn) {
                this.hotspots.disableAll();
              }
            } // if (this.option('mode') === 'magnifier') {
            //     this.zoom.lensContainer = $J.D.node.body;
            // }


            this.replaceZoom();

            if (this.ready && this.isSlideShown && this.isInView && !!this.imageNode) {
              this.isHidden = true;
              this.imageNode.setCss({
                opacity: 0,
                visibility: 'hidden'
              });
            }
          } // eslint-disable-next-line no-unused-vars


          onAfterFullscreenOut(data) {
            if (this.isHidden) {
              this.isHidden = false;
              setTimeout(() => {
                if (!this.destroyed) {
                  this.setImageWidthHeight();
                  this.imageNode.setCss({
                    opacity: '',
                    visibility: ''
                  });
                }
              }, 0);
            }

            super.onAfterFullscreenOut(data); // if we use it, we do not have pinchend event and touchdrag after that
            // if (this.pinchCloud) {
            //     this.pinchCloud.removeEvent();
            //     this.pinchCloud.addEvent();
            // }
          }

          onSecondSelectorClick() {
            this.zoomOut(true);
          }

          onMouseAction(type) {
            if (type === 'mouseout') {
              if (!['deep', 'magnifier'].includes(this.option('mode')) && (this.insideOptions.type === 'outside' && this.insideOptions.outsideModeWasChanged || this.insideOptions.type === 'inner') && (this.insideOptions.trigger === 'hover' || this.insideOptions.hideZoomForClickTrigger) && !this.isNotMouse) {
                this.zoomOut(true);
              }
            }
          }

          makeZoom(direction, x, y) {
            let result = false;

            if (this.ready && this.zoom) {
              switch (direction) {
                case 'zoomin':
                  if (this.zoomIsOpened) {
                    if (this.zoom.nextMinZoom === 1) {
                      this.controls.disable('in');
                    }

                    result = this.zoom.zoomUp(x, y);
                  } else {
                    result = this.openZoom(x, y, this.insideOptions.type === 'deep' ? 'first' : false);
                  }

                  break;

                case 'zoomout':
                  if (this.zoomIsOpened) {
                    if (this.zoom.getZoomData() === 0 || this.zoom.nextMinZoom === 0) {
                      result = this.zoom.hide();

                      if (this.controls) {
                        this.controls.disable('out');
                      }
                    } else {
                      result = this.zoom.zoomDown(x, y);
                    }
                  }

                  break;

                default:
                  // why is it need
                  if (this.zoomIsOpened) {
                    result = this.zoom.hide();

                    if (this.controls) {
                      this.controls.disable('out');
                    }
                  }

              }
            }

            return result;
          }

          calcContainerSize() {
            const size = this.instanceNode.size;

            if (!size.height || !size.width) {
              const originSize = this.image.originSize;

              if (!size.height) {
                this.currentSize.width = size.width;
                this.currentSize.height = originSize.height / originSize.width * size.width;
              } else {
                this.currentSize.height = size.height;
                this.currentSize.width = originSize.width / originSize.height * size.height;
              }
            } else {
              this.currentSize = size;
            }
          }

          getImageSize() {
            let width;
            let height;
            const cs = this.currentSize;
            const is = this.image.originSize;

            if (cs.width >= cs.height) {
              height = Math.min(cs.height, is.height);
              width = is.width / is.height * height;

              if (width > cs.width) {
                width = Math.min(cs.width, is.width);
                height = is.height / is.width * width;
              }
            } else {
              width = Math.min(cs.width, is.width);
              height = is.height / is.width * width;

              if (height > cs.height) {
                height = Math.min(cs.height, is.height);
                width = is.width / is.height * height;
              }
            }

            return Object.assign({
              realWidth: width,
              realHeight: height
            }, this.image.getClearSizeWithoutProcessingSettings({
              width: width,
              height: height
            }));
          }

          setTriggerAction(tr) {
            let trigger = this.option('trigger');
            this.isNotMouse = false;

            if (this.option('ratio') !== 'max' && this.option('ratio') < globalVariables.MIN_RATIO) {
              return;
            }

            if (trigger) {
              let showHint = false;

              if (this.lastTriggerAction) {
                this.lastTriggerAction();
                this.lastTriggerAction = null;

                if (this.hint) {
                  this.hint.destroy();
                  this.hint = null;
                  showHint = true;
                }
              }

              if (tr) {
                trigger = tr;
              }

              let imageEvent;
              let hintMessage;

              switch (trigger) {
                case 'click':
                  imageEvent = ['btnclick', 'tap'];
                  hintMessage = this.option('hint.text.click');
                  break;

                case 'dblclick':
                  imageEvent = ['dblbtnclick', 'dbltap'];
                  hintMessage = this.option('hint.text.dblclick');
                  break;

                case 'hover':
                  imageEvent = 'mouseover';
                  hintMessage = this.option('hint.text.hover');

                  if ($J.browser.mobile) {
                    if (this.outsideModeWasChanged) {
                      hintMessage = this.option('hint.text.dblclick');
                      imageEvent = 'dbltap';
                      trigger = imageEvent;
                    }
                  }

                  break;
                // no default
              }

              this.createHint(hintMessage);

              if (showHint && this.isSlideShown && this.isInView && this.isZoomSizeExist()) {
                this.showHint();
              }

              const cbs = [];

              if (trigger === 'hover') {
                if ($J.browser.touchScreen) {
                  cbs.push(this.setLongTapEvents());
                }

                if (!$J.browser.mobile) {
                  cbs.push(this.setHoverEvents());
                }
              } else {
                const eventHandler = e => {
                  if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always) {
                    e.stop();

                    if (this.isFullscreenActionEnded()) {
                      const pageXY = e.pageXY;
                      this.openZoom(pageXY.x, pageXY.y, false);
                    }
                  }
                };

                if ($J.browser.touchScreen) {
                  const pointerCallback = e => {
                    this.isNotMouse = e.isTouchEvent();
                  };

                  this.imageNode.addEvent('pointerup', pointerCallback);
                  cbs.push($(cb => {
                    this.isNotMouse = false;
                    this.imageNode.removeEvent('pointerup', cb);
                  }).bind(this, pointerCallback));
                }

                this.imageNode.addEvent(imageEvent, eventHandler);
                cbs.push($((eventName, cb) => {
                  this.imageNode.removeEvent(eventName, cb);
                }).bind(this, imageEvent, eventHandler));
              }

              this.lastTriggerAction = $(_cbs => {
                $(_cbs).forEach(cb => {
                  cb();
                });
              }).bind(this, cbs);
            }
          }

          setImageSrc(src, srcset, dppx) {
            if (this.imageNode) {
              this.imageNode.attr('src', src);

              if (srcset) {
                this.imageNode.attr('srcset', srcset + ' ' + dppx + 'x');
              } else {
                this.imageNode.removeAttr('srcset');
              }

              this.clonedImage = $(this.imageNode.node.cloneNode(true));
              this.clonedImage.node.className = '';
            }
          }

          setImageWidthHeight() {
            if (!this.destroyed) {
              if (this.currentImageSize.realWidth / this.currentImageSize.realHeight >= this.currentSize.width / this.currentSize.height) {
                this.imageNode.setCss({
                  width: '100%',
                  height: ''
                });
              } else {
                this.imageNode.setCss({
                  width: '',
                  height: '100%'
                });
              }
            }
          }

          createImage(node, src, srcset, dppx) {
            if (!this.imageNode) {
              if (node) {
                this.imageNode = $(node);
              } else {
                this.imageNode = $J.$new('img');
              }

              this.imageNode.attr('referrerpolicy', this.referrerPolicy);
              const originSize = this.image.originSize;
              this.imageNode.setCss({
                maxWidth: originSize.width,
                maxHeight: originSize.height
              });
              this.setImageWidthHeight();
              this.setTriggerAction();

              if (this.option('wheel') && this.option('mode') === 'deep') {
                this.imageNode.addEvent('mousescroll', e => {
                  if (!this.zoomIsOpened && e.delta > 0) {
                    e.stop();
                    this.openZoom(e.x, e.y, 'first');
                  }
                });
              }

              $J.W.addEvent('scroll', this.onScrollHandler);

              if (this.dataAlt) {
                this.imageNode.attr('alt', this.dataAlt);
              }

              this.setImageSrc(src, srcset, dppx);
            }
          }

          setLongTapEvents() {
            let move = false;
            let touchDown = false;

            const _start = e => {
              clearTimeout(this.longTapTimer);

              if (this.zoomIsOpened || e.isTouchEvent() && !e.isPrimaryTouch()) {
                return;
              }

              if (this.isFullscreenActionEnded()) {
                this.longTapTimer = setTimeout(() => {
                  if (e.isTouchEvent() && !e.isPrimaryTouch()) {
                    return;
                  }

                  e.stop();
                  move = true;
                  const p = e.pageXY;
                  this.openZoom(p.x, p.y, false, true);
                }, 201);
                touchDown = true;
              }
            };

            const _move = e => {
              if (e.isTouchEvent() && !e.isPrimaryTouch(e)) {
                return;
              }

              if (move) {
                e.stop();
                const p = e.pageXY;
                this.zoom.customMove(p.x, p.y);
              } else {
                clearTimeout(this.longTapTimer);
              }
            };

            const _end = e => {
              if (e.isTouchEvent() && !e.isPrimaryTouch(e)) {
                return;
              }

              if (touchDown) {
                // e.stop();
                touchDown = false;
                clearTimeout(this.longTapTimer);
              }

              if (move) {
                e.stop();
                move = false;
                this.zoom.hide(true);
              }
            };

            if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always) {
              this.instanceNode.addEvent(['touchstart', 'pointerdown'], _start);
              this.instanceNode.addEvent(['touchmove', 'pointermove'], _move);
              this.instanceNode.addEvent(['touchend', 'pointerup'], _end);
            }

            return () => {
              this.instanceNode.removeEvent(['touchstart', 'pointerdown'], _start);
              this.instanceNode.removeEvent(['touchmove', 'pointermove'], _move);
              this.instanceNode.removeEvent(['touchend', 'pointerup'], _end);
            };
          }

          setHoverEvents() {
            let isOver = false;
            let x;
            let y;
            let timer;

            const check = () => {
              return $J.browser.touchScreen && !$J.browser.mobile;
            };

            const _move = e => {
              const pageXY = e.pageXY;
              x = pageXY.x;
              y = pageXY.y;

              if (check() && e.isTouchEvent()) {
                return;
              }

              if (!isOver && this.isSlideShown && (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always)) {
                isOver = true;
                timer = setTimeout(() => {
                  // the scroll is not needed for inner zoom
                  this.openZoom(x, y, false);
                }, 84);
              }
            };

            const _out = e => {
              let relatedTarget = $(e.related);

              if (check() && e.isTouchEvent()) {
                return;
              }

              if (isOver && (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always)) {
                isOver = false;

                if (this.isFullscreenActionEnded()) {
                  while (relatedTarget && relatedTarget !== this.imageNode.node && relatedTarget !== $J.D.node.body) {
                    relatedTarget = $(relatedTarget.parentNode);
                  }

                  if (relatedTarget !== this.imageNode.node) {
                    x = null;
                    y = null;
                    clearTimeout(timer);
                  }
                }
              }
            };

            let removeConnection = () => {};

            let moveEvent = 'mousemove';
            let outEvent = 'mouseout';

            if (check() && ['edge', 'ie'].includes($J.browser.uaName)) {
              removeConnection = this.on('zoomHidden', e => {
                e.stop();
                isOver = false;
              });
              moveEvent = 'pointermove';
              outEvent = 'pointerup';
            }

            this.imageNode.addEvent(moveEvent, _move);
            this.imageNode.addEvent(outEvent, _out);
            return () => {
              removeConnection();
              this.imageNode.removeEvent(moveEvent, _move);
              this.imageNode.removeEvent(outEvent, _out);
            };
          }

          getZoomImageSize() {
            const originSize = this.image.originSize;
            const originWidth = originSize.width;
            const originHeight = originSize.height;
            const r = this.option('ratio');
            let size = {
              width: originWidth,
              height: originHeight
            };

            if (r !== 'max') {
              // because proportions can change
              size.width = this.currentImageSize.realWidth * r;
              size.height = this.currentImageSize.realHeight * r;
              size = ResponsiveImage.roundImageSize(size);
            }

            size.width = Math.min(originWidth, size.width);
            size.height = Math.min(originHeight, size.height);
            return {
              width: size.width,
              height: size.height,
              originWidth: originWidth,
              originHeight: originHeight
            };
          }

          openZoom(x, y, toFirstLevel, longTap) {
            if (this.insideOptions.type === 'deep' && toFirstLevel !== 'zero') {
              toFirstLevel = 'first';
            }

            let result = false;

            if (!this.zoom || !this.isZoomSizeExist()) {
              return result;
            } // this.zoomIsOpened = img;


            this.zoomIsOpened = true;

            if (this.hint) {
              this.hint.hide();
            }

            if (this.hotspots) {
              this.hotspots.hideActiveHotspotBox(true);
            }

            const imageClone = this.clonedImage;
            const zoomSize = this.getZoomImageSize();

            if (undefined === x) {
              result = this.zoom.showCenter(imageClone, zoomSize, toFirstLevel);
            } else {
              result = this.zoom.show(imageClone, zoomSize, x, y, longTap, toFirstLevel);
            }

            return result;
          }

          createPinchEvent() {
            // difference between scale
            const OPEN_ZOOM = 1.1;
            const FS_OUT = 0.2;
            const FS_IN = 2;
            let scale;
            let baseMin;
            let saveValue;
            let compensation;
            let maxCompensation;
            let minCompensation;
            let max;
            let min;
            let basePercent;

            const setDefaultsValues = () => {
              maxCompensation = 1;
              minCompensation = 1;
              baseMin = this.zoom.baseScale.x;
              max = 1;
              min = baseMin;
              saveValue = 1 - baseMin;
            };

            super.createPinchEvent(this.instanceNode);

            this.pinchCloud.onPinchStart = e => {
              if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState) || this.insideOptions.type === 'outside' && !this.insideOptions.outsideModeWasChanged) {
                return;
              }

              this.pinchCloud.pinch = true;
              clearTimeout(this.longTapTimer);
              basePercent = false;
              this.pinchCloud.scale = e.scale;
              compensation = 1;

              if (this.hotspots) {
                this.hotspots.hideActiveHotspotBox(true);
              }

              if (this.zoomIsOpened) {
                compensation = this.zoom.scale.x;

                if (baseMin === $J.U) {
                  setDefaultsValues();
                }

                compensation /= baseMin;
              }

              this.sendEvent('pinchStart');
            };

            this.pinchCloud.onPinchResize = e => {
              if (this.pinchCloud.pinch && !this.pinchCloud.block) {
                if (this.zoom && this.fullscreenState === globalVariables.FULLSCREEN.OPENED && this.zoomIsOpened) {
                  this.pinchCloud.scale = e.scale;
                  this.zoom.basePercent = e.centerPoint;
                }
              }
            };

            this.pinchCloud.onPinchMove = e => {
              if (this.pinchCloud.pinch && !this.pinchCloud.block) {
                if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.isFullscreenEnabled) {
                  if (!this.zoomIsOpened) {
                    if (e.scale > OPEN_ZOOM) {
                      if (this.option('mode') !== 'magnifier' && this.option('wheel')) {
                        this.openZoom(e.centerPoint.x, e.centerPoint.y, 'zero');
                        setDefaultsValues();
                        compensation = 1;
                      }
                    } else if (e.scale < FS_OUT && this.isFullscreenEnabled) {
                      this.pinchCloud.block = true;
                      this.sendEvent('fullscreenOut');
                    }
                  } else if (this.zoom) {
                    if (!basePercent) {
                      basePercent = true;
                      this.zoom.basePercent = e.centerPoint;
                    } else {
                      scale = e.scale;
                      scale *= baseMin;

                      if (max < scale) {
                        max = scale;
                        min = baseMin;
                        minCompensation = 1;
                        maxCompensation = saveValue / (max - baseMin);
                      }

                      if (min > scale) {
                        min = scale;
                        max = 1;
                        maxCompensation = 1;
                        minCompensation = baseMin / min;
                      }

                      scale *= compensation;
                      scale = (baseMin + (scale - baseMin) * maxCompensation) * minCompensation;
                      this.zoom.setScale(scale, e.centerPoint.x, e.centerPoint.y);
                    }

                    this.pinchCloud.scale = e.scale;
                  }
                } else if (e.scale >= FS_IN) {
                  this.pinchCloud.block = true;
                  this.sendEvent('fullscreenIn');
                }
              }
            }; // eslint-disable-next-line


            this.pinchCloud.onPinchEnd = e => {
              // TODO hide zoom if zoom works with this event
              if (this.pinchCloud.pinch) {
                this.pinchCloud.pinch = false;
                this.sendEvent('pinchEnd');
              }

              if (this.zoomIsOpened) {
                this.pinchCloud.removeEvent();
              }

              this.pinchCloud.block = false;
            };
          }

          loadContent() {
            this.postInit();
          }

          postInit() {
            if (this.postInitState) {
              return;
            }

            this.postInitState = 1;
            this.waitToStart.start();
            getNodeSize(this.instanceNode.node).then(size => {
              this.currentSize = size; // eslint-disable-next-line
            }).catch(error => {
              if (!this.destroyed) {
                this.calcContainerSize();
              }
            }).finally(() => {
              if (!this.destroyed) {
                this.postInitState = 2;
                this.getImage();
              }
            });
          }

          get imageClassContainer() {
            return this.image;
          } // checkImage(setts, dontLoad) {
          //     let result;
          //     if (dontLoad) {
          //         result = this.image.isExist(setts); // because we do not load images with imageclass
          //     } else {
          //         result = this.image.isLoaded(setts);
          //     }
          //     return result;
          // }


          getImage() {
            const newImageSize = this.getImageSize();
            /*
                we must do round for those values
                 for example without round
                old size is 374
                new size is 470
                470 - 374 = 96
                difference between those sizes is less than 100 and we won't reload for image
                but image was loaded with size 400
                 with round
                374 + round = 400
                470 + round = 500
                 500 - 400 = 100 we must to reload image
            */

            const diff = difference(ResponsiveImage.roundImageSize({
              width: this.currentImageSize.width
            }).width, ResponsiveImage.roundImageSize({
              width: newImageSize.width
            }).width);
            let originSize;
            let dppx;
            const dontLoad = true;
            this.setImageCss = false;

            if (!this.ready || diff >= this.differenceBetweenSizes || this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
              // fix for if the viewer was with display none
              if (!this.ready && !newImageSize.width && !newImageSize.height) {
                setTimeout(() => {
                  this.calcContainerSize();
                  this.getImage();
                }, 16);
                return;
              }

              if (diff >= this.differenceBetweenSizes || this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.currentImageSize.width) {
                this.currentImageSize = newImageSize;
              }

              let opt = this.imageSettings({
                width: this.currentImageSize.realWidth,
                height: this.currentImageSize.realHeight,
                round: true,
                dontLoad: dontLoad
              });

              if ($J.DPPX > 1) {
                originSize = this.image.originSize;

                if (opt.height > opt.width) {
                  dppx = helper.getDPPX(opt.round ? ResponsiveImage.roundImageSize({
                    height: opt.height
                  }).height : opt.height, originSize.height, this.upscale);
                } else {
                  dppx = helper.getDPPX(opt.round ? ResponsiveImage.roundImageSize({
                    width: opt.width
                  }).width : opt.width, originSize.width, this.upscale);
                }

                opt.dppx = dppx;
              }

              opt = this.setHDQuality(opt);

              if (!this.checkImage(opt, dontLoad) || !this.ready) {
                this.image.getImage(opt);
              } else {
                const img = this.image.getImage(opt);
                this.setImageSrc(img.src, img.srcset, dppx);
              }
            } else if (diff < this.differenceBetweenSizes) {
              this.setImageCss = true;
            }
          }

          imageRequest() {
            this.image.getImage(this.imageSettings({
              width: this.currentImageSize.width,
              height: this.currentImageSize.height
            }));
          }

          showImage() {
            if (!this.imageShowPromise) {
              this.imageShowPromise = new Promise((resolve, reject) => {
                let result = null;
                let _error = null;

                if (this.isInView && this.isSlideShown) {
                  this.imageNode.setCss({
                    opacity: 0,
                    transition: 'opacity .3s linear'
                  });
                  this.instanceNode.append(this.imageNode);
                  helper.loadImage(this.imageNode.node).then(imageData => {
                    result = imageData;
                  }).catch(error => {
                    _error = error;
                  }).finally(() => {
                    if (!this.destroyed) {
                      this.imageNode.addEvent('transitionend', e => {
                        e.stop();
                        this.imageNode.removeEvent('transitionend');
                        this.imageNode.setCss({
                          opacity: '',
                          transition: ''
                        });

                        if (result) {
                          this.sendContentLoadedEvent();
                          resolve(result);
                        } else {
                          reject(_error);
                        }
                      });
                      this.imageNode.render();
                      this.imageNode.setCssProp('opacity', 1);
                    }
                  });
                } else {
                  this.instanceNode.append(this.imageNode);
                  helper.loadImage(this.imageNode.node).then(imageData => {
                    result = imageData;
                  }).catch(error => {
                    _error = error;
                  }).finally(() => {
                    if (result) {
                      this.sendContentLoadedEvent();
                      resolve(result);
                    } else {
                      reject(_error);
                    }
                  });
                }
              });
            }

            return this.imageShowPromise;
          }

          createLoader() {
            this.loader = new RoundLoader(this.instanceNode, {
              'class': 'zoom-loader'
            });
          }

          createSirvImage() {
            if (!this.imageUrl) {
              return;
            }

            this.on('imageOnload', e => {
              e.stopAll();

              if (e.data.callbackData.lens) {
                if ((this.zoom.shown || this.zoom.showing) && this.zoomIsOpened) {
                  this.zoom.addLoadedImage(e.data);
                }
              } else if (this.ready) {
                if (this.imageShowPromise) {
                  this.setImageSrc(e.data.src, e.data.srcset, e.data.dppx);
                }
              } else {
                this.createImage(e.data.node, e.data.src, e.data.srcset, e.data.dppx);
                this.showImage().finally(() => {
                  if (this.loader) {
                    this.loader.hide();
                  }

                  this.done();
                  this.sendContentLoadedEvent();
                });
              }
            });
            this.on('imageOnerror', e => {
              e.stopAll();

              if (this.loader) {
                this.loader.hide();
              }

              console.log('image error');
            });
            this.image = new ResponsiveImage(this.imageUrl, {
              imageSettings: this.queryParams,
              referrerPolicy: this.referrerPolicy
            });
            this.image.parentClass = this;
            this.getInfo();
          }

          getInfoSize() {
            return new Promise((resolve, reject) => {
              this.getInfo().then(() => {
                resolve({
                  size: this.infoSize
                });
              }).catch(err => {
                reject({
                  error: err,
                  isPlaceholder: err._isplaceholder
                });
              });
            });
          }

          getSelectorImgUrl(data) {
            return new Promise((resolve, reject) => {
              const defOpt = this.imageSettings();

              if (defOpt.src) {
                data.src = defOpt.src;
              }

              data.srcset = defOpt.srcset;

              if (this.isInfoLoaded) {
                this.waitToStart.wait(() => {
                  resolve(Object.assign(this.image.getThumbnail(data), {
                    alt: this.dataAlt
                  }));
                });
              } else {
                this.getInfo().then(() => {
                  this.waitToStart.wait(() => {
                    resolve(Object.assign(this.image.getThumbnail(data), {
                      alt: this.dataAlt
                    }));
                  });
                }).catch(reject);
              }
            });
          }

          getThumbnailData(opt) {
            return this.image.getThumbnail(opt);
          }

          createControls() {
            if (this.insideOptions.controls) {
              this.controls = new ZoomControls(this.instanceNode);
              this.controls.parentClass = this;
              this.on('zoomControlsAction', e => {
                e.stopAll();

                if (this.zoom) {
                  this.makeZoom(e.data.type);
                }
              });
            }
          }

          changeControlsState(zoom
          /* from 0 to 1 */
          ) {
            if (this.controls) {
              if (zoom === 1 || zoom === 0) {
                if (zoom === 1) {
                  this.controls.disable('in');
                } else {
                  this.controls.disable('out');
                }
              } else {
                this.controls.disable();
              }
            }
          }

          createZoom(options) {
            let result = null;

            if (!this.destroyed) {
              let lensContainer = this.zoomContainer;
              result = super.createZoom(this.instanceNode, options);

              if (this.option('mode') === 'magnifier') {
                lensContainer = getContainerForZoom(this.instanceNode);
              } else if (![globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.fullscreenState)) {
                if (result.type === 'outside') {
                  lensContainer = getContainerForZoom(this.instanceNode); // because container of viewer can be overflow hidden

                  lensContainer = $J.D.node.body;
                }
              }

              if (lensContainer) {
                this.zoom.lensContainer = lensContainer;
              }
            }

            return result;
          }

          zoomIn() {
            let result = false;

            if (this.ready && this.zoom) {
              if (this.option('fullscreenOnly') && this.fullscreenState === globalVariables.FULLSCREEN.CLOSED) {
                this.sendEvent('fullscreenIn');
              } else {
                result = this.makeZoom('zoomin');
              }
            }

            return result;
          }

          zoomOut(force) {
            let result = false;

            if (this.ready && this.zoom) {
              if (force) {
                if (this.zoomIsOpened) {
                  result = this.zoom.hide(!this.zoom.getZoomData());
                }
              } else {
                result = this.makeZoom('zoomout');
              }
            }

            return result;
          }

          get originImageUrl() {
            if (this.ready) {
              return this.image.originUrl;
            }

            return null;
          }

          isZoomSizeExist() {
            let result = false;

            if (this.ready) {
              const minZoomFactor = 100; // like in deep zoom level calculation

              const cs = this.currentImageSize;
              const zoomSize = this.getZoomImageSize();

              if (zoomSize.originWidth - cs.realWidth >= minZoomFactor && (this.option('ratio') === 'max' || this.option('ratio') >= globalVariables.MIN_RATIO)) {
                result = true;
              }
            }

            return result;
          }

          onResize() {
            let result = false;

            if (this.destroyed) {
              return;
            }

            if (this.isStarted && this.postInitState === 2) {
              this.calcContainerSize();
              this.getImage();

              if (this.hotspots) {
                if (this.hotspotsTurnedOn && [globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.OPENING].includes(this.fullscreenState) || this.insideOptions.trigger !== 'hover' && [globalVariables.FULLSCREEN.OPENED, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
                  this.hotspots.containerSize = this.imageNode.node.getBoundingClientRect();

                  if (this.isInView && this.isSlideShown) {
                    this.hotspots.showNeededElements();
                  }
                }
              }

              if (this.imageNode) {
                this.setImageWidthHeight();

                if (this.isZoomSizeExist()) {
                  this.imageNode.addClass(globalVariables.CSS_CURSOR_ZOOM_IN);
                } else {
                  if (this.hint) {
                    this.hint.hide();
                  }

                  this.imageNode.removeClass(globalVariables.CSS_CURSOR_ZOOM_IN);
                }
              }

              result = true;
            }

            if (this.controls) {
              if (this.isZoomSizeExist()) {
                this.controls.show();
              } else {
                this.controls.hide();
              }
            }

            this.replaceZoom();

            if (this.zoom) {
              this.zoom.onResize();
            }

            return result;
          }

          onScroll(e) {
            if (this.zoomIsOpened) {
              e.stop();
            }

            clearTimeout(this.longTapTimer);
            this.scrollDebounce();
          }

          destroy() {
            this.destroyed = true;

            if (this.loader) {
              this.loader.destroy();
              this.loader = null;
            }

            $($J.W).removeEvent('scroll', this.onScrollHandler);
            this.onScrollHandler = null;

            if (this.lastTriggerAction) {
              this.lastTriggerAction();
              this.lastTriggerAction = null;
            }

            if (this.hint) {
              this.hint.destroy();
              this.hint = null;
            }

            if (this.image) {
              this.off('imageOnload');
              this.off('imageOnerror');
              this.image.destroy();
              this.image = null;
            }

            if (this.controls) {
              this.controls.destroy();
              this.controls = null;
              this.off('zoomControlsAction');
            }

            if (this.hotspots) {
              this.hotspotsTurnedOn = false;
              this.instanceNode.removeEvent('tap');
            }

            if (this.zoom) {
              this.off('zooming');
              this.off('zoomUp');
              this.off('zoomDown');
            }

            this.instanceNode.clearEvents();
            this.instanceNode.removeClass(P + '-zoom-view');

            if (this.imageNode) {
              this.imageNode.remove();
              this.imageNode = null;
            }

            if (this.clonedImage) {
              this.clonedImage = null;
            }

            this.zoomDebounce.cancel();
            this.zoomDebounce = null;
            this.scrollDebounce.cancel();
            this.scrollDebounce = null;
            clearTimeout(this.longTapTimer);
            this.longTapTimer = null;
            this.hotspotsData = null;
            super.destroy();
            return true;
          }

        }

        return Zoom_;
      })();

      return Zoom;
    });
    Sirv.define('Video', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'EventEmitter', 'Instance', 'defaultsVideoOptions'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, EventEmitter, Instance, defaultsVideoOptions) => {
      const $J = magicJS;
      const $ = $J.$;
      /* start-removable-module-css */

      globalFunctions.rootDOM.addModuleCSSByName('Video', () => {
        return '.smv-sirv-video .js-focus-visible .vjs-menu li.vjs-menu-item:hover,.smv-sirv-video .js-focus-visible .vjs-menu li.vjs-selected:hover,.smv-sirv-video .vjs-menu li.vjs-menu-item:focus,.smv-sirv-video .vjs-menu li.vjs-menu-item:hover,.smv-sirv-video .vjs-menu li.vjs-selected,.smv-sirv-video .vjs-menu li.vjs-selected:focus,.smv-sirv-video .vjs-menu li.vjs-selected:hover{background-color:transparent;color:inherit}.smv-sirv-video .vjs-playback-rate .vjs-playback-rate-value,.smv-sirv-video .vjs-quality-selector .vjs-icon-placeholder{font-size:1.2em;line-height:2.5em;pointer-events:none}.smv-sirv-video.video-js .vjs-big-play-button,.smv-sirv-video.video-js .vjs-control-bar,.smv-sirv-video.video-js .vjs-menu-button .vjs-menu-content,.smv-sirv-video.video-js .vjs-volume-vertical{background-color:rgba(55,58,60,.8)}.smv-sirv-video{position:relative;top:0;left:0;width:100%!important;height:100%!important}.smv-sirv-video :focus{outline:0}.smv-sirv-video .vjs-poster{background-color:transparent}.smv-sirv-video .vjs-button{display:inline-block;transition:none;border:0!important;background:0 0;color:inherit;font-size:inherit;line-height:inherit;text-decoration:none;text-transform:none;appearance:none}.smv-sirv-video .vjs-big-play-button{top:50%;left:50%;width:1.2em;height:1.2em;margin-top:-.6em;margin-left:-.6em;border:.04em solid transparent;border-radius:1em;color:inherit!important;font-size:5em;letter-spacing:0!important;line-height:1.2em;box-shadow:none}.smv-sirv-video:hover .vjs-big-play-button{border-color:transparent}.smv-sirv-video.vjs-controls-disabled .vjs-big-play-button,.smv-sirv-video.vjs-has-started .vjs-big-play-button{display:block;transition:opacity .25s}.smv-sirv-video.vjs-has-started.vjs-playing .vjs-big-play-button{opacity:0;pointer-events:none}.smv-sirv-video.vjs-has-started.vjs-paused .vjs-big-play-button{opacity:1}.smv-sirv-video .vjs-quality-selector .vjs-icon-placeholder{line-height:1}.smv-sirv-video.video-js{background-color:transparent;color:#fff;font-size:10px}.smv-sirv-video.video-js:not(.vjs-has-started) .vjs-tech{opacity:.001}.smv-sirv-video.video-js .vjs-control-bar :last-child .vjs-menu{left:100%;transform:translateX(-100%)}.smv-sirv-video.video-js .vjs-control-bar .vjs-control{color:inherit!important;box-shadow:none}.smv-sirv-video.video-js .vjs-control-bar .vjs-control .vjs-icon-placeholder{font-family:VideoJS;font-style:normal;font-weight:400;line-height:1}.smv-sirv-video.video-js .vjs-control-bar .vjs-control.vjs-quality-selector,.smv-sirv-video.video-js .vjs-control-bar .vjs-control.vjs-resolution{margin-right:.4em}.smv-sirv-video.video-js.vjs-has-started .vjs-control-bar{transition:visibility .2s,opacity .2s}.smv-sirv-video.video-js .vjs-menu-button{padding:0}.smv-sirv-video.video-js .vjs-slider{background-color:rgba(255,255,255,.2)}.smv-sirv-video.video-js .vjs-progress-control .vjs-progress-holder{transform:scaleY(.6);transition:transform .1s cubic-bezier(.4,0,1,1);font-size:1.6666666667em}.smv-sirv-video.video-js .vjs-progress-control .vjs-play-progress::before{transform:scale(0);transition:transform .1s cubic-bezier(.4,0,1,1)}.smv-sirv-video.video-js .vjs-progress-control:hover .vjs-play-progress::before,.smv-sirv-video.video-js .vjs-progress-control:hover .vjs-progress-holder{transform:none}.smv-sirv-video.video-js .vjs-load-progress{background-color:transparent}.smv-sirv-video.video-js .vjs-load-progress div{background:rgba(255,255,255,.4)}.smv-sirv-video.video-js .vjs-menu{left:50%;width:8em;transform:translateX(-50%)}.smv-sirv-video.video-js .vjs-menu .vjs-menu-item{padding:.6em .6em .3em;font-size:1.2em;text-align:left;text-transform:none}.smv-sirv-video.video-js .vjs-menu .vjs-menu-item~.vjs-menu-item{padding-top:.3em}.smv-sirv-video.video-js .vjs-menu .vjs-menu-item::before{padding:0 1em;font-family:VideoJS;font-size:.66em;content:\'\\f111\';opacity:0}.smv-sirv-video.video-js .vjs-menu .vjs-menu-item.vjs-selected::before{opacity:1}.smv-sirv-video.video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical{transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s}:root:not(.mobile-magic) .smv-sirv-video.video-js.vjs-has-started:not(:hover) .vjs-control-bar{opacity:0}.smv-disabled-action .vjs-tech{pointer-events:none!important}.smv-disabled-action .vjs-poster{pointer-events:none!important}.smv .vjs-quality-selector .vjs-menu-content .vjs-menu-title{display:none}.smv .smv-q-last .vjs-quality-selector .vjs-menu,.smv .smv-s-last .vjs-playback-rate .vjs-menu{right:0;left:auto!important;transform:none!important}';
      });
      /* end-removable-module-css */
      // see 'src/modules/defaultsVideoOptions/8.core.js' file

      /* global $, $J */

      /* global helper */

      /* global videojs */

      /* global Instance */

      /* global sirvRequire */

      /* global sirvModule */

      /* global globalVariables */

      /* global defaultsVideoOptions */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint-env es6 */

      /*
          videojs-brand
      */
      // eslint-disable-next-line no-unused-vars

      const Video = (() => {
        const P = 'smv'; // Video playback rates (speed)

        const PLAYBACK_RATES = [0.5, 1, 1.5, 2];
        const DISABLE_CLASS = P + '-disabled-action';
        const HOST = 'https://video.sirv.com';
        const INFO = 'sirv_video_info_';
        const QUALITY_CONTROL = P + '-q-last';
        const SPEED_CONTROL = P + '-s-last';
        const NEW_IMAGE_FACTOR = 50 * $J.DPPX;
        const ACTIONS = {
          NONE: 0,
          PLAY: 1,
          PLAY_SREEN_IN: 2,
          PLAY_BY_USER: 3,
          PLAY_BY_SWITCHING: 4,
          PAUSE: 5,
          PAUSE_BY_SWITCHING: 6
        };
        const cssID = 'sirv-stylesheet-vjs';

        const loadCSS = rootNode => {
          return globalFunctions.loadCssFile(rootNode, globalVariables.SIRV_ASSETS_URL + 'vjs/sirv.videojs.css', cssID);
        };

        const loadVideoJS = () => {
          return globalFunctions.loadJsFile(globalVariables.SIRV_ASSETS_URL + 'vjs/sirv.videojs.js');
        };

        const loadQualitySelectorCSS = rootNode => {
          return globalFunctions.loadCssFile(rootNode, globalVariables.SIRV_ASSETS_URL + 'vjs/qualityselector.css', 'sirv-stylesheet-vjs-quality-selector', '#' + globalFunctions.rootDOM.mainCSSID);
        };

        const loadQualitySelector = () => {
          return globalFunctions.loadJsFile(globalVariables.SIRV_ASSETS_URL + 'vjs/qualityselector.js');
        };

        const getVideoType = src => {
          src = src || '';
          src = src.split('?')[0];
          src = src.split('.');
          src = src[src.length - 1];
          src = src.toLowerCase();

          switch (src) {
            case '3gp':
              src = 'video/3gpp'; // src = 'video/3gpp; codecs="mp4v.20.8, samr"';

              break;

            case 'flv':
              src = 'video/flv'; // src = 'video/flv; codecs="flv"';

              break;

            case 'mp4':
              src = 'video/mp4'; // src = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';

              break;

            case 'ogv':
              src = 'video/ogg'; // src = 'video/ogg; codecs="theora, vorbis"';

              break;

            case 'webm':
              src = 'video/webm'; // src = 'video/webm; codecs="vp8, vorbis"';

              break;

            default:
              src = '';
          }

          return src;
        };

        const calcBandwidth = (hls, fps, motionFactor) => {
          // return hls.width * hls.height * 24 / 8;
          // https://www.miracletutorials.com/bitrate-hls-video/
          // width * height * fps * motion_factor * 0.07
          // 1 = little motion
          // 2 = moderate motion
          // 3 = more motion
          // 4 = high motion
          return parseInt(hls.width * hls.height * fps * motionFactor * 0.07, 10);
        };

        class VideoInstance extends Instance {
          constructor(node, options) {
            super(node, options, defaultsVideoOptions);
            this.type = globalVariables.SLIDE.TYPES.VIDEO;
            this.url = this.instanceNode.attr('data-src');
            this.info = null;
            this.HLS = [];
            this.currentSize = {
              width: 0,
              height: 0
            };
            this.videoNode = null;
            this.areSourcesAdded = false;
            this.indexOfCurrentHls = 0;
            this.player = null;
            this.thumbnail = this.option('thumbnail');
            this.currentTime = 0;
            this.isVideoPaused = false;
            this.fps = 30;
            this.pluginResizeDebounce = null;
            this.playPromise = null;
            this.posterSize = null;
            this.lastAction = ACTIONS.NONE;
            this.isPlayed = false;
            this.isEnded = false; // because sometimes when we call this.player.start() and the video is not loaded yet the videojs throw error when we call this.player.pause()

            this.playingState = globalVariables.VIDEO.NONE;
            this.nativeFullscreen = options.nativeFullscreen;
            const baseUrl = globalFunctions.normalizeURL(this.url.replace(globalVariables.REG_URL_QUERY_STRING, '$1'));
            const params = this.url.replace(globalVariables.REG_URL_QUERY_STRING, '$2');
            this.url = baseUrl;

            if (params) {
              this.url += '?' + params;
            }

            this.disableAction();
            this.isLoadeddata = false;
            this.controlsFullscreen = this.option('controls.fullscreen'); // in order to not search it in different classes
            // this.api = Object.assign(this.api, {
            //     isReady: this.isReady.bind(this), // parent class
            //     resize: this.resize.bind(this), // parent class
            //     getOptions: this.getOptions.bind(this) // parent class
            // });

            this.getInfo(); // for shadow dom we must add it after the element will be in dom to detect where the viewer is started
            // this.addSources();
          }

          normalizeOptions() {
            const min = this.option('quality.min');
            const max = this.option('quality.max');

            if (min > max) {
              this.option('quality.max', min);
            }
          }

          getSelectorImgUrl(data) {
            return new Promise((resolve, reject) => {
              const size = data.width || data.height;
              let thumbnailPosterSelector = this.url.split('?')[0] + '?thumbnail=' + size;

              if ($J.DPPX > 1) {
                thumbnailPosterSelector = this.url.split('?')[0] + '?thumbnail=' + size * $J.DPPX + '&quality=60';
              }

              if (!isNaN(parseFloat(this.thumbnail))) {
                thumbnailPosterSelector = this.getThumbnailPoster(thumbnailPosterSelector);
              }

              const obj = {
                src: thumbnailPosterSelector,
                callbackData: data.callbackData
              };

              if ($J.DPPX > 1) {
                obj.srcset = thumbnailPosterSelector;
              }

              this.getInfo().then(() => {
                // this.waitToStart.wait(() => {
                resolve(obj); // });
              }).catch(reject);
            });
          }

          disableAction() {
            if (this.always && [globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
              this.instanceNode.addClass(DISABLE_CLASS);
            }
          }

          enableAction() {
            if (this.always) {
              this.instanceNode.removeClass(DISABLE_CLASS);
            }
          }

          getInfo() {
            if (!this.gettingInfoPromise) {
              this.gettingInfoPromise = new Promise((resolve, reject) => {
                this.waitGettingInfo.wait(() => {
                  let url = this.url;
                  const hash = $J.getHashCode(this.url.split('?')[0].replace(/^http(s)?:\/\//, ''));

                  if (/\?/.test(url)) {
                    url += '&';
                  } else {
                    url += '?';
                  } // url += ('nometa&info=' + INFO + hash + '_main');
                  // we need meta because we need fps


                  url += 'info=' + INFO + hash + '_main';
                  helper.getRemoteData(url, 'video_info_' + helper.generateUUID(), this.referrerPolicy).then(data => {
                    if (!this.destroyed) {
                      this.info = data;

                      if (this.info.QuickTime && this.info.QuickTime.VideoFrameRate) {
                        this.fps = this.info.QuickTime.VideoFrameRate;
                      }

                      this.HLS = this.info.original.HLS || [];

                      if (this.HLS.length > 1) {
                        this.HLS.sort((a, b) => {
                          let result = 0;

                          if (a.width < b.width) {
                            result = -1;
                          } else if (a.width > b.width) {
                            result = 1;
                          } else if (a.height < b.height) {
                            result = -1;
                          } else if (a.height > b.height) {
                            result = 1;
                          }

                          return result;
                        });
                      }

                      this.infoSize = {
                        width: this.info.original.width,
                        height: this.info.original.height
                      };
                      resolve(this.infoSize);
                    }
                  }).catch(err => {
                    if (!this.destroyed) {
                      reject(err);
                    }
                  });
                });
              });
            }

            return this.gettingInfoPromise;
          }

          getInfoSize() {
            return new Promise((resolve, reject) => {
              this.getInfo().then(() => {
                resolve({
                  size: this.infoSize
                });
              }).catch(err => {
                reject({
                  error: err
                });
              });
            });
          }

          addSources() {
            const nodeWithSirvClassName = globalFunctions.getNodeWithSirvClassName(this.instanceNode) || $J.D.node.head || $J.D.node.body;
            Promise.all([loadCSS($J.D.node.head || $J.D.node.body), loadCSS(nodeWithSirvClassName), loadQualitySelectorCSS(nodeWithSirvClassName), loadVideoJS().then(loadQualitySelector)]).finally(() => {
              window.Sirv.require('qualitySelector', () => {
                this.areSourcesAdded = true;

                if (this.isStarted) {
                  if (this.isInView && (this.preload || this.isSlideShown)) {
                    this.createVideoNode();
                  }
                }
              });
            });
          }

          onStartActions(who) {
            if (this.ready) {
              if (this.player) {
                if (this.isInView) {
                  if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED && this.always && this.option('controls.enable')) {
                    this.player.controlBar.show();
                    this.player.bigPlayButton.show();
                  }

                  if (this.option('autoplay') && this.player.paused() && (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always)) {
                    this.player.muted(true);

                    if (this.isPlayed) {
                      this.lastAction = ACTIONS.PLAY_BY_SWITCHING;
                    } else if (who === globalVariables.SLIDE_SHOWN_BY.USER) {
                      this.lastAction = ACTIONS.PLAY;
                    }

                    this.play();
                  }
                }
              }
            } else if (this.isStarted) {
              if (this.isInView && this.isSlideShown && !this.preload && this.areSourcesAdded) {
                this.createVideoNode();
              }
            }
          }

          onStopActions() {
            if (this.player) {
              if (!this.player.paused() && this.playingState === globalVariables.VIDEO.PLAYING) {
                this.lastAction = ACTIONS.PAUSE_BY_SWITCHING;
                this.pause();
              }
            }
          }

          onInView(value) {
            if (value) {
              if (this.ready) {
                if (this.player) {
                  if (this.isSlideShown && value) {
                    if (this.option('autoplay') || this.playingState !== globalVariables.VIDEO.NONE && !this.isVideoPaused) {
                      this.lastAction = ACTIONS.PLAY_SREEN_IN;
                      this.play();
                    }
                  }
                }
              } else if (this.isStarted) {
                if (!this.isInView && (this.preload || this.isSlideShown) && this.areSourcesAdded) {
                  this.isInView = true;
                  this.createVideoNode();
                }
              }
            } else if (this.player) {
              this.isVideoPaused = this.playingState === globalVariables.VIDEO.PAUSE;

              if (!this.player.paused() && this.playingState === globalVariables.VIDEO.PLAYING) {
                this.lastAction = ACTIONS.PAUSE;
                this.pause();
              }
            }
          }

          startFullInit(options) {
            if (this.isStartedFullInit) {
              return;
            }

            super.startFullInit(options);
            this.normalizeOptions();
            this.thumbnail = this.option('thumbnail');
            this.getId('video-');
            this.instanceNode.addClass('sirv-video');
            this.instanceNode.addEvent('mousedown', e => {
              e.stop();
            });
          } // eslint-disable-next-line no-unused-vars


          onBeforeFullscreenIn(data) {
            this.controlsFullscreen = false;

            if (this.player) {
              this.isVideoPaused = this.playingState === globalVariables.VIDEO.PAUSE; // if (!this.player.paused() && this.playingState === globalVariables.VIDEO.PLAYING) {
              //     this.currentTime = this.player.currentTime();
              //     this.pause();
              // }

              this.toggleFullscreenButton();
            }
          } // eslint-disable-next-line no-unused-vars


          onAfterFullscreenIn(data) {
            this.enableAction();

            if (this.isSlideShown && this.isInView && this.player) {
              if (this.player.paused()) {
                if (this.always) {
                  if (this.option('controls.enable')) {
                    this.player.controlBar.show();
                    this.player.bigPlayButton.show();
                  }
                } // if (this.option('autoplay') || this.playingState !== globalVariables.VIDEO.NONE && !this.isVideoPaused) {
                // if ((this.option('autoplay') || this.playingState !== globalVariables.VIDEO.NONE) && !this.isVideoPaused) {


                if (this.option('autoplay') && !this.isVideoPaused) {
                  this.player.currentTime(this.currentTime);
                  this.playingState = globalVariables.VIDEO.PLAY; // from v 7.2.3; The method 'play_' fix bug with chenching container

                  this.player.play_();
                }
              }
            }
          } // eslint-disable-next-line no-unused-vars


          onBeforeFullscreenOut(data) {
            this.disableAction();

            if (this.option('controls.fullscreen')) {
              this.controlsFullscreen = true;
            }

            if (this.player) {
              this.isVideoPaused = this.playingState === globalVariables.VIDEO.PAUSE; // if (!this.player.paused() && this.playingState === globalVariables.VIDEO.PLAYING) {
              //     this.currentTime = this.player.currentTime();
              //     this.pause();
              // }

              this.toggleFullscreenButton();
            }
          } // eslint-disable-next-line no-unused-vars


          onAfterFullscreenOut(data) {
            if (this.isSlideShown && this.isInView) {
              if (this.player) {
                if (this.always && this.option('controls.enable')) {
                  this.player.controlBar.hide();
                  this.player.bigPlayButton.hide();
                } // if (this.option('autoplay') || this.playingState !== globalVariables.VIDEO.NONE && !this.isVideoPaused) {
                // if ((this.option('autoplay') || this.playingState !== globalVariables.VIDEO.NONE) && !this.isVideoPaused) {


                if (this.option('autoplay') && !this.isVideoPaused) {
                  // this.player.currentTime(this.currentTime);
                  this.lastAction = ACTIONS.PLAY;
                  this.play();
                }
              }
            }
          }

          onSecondSelectorClick() {
            if (this.player) {
              if (this.isSlideShown && this.isInView) {
                if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always) {
                  if (this.player.paused()) {
                    this.lastAction = ACTIONS.PLAY;
                    this.play();
                  } else if (this.playingState === globalVariables.VIDEO.PLAYING && this.isLoadeddata) {
                    this.pause();
                  }
                }
              }
            }
          }

          createVideoNode() {
            if (!this.videoNode) {
              this.videoNode = $J.$new('video', {
                'class': P + '-sirv-video',
                preload: 'none'
              });
              this.videoNode.addClass('video-js');
              this.instanceNode.append(this.videoNode);
              this.waitToStart.start();
              this.done();
            }
          }

          play() {
            if (this.player && !this.playPromise) {
              this.playingState = globalVariables.VIDEO.PLAY;
              this.playPromise = this.player.play();
            }
          }

          pause() {
            if (this.player) {
              // videojs play promise does not have 'finally' method for ie11
              // we have launch videojs player without promise because we have bug with standard play method when we are changing videojs player's time
              (this.playPromise || new Promise(resolve => resolve(null))).then(() => {
                this.player.pause();
                this.playPromise = null;
              }).catch(() => {
                this.player.pause();
                this.playPromise = null;
              });
            }
          }

          loadContent() {
            this.createVideoNode();
          }

          run(isShown, preload, firstSlideAhead) {
            const result = super.run(isShown, preload, firstSlideAhead);

            if (result) {
              this.calcContainerSize();

              if (this.isInView && (this.preload || this.isSlideShown) && this.areSourcesAdded) {
                this.createVideoNode();
              }

              this.startGettingInfo();
            }

            return result;
          }

          createMasterManifest() {
            const result = ['#EXTM3U'];
            const mf = this.option('motionFactor');
            const das = this.option('dynamicAdaptiveStreaming');
            this.HLS.forEach(HLS => {
              let str = '#EXT-X-STREAM-INF:PROGRAM-ID=1,';

              if (das) {
                str += 'BANDWIDTH=' + calcBandwidth(HLS, this.fps, mf) + ',';
              }

              str += 'RESOLUTION=' + HLS.width + 'x' + HLS.height;
              result.push(str);
              result.push(HOST + HLS.index);
            });
            return result.join('\n');
          }

          toggleFullscreenButton() {
            const ft = this.player.controlBar.getChild('FullscreenToggle');
            const ua = this.player.options_.userActions;

            if (this.controlsFullscreen) {
              ua.doubleClick = true;
              ft.show();
            } else {
              ua.doubleClick = false;
              ft.hide();
            }
          }

          isHLS() {
            return this.HLS.length > 0 && $J.browser.uaName !== 'ie';
          }

          getThumbnailSize() {
            const maxSize = this.isHLS() ? this.HLS[this.HLS.length - 1].height : this.info.height || this.info.original.height || 140;
            let size = maxSize;

            if (this.currentSize.height < size) {
              size = this.currentSize.height;
            }

            size *= $J.DPPX;

            if (size > maxSize) {
              size = maxSize;
            }

            return size;
          }

          get posterUrl() {
            return this.getThumbnailPoster(this.url.split('?')[0] + '?thumbnail=' + this.posterSize);
          }

          done() {
            if (!this.ready) {
              this.posterSize = this.getThumbnailSize();
              const posterImage = this.posterUrl; // Position volume control verically, if it's enabled.

              let volumeControl = {
                inline: false
              };

              if (this.option('controls.volume') === false) {
                volumeControl = false;
              }

              const html5Options = {
                nativeTextTracks: false,
                nativeAudioTracks: false,
                nativeVideoTracks: false
              };
              const isHSL = this.isHLS();
              const vhsOptions = {
                overrideNative: isHSL && $J.browser.uaName !== 'safari'
              };
              html5Options.smoothQualityChange = true;
              html5Options.vhs = vhsOptions;
              const videoOptions = {
                controls: this.option('controls.enable'),
                fluid: false,
                muted: this.option('volume') === 0 || this.option('autoplay'),
                loop: this.option('loop'),
                autoplay: this.option('autoplay') && this.isSlideShown,
                preload: this.option('autoplay') || this.option('preload') ? 'auto' : 'none',
                textTrackSettings: false,
                controlBar: {
                  fullscreenToggle: true,
                  // we will toggle it by itself
                  volumePanel: volumeControl,
                  muteToggle: false,
                  children: ['playToggle', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'volumePanel', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
                },
                poster: posterImage,
                playsinline: true,
                html5: html5Options,
                userActions: {
                  doubleClick: true
                },
                qualityLevels: {} // errorDisplay: false // it does not work

              };

              if (this.option('controls.quality')) {
                this.instanceNode.addClass(QUALITY_CONTROL);
              } else if (this.option('controls.speed')) {
                this.instanceNode.addClass(SPEED_CONTROL);
              }

              if (this.option('controls.speed')) {
                videoOptions.playbackRates = PLAYBACK_RATES;
              }

              if (isHSL) {
                this.player = $J.W.node.videojs(this.videoNode.node, videoOptions);

                if ($J.browser.uaName !== 'safari') {
                  this.player.src({
                    src: 'data:application/x-mpegURL;base64,' + window.btoa(this.createMasterManifest()),
                    type: 'application/x-mpegURL'
                  });
                }

                this.player.hlsQualitySelectorAutoMode({
                  visibility: this.option('controls.quality'),
                  hls: this.HLS,
                  host: HOST,
                  max: this.option('quality.max'),
                  min: this.option('quality.min')
                });
                this.pluginResizeDebounce = helper.debounce(() => {
                  this.player.hlsQualitySelectorAutoMode.recalc();
                }, 600);
              } else {
                videoOptions.src = this.url;
                const vType = getVideoType(this.url);
                this.videoNode.append($J.$new('source', {
                  src: this.url,
                  type: vType
                }));
                this.player = videojs(this.videoNode.node, videoOptions);
              }

              this.player.volume(parseInt(this.option('volume'), 10) / 100);
              this.toggleFullscreenButton();
              this.player.on('loadeddata', () => {
                this.isLoadeddata = true;
              });
              this.player.on('play', () => {
                this.isVideoPaused = false; // const isPaused = this.playingState !== globalVariables.VIDEO.NONE;

                this.playingState = globalVariables.VIDEO.PLAYING;

                if (!this.isSlideShown || !this.isInView) {
                  this.lastAction = ACTIONS.PAUSE;
                  this.pause();
                } else {
                  let reason = 'user';

                  if (this.lastAction === ACTIONS.PLAY_SREEN_IN) {
                    reason = 'viewport';
                  } else if (this.lastAction === ACTIONS.PLAY) {
                    reason = 'autoplay';
                  } else if (this.lastAction === ACTIONS.PLAY_BY_SWITCHING) {
                    reason = 'itemchange';
                  }

                  this.lastAction = ACTIONS.NONE;

                  if (this.isPlayed) {
                    this.sendEvent('resume', {
                      event: {
                        reason: reason,
                        playbackTime: this.player.currentTime()
                      }
                    });
                  } else {
                    this.isPlayed = true;
                    this.sendEvent('play', {
                      event: {
                        reason: reason
                      }
                    });
                  }
                }
              });
              this.player.on('pause', () => {
                if (this.player.currentTime() === this.player.duration()) {
                  return;
                }

                this.playingState = globalVariables.VIDEO.PAUSE;
                let reason = 'user';

                if (this.lastAction === ACTIONS.PAUSE) {
                  reason = 'viewport';
                } else if (this.lastAction === ACTIONS.PAUSE_BY_SWITCHING) {
                  reason = 'itemchange';
                }

                this.lastAction = ACTIONS.NONE;
                this.sendEvent('pause', {
                  event: {
                    reason: reason,
                    playbackTime: this.player.currentTime()
                  }
                });
              });
              this.player.on('ended', () => {
                this.isPlayed = false;
                this.isEnded = true;
                this.playingState = globalVariables.VIDEO.PAUSE;
                this.sendEvent('end');
              });
              this.player.on('fullscreenchange', () => {
                let eventName = 'fullscreenOut';

                if (this.player.isFullscreen()) {
                  eventName = 'fullscreenIn';
                }

                this.sendEvent(eventName, {
                  event: {
                    playbackTime: this.player.currentTime()
                  }
                });
              });
              let videoSeekStart = null;
              let previousTime = 0;
              let currentTime = 0;
              this.player.on('timeupdate', () => {
                previousTime = currentTime;
                currentTime = this.player.currentTime();
              });
              this.player.on('seeking', () => {
                if (videoSeekStart === null) {
                  videoSeekStart = previousTime;
                }
              });
              this.player.on('seeked', () => {
                if (this.isEnded) {
                  this.isEnded = false;
                } else {
                  this.sendEvent('seek', {
                    event: {
                      seekStart: videoSeekStart,
                      seekEnd: this.player.currentTime()
                    }
                  });
                }

                videoSeekStart = null;
              });
              this.player.on('error', event => {
                // eslint-disable-next-line no-console
                console.log('error', event);
              });

              if ($J.browser.touchScreen && $J.browser.mobile) {
                this.player.on('touchstart', e => {
                  if ($J.$(e.target).tagName === 'video' && this.player.hasClass('vjs-user-active')) {
                    if (this.player.paused()) {
                      this.lastAction = ACTIONS.PLAY;
                      this.play();
                    } else {
                      this.pause();
                    }
                  }
                });
              }

              this.player.on('ready', () => {
                // This hack disables fullscreen on double-click without visual glitch.
                // TODO: Use more proper way to disable fullscreen on double-click.
                if (!this.option('controls.fullscreen')) {
                  this.player.off(this.player.tech_, 'dblclick', this.player.handleTechDoubleClick_);
                }

                if (this.option('controls.enable') && this.fullscreenState !== globalVariables.FULLSCREEN.OPENED && this.always) {
                  this.player.controlBar.hide();
                  this.player.bigPlayButton.hide();
                }

                if (this.isSlideShown && this.isInView && this.option('autoplay')) {
                  if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || !this.always) {
                    this.player.muted(true);
                    this.lastAction = ACTIONS.PLAY;
                    this.play();
                    this.player.muted(true);
                  }
                }

                super.done();
                this.sendContentLoadedEvent();
              });
            }
          }

          getThumbnailPoster(basePoster) {
            let result = basePoster;

            if (!result) {
              result = '';
            }

            if (this.thumbnail || this.thumbnail === 0) {
              const prefix = '&video.thumbPos=';
              const floatValueThumbnail = parseFloat(this.thumbnail);

              if (!isNaN(floatValueThumbnail) && floatValueThumbnail < this.info.original.duration) {
                result += prefix + this.thumbnail; // eslint-disable-next-line
              } else if (/^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/i.test(this.thumbnail)) {
                result = this.thumbnail;
              }
            }

            return result;
          }

          calcContainerSize() {
            const size = this.instanceNode.size;

            if (!size.height || !size.width) {
              const originSize = {
                width: 0,
                height: 0
              };
              originSize.width = this.info.original.width;
              originSize.height = this.info.original.height;

              if (!size.height) {
                this.currentSize.width = size.width;
                this.currentSize.height = originSize.height / originSize.width * size.width;
              } else {
                this.currentSize.height = size.height;
                this.currentSize.width = originSize.width / originSize.height * size.height;
              }
            } else {
              this.currentSize = size;
            }
          }

          createPinchEvent() {
            // difference between scale
            const FS_OUT = -0.08;
            const FS_IN = 0.11;
            super.createPinchEvent(this.instanceNode);

            this.pinchCloud.onPinchStart = e => {
              if ([globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.CLOSING].includes(this.fullscreenState)) {
                return;
              }

              this.pinchCloud.pinch = true;
              this.pinchCloud.scale = e.scale;
              this.sendEvent('pinchStart');
            };

            this.pinchCloud.onPinchMove = e => {
              if (this.pinchCloud.pinch && !this.pinchCloud.block) {
                const s = e.scale - this.pinchCloud.scale;

                if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                  if (s < FS_OUT) {
                    this.pinchCloud.block = true;
                    this.sendEvent('fullscreenOut');
                  }
                } else if (e.scale >= FS_IN) {
                  this.pinchCloud.block = true;
                  this.sendEvent('fullscreenIn');
                }
              }
            };
          }

          onResize() {
            if (this.player) {
              if (!this.isSlideShown || !this.isInView) {
                if (!this.player.paused() && this.playingState === globalVariables.VIDEO.PLAYING) {
                  this.pause();
                }
              }

              if (this.pluginResizeDebounce) {
                this.pluginResizeDebounce();
              }

              if (this.playingState === globalVariables.VIDEO.NONE) {
                this.calcContainerSize();
                const newSize = this.getThumbnailSize();

                if (newSize > this.posterSize && newSize - this.posterSize >= NEW_IMAGE_FACTOR) {
                  this.posterSize = newSize;
                  this.player.poster(this.posterUrl);
                }
              }

              return true;
            }

            return false;
          }

          destroy() {
            if (this.player) {
              this.player.off();
              this.player.dispose();
              this.player = null;
            }

            if (this.videoNode) {
              this.videoNode.remove();
              this.videoNode = null;
            }

            if (this.pluginResizeDebounce) {
              this.pluginResizeDebounce.cancel();
              this.pluginResizeDebounce = null;
            }

            this.instanceNode.clearEvents();
            this.instanceNode.removeClass('sirv-video');
            this.instanceNode.removeClass(DISABLE_CLASS);
            this.instanceNode.removeClass(QUALITY_CONTROL);
            this.instanceNode.removeClass(SPEED_CONTROL);
            this.playPromise = null;
            this.HLS = [];
            super.destroy();
            return true;
          }

        }

        return VideoInstance;
      })();

      return Video;
    });
    Sirv.define('LazyImage', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'helper', 'ResponsiveImage', 'BaseInstance', 'getDPPX'], (bHelpers, magicJS, globalVariables, globalFunctions, helper, ResponsiveImage, BaseInstance, getDPPX) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-env es6 */

      /* eslint-disable no-extra-semi */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const defaultOptions = {
        resize: {
          type: 'boolean',
          defaults: true
        },
        // A distance from the viewport within which images should be loaded.
        threshold: {
          type: 'number',
          minimum: 0,
          defaults: 0
        },
        fit: {
          type: 'string',
          'enum': ['contain', 'cover', 'crop', 'none'],
          defaults: 'contain'
        },
        // Quality applied to images (1x - 1.49x).
        quality: {
          type: 'number',
          minimum: 0,
          maximum: 100,
          defaults: 80
        },
        // Quality applied to hi-res images (1.5x - 2x).
        hdQuality: {
          type: 'number',
          minimum: 0,
          maximum: 100,
          defaults: 60
        },
        autostart: {
          oneOf: [
          /*
              created - init and load
              visible - init and load in view
              off - not init
          */
          {
            type: 'string',
            'enum': ['created', 'visible', 'off']
          }, {
            type: 'boolean',
            'enum': [false]
          }],
          defaults: 'visible'
        },
        onReady: {
          type: 'function',
          defaults: () => {}
        }
      };
      /*
          image without slider
      
          If image is as background
          background-size: auto;
          background-size: contain;
          background-size: cover;
          background-size: 100px;
          background-size: 50%;
          background-size: 100px, 150px;
      */

      /* eslint-env es6 */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      class Appearance {
        constructor(node) {
          this.node = $(node);
          this.state = 0; // 0 - nothing, 1 - before loading image, 2 - after loading high quality image

          this.states = $(['sirv-image-loading', 'sirv-image-loaded']);
        }

        setState(numberOfState) {
          if (this.state !== numberOfState) {
            if (this.state - 1 >= 0) {
              this.node.removeClass(this.states[this.state - 1]);
            }

            this.state = numberOfState;
            this.node.addClass(this.states[numberOfState - 1]);
          }
        }

        destroy() {
          this.state = 0;
          this.states.forEach(className => {
            this.node.removeClass(className);
          });
          this.node = null;
        }

      }
      /* eslint-env es6 */

      /* global BaseInstance */

      /* global ResponsiveImage */

      /* global helper */

      /* global globalFunctions */

      /* global globalVariables */

      /* global Appearance */

      /* global getDPPX */

      /* global defaultOptions */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint class-methods-use-this: ["error", { "exceptMethods": ["_imageOnerrorHandler", "_setHDQuality"] }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "LazyImage" }] */
      // const calcCropPositionForBGImage = (position, nodeSize, originImageSize) => {
      //     let result = helper.round((originImageSize - nodeSize) / 100 * position);
      //     if (result < 0) { result = 0; }
      //     return result;
      // };


      const P = 'smv';

      const inView = node => {
        var rect = node.getBoundingClientRect();
        return !(rect.top === 0 && rect.right === 0 && rect.bottom === 0 && rect.left === 0 && rect.width === 0 && rect.height === 0); // hidden
      };

      class LazyImage extends BaseInstance {
        constructor(node, options, force) {
          options.options = {
            common: {
              common: options.options.common,
              mobile: {}
            },
            local: {
              common: '',
              mobile: ''
            }
          };
          super(node, options, defaultOptions);
          this.node = this.instanceNode;
          this.type = globalVariables.SLIDE.TYPES.IMAGE;
          this.isLazy = this.option('autostart') === 'visible';
          this.image = null;
          this.isInfoLoaded = false;
          this.infoSize = {
            width: 0,
            height: 0
          };
          this.isNotSirv = false;
          this.isInView = false;
          this.isStaticImage = false;
          this.dppx = 1;
          this.getImageInfoPromise = null;
          this.loadStaticImagePromise = null;
          this.upscale = false;
          this.size = {
            width: 0,
            height: 0
          };
          this.maxSize = {};
          this.lastImageSize = {
            width: 0,
            height: 0
          };
          this.srcWasSetted = false;
          this.originAlt = null;
          this.infoAlt = null;
          this.originTitle = null;
          this.src = null;
          this.srcset = null;
          this.startedSrc = null;
          this.dataSrc = null;
          this.imageUrl = null;
          this.dontLoad = true;
          this.appearanceState = null;
          this.dataBgSrc = null;
          this.inViewModule = null;
          this.rootMargin = 0;
          this.fitSize = null;
          this.backgroundNodeSize = null;
          this.isMaxWidthSet = false;
          this.cropPosition = {
            x: null,
            y: null
          };
          this.cssBackgroundSize = null;
          this.isPlaceholder = false;
          this.isRun = false;
          this.inited = false;
          this.resizeDebounce = helper.debounce(() => {
            this._setRootMargin();

            this.onResize();
          }, 50);

          this.resizeHandler = e => {
            this.resizeDebounce();
          };

          const as = this.instanceOptions.get('autostart');

          if (as && as !== 'off' || force) {
            this.preInit();
          }
        }

        preInit() {
          this.isRun = true;
          this.inViewModule = new helper.InViewModule(entries => {
            entries.forEach(entry => {
              // https://github.com/verlok/vanilla-lazyload/issues/293#issuecomment-469100338
              // Sometimes 'intersectionRatio' can be 0 but 'isIntersecting' is true
              const iv = entry.isIntersecting || entry.intersectionRatio > 0;

              if (this.isInView !== iv) {
                if (!this.inited) {
                  this.isInView = iv;

                  if (iv) {
                    this.init();
                  } else if (inView(this.instanceNode.node)) {
                    this.init();
                  }
                } else {
                  this.inViewCallback(iv);
                }
              }
            });
          }, {
            rootMargin: this.rootMargin + 'px 0px'
          });
          this.inViewModule.observe(this.instanceNode);

          if (inView(this.instanceNode.node)) {
            this.init();
          }
        }

        init() {
          this.inited = true;

          try {
            this.maxWidth = this.instanceNode.node.style.maxWidth;
          } catch (ex) {
            /* empty */
          }

          this._getBaseData();

          if (this.imageUrl && ($J.browser.ready || $J.D.node.readyState !== 'loading')) {
            this.startFullInit();
          }

          this.createSirvImage();
        }

        stop() {
          this.destroy();
          return true;
        }

        getOptionsForStartFullInit(options) {
          if (options) {
            options = {
              common: {
                common: options.common.lazyImage || {},
                mobile: options.mobile.lazyImage || {}
              },
              local: {
                common: '',
                mobile: ''
              }
            };
          }

          super.getOptionsForStartFullInit(options);
        }

        checkReadiness(eventname, component) {
          if (eventname === 'onLoad') {
            return this.ready;
          }

          return false;
        }

        _setRootMargin() {
          let value = parseInt(this.option('threshold'), 10);

          if ($J.typeOf(this.option('threshold')) === 'string') {
            value = ($J.W.node.innerHeight || $J.D.node.documentElement.clientHeight) / 100 * value; // eslint-disable-line operator-assignment
          }

          this.rootMargin = value;
        }

        _getQueryParams() {
          if (this.imageUrl) {
            this.queryParams = helper.paramsFromQueryString(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$2'));

            if (this.queryParams) {
              const q = parseInt(this.queryParams.quality, 10);

              if (isNaN(q)) {
                delete this.queryParams.quality;
              } else {
                this.queryParams.quality = q;
              }
            }

            this.queryParamsQuality = this.queryParams.quality || null;
          }
        }

        _getBaseData() {
          this.originAlt = this.instanceNode.attr('alt');
          this.originTitle = this.instanceNode.attr('title');
          this.src = this.instanceNode.attr('src');
          this.srcset = this.instanceNode.attr('srcset');
          this.startedSrc = this.src;
          this.dataSrc = this.instanceNode.attr('data-src');
          this.isStaticImage = this.src && !this.dataSrc;
          this.imageUrl = this.dataSrc || this.src;

          if (helper.isSVG(this.imageUrl) || this.instanceNode.attr('data-type') === 'static') {
            this.isNotSirv = true;
          }

          this.dataBgSrc = this.instanceNode.attr('data-bg-src');
          this.isStaticImage = this.isStaticImage && !this.dataBgSrc;
          this.imageUrl = this.dataBgSrc || this.imageUrl;

          if (this.instanceNode.tagName === 'img') {
            this.instanceNode.attr('referrerpolicy', this.referrerPolicy);

            if (this.dataBgSrc) {
              if (!this.dataSrc) {
                this.dataSrc = this.dataBgSrc;
              }

              this.dataBgSrc = null;
            }
          }

          if (this.dataBgSrc) {
            this.dontLoad = false;
          }

          if (this.imageUrl) {
            // Image URL
            this.src = globalFunctions.normalizeURL(this.imageUrl.replace(globalVariables.REG_URL_QUERY_STRING, '$1'));
          } // Image default params


          this._getQueryParams();

          if (this.startedSrc && this.dataSrc && this.startedSrc !== this.dataSrc) {
            this.isPlaceholder = this.instanceNode.attr('src');
          }
        }

        createSirvImage() {
          if (!this.imageUrl || this.isNotSirv) {
            return;
          }

          this.on('imageOnload', e => {
            e.stopAll();
            this.replaceSrc();

            if (!this.ready) {
              if (this.isStaticImage) {
                this.done();
              } else {
                const showImage = () => {
                  if (this.appearanceState) {
                    this.appearanceState.setState(2);
                    this.done();
                  }
                };

                if (e.data.node) {
                  showImage();
                } else {
                  helper.loadImage(this.instanceNode).finally(() => {
                    showImage();
                  });
                }
              }
            }
          });
          this.on('imageOnerror', e => {
            e.stopAll();
            console.log('image error');
          });
          this.image = new ResponsiveImage(this.imageUrl, {
            imageSettings: this.queryParams,
            round: true,
            dontLoad: this.dontLoad,
            convertSmallerSideToZero: this.option('fit') !== 'crop',
            referrerPolicy: this.referrerPolicy
          });
          this.image.parentClass = this;
          this.getInfoSize().catch(err => {
            if (err._isplaceholder) {
              this.infoSize = err;
              this.isNotSirv = true;
            }
          }).finally(() => {
            if ($J.D.node.readyState !== 'loading') {
              if (this.isStartedFullInit) {
                this.run();
              }
            }
          });
        }

        getInfoSize() {
          if (!this.getImageInfoPromise) {
            this.getImageInfoPromise = new Promise((resolve, reject) => {
              if (this.image) {
                this.image.loadInfo().then(info => {
                  this.isInfoLoaded = true;
                  this.infoAlt = this.image.description;
                  this.infoSize = this.image.originSize;
                  this.cropPosition = this.image.getCropPosition();
                  resolve(info);
                }).catch(err => {
                  this.isInfoLoaded = true;

                  if (!err.status || err.status !== 404) {
                    this.isNotSirv = true;
                  }

                  reject(err);
                });
              } else {
                reject();
              }
            });
          }

          return this.getImageInfoPromise;
        }

        getId(idPrefix, df) {
          this.id = this.instanceNode.attr('id');

          if (!this.id && !this.isStaticImage) {
            super.getId(idPrefix, df);
          }
        }

        startFullInit(options, force) {
          if (this.isStartedFullInit || !this.inited) {
            return;
          }

          this.getOptionsForStartFullInit(options);
          const as = this.option('autostart');

          if (!this.inited && !(as && as !== 'off' || force)) {
            return;
          }

          super.startFullInit(options);

          if (options) {
            this.isLazy = this.option('autostart') === 'visible';
          }

          this.getId('responsive-image-', ' ');

          if (this.dataBgSrc) {
            this.cssBackgroundSize = helper.imageLib.getBackgroundSize(this.instanceNode);

            if (this.cssBackgroundSize) {
              this.option('fit', 'none');
            }

            this.instanceNode.addClass(P + '-bg-image');

            if (this.option('fit') !== 'none') {
              if (this.option('fit') === 'contain') {
                this.instanceNode.addClass(P + '-bg-contain');
              } else {
                this.instanceNode.addClass(P + '-bg-cover');
              }
            }
          }

          this._setRootMargin();

          if (this.isStaticImage) {
            this.isLazy = false;
          } else {
            this.appearanceState = new Appearance(this.instanceNode);

            if (!this.isPlaceholder) {
              this.appearanceState.setState(1);
            }
          }

          const tagName = this.instanceNode.tagName === 'img';

          if (this.isLazy && tagName) {
            this.instanceNode.attr('loading', 'lazy');
          }

          if (!this.isLazy || tagName && $J.browser.uaName !== 'ie') {
            this.isInView = true;
            this.inViewModule.disconnect();
            this.inViewModule = null;
          }

          if (this.isInfoLoaded || this.isNotSirv) {
            if ($J.D.node.readyState !== 'loading') {
              this.run();
            }
          }

          $J.W.addEvent('resize', this.resizeHandler);
        }

        fixHeight(height) {
          if (height !== 0) {
            const blockSize = parseInt(this.instanceNode.getCss('block-size'), 10);

            if (height === blockSize || height <= 16) {
              height = 0;
            }
          }

          return height;
        }

        run() {
          const result = super.run();

          if (result) {
            // Remove ALT to properly calculate image size.
            // Safari and Edge/IE return image size with a height if ALT text is present.
            this.instanceNode.removeAttr('alt'); // Remove TITLE to properly calculate image size.
            // The latest version(s) of Chrome returns image size with a height if TITLE is set.

            this.instanceNode.removeAttr('title'); // This force browsers to re-layout image and recalculate its dimensions.

            this.instanceNode.setCss({
              display: 'inline-flex'
            }).render();
            this.instanceNode.setCss({
              display: ''
            }).render();
            let size = null;
            helper.imageLib.getSize(this.instanceNode).then(dataSize => {
              size = dataSize;
            }).finally(() => {
              if (this.destroyed) {
                return;
              }

              size = helper.fixSize(this.instanceNode, size); // if (this.dataBgSrc) {
              //     this.fitSize = helper.imageLib.getBackgroundSize(this.instanceNode);
              // }

              if (size.width === 0 && size.height === 0) {
                this.instanceNode.setCss({
                  width: '100%'
                });
                size.width = this.instanceNode.size.width;
              }

              if (size.width === 0 && size.height === 0) {
                size.width = $J.W.node.innerWidth;
              }

              if (this.option('fit') === 'contain') {
                this.fitSize = {
                  width: 'contain',
                  height: 'contain'
                };
              } else {
                this.fitSize = {
                  width: 'cover',
                  height: 'cover'
                };
              }

              if (this.option('fit') === 'none') {
                if (this.cssBackgroundSize) {
                  this.size = helper.imageLib.calcProportionalBackgroundSize(this.cssBackgroundSize, this.infoSize);
                } else {
                  this.size = this.infoSize;
                }
              } else {
                this.size = helper.imageLib.calcProportionSize(size, this.infoSize, this.fitSize);
              }

              if (!this.dataBgSrc) {
                // Set the max-width to prevent image stretching beyond its original maximum width
                const objectFit = this.instanceNode.getCss('objectFit');

                if (!this.maxWidth && this.infoSize.width > 0 && (!objectFit || objectFit === 'fill') && !this.instanceNode.attr('width')) {
                  this.isMaxWidthSet = true;
                  this.instanceNode.setCss({
                    maxWidth: this.infoSize.width
                  });
                }
              }

              if (this.originAlt || this.infoAlt) {
                // Restore ALT text
                this.instanceNode.attr('alt', this.originAlt || this.infoAlt);
              }

              if (this.originTitle) {
                // Restore TITLE text
                this.instanceNode.attr('title', this.originTitle);
              }

              if (this.isStaticImage) {
                this.loadStaticImage().finally(() => {
                  if (this.isInfoLoaded) {
                    this.done();
                  }
                });
              } else if (!this.isLazy || this.isInView) {
                this.getImage();
              }
            });
          }

          return result;
        }

        _setSrc(src, srcset) {
          if (this.dataBgSrc) {
            this.instanceNode.setCss({
              backgroundImage: 'url("' + (srcset || src) + '")'
            });
          } else {
            this.instanceNode.attr('src', src);

            if (srcset) {
              if (!this.isNotSirv && this.dppx > 1) {
                this.instanceNode.attr('srcset', srcset + ' ' + this.dppx + 'x');
              }
            } else {
              this.instanceNode.removeAttr('srcset');
            }
          }
        }

        _setHDQuality(opt) {
          if (opt.dppx > 1 && opt.dppx < 1.5) {
            const quality = this.instanceOptions.isset('quality') ? this.option('quality') : null;

            if (this.queryParamsQuality === null && quality !== null) {
              opt.srcset.quality = quality;
            } else if (opt.srcset) {
              delete opt.srcset.quality;
            }
          }

          return opt;
        }

        replaceSrc() {
          let img;

          if (this.isNotSirv) {
            if (this.srcWasSetted) {
              return;
            }

            this.srcWasSetted = true;
            img = {
              src: this.imageUrl
            };
          } else {
            let opt = this._getImageCreateSettings();

            if (opt.dppx > 1 && opt.dppx < 1.5) {
              delete opt.srcset.quality;
            }

            opt = this._setHDQuality(opt);
            img = this.image.getImage(opt);
            this.lastImageSize.width = img.width || img.serverWidth;
            this.lastImageSize.height = img.height || img.serverHeight;
          }

          this._setSrc(img.src, img.srcset);
        }

        loadStaticImage() {
          if (!this.loadStaticImagePromise) {
            this.loadStaticImagePromise = new Promise((resolve, reject) => {
              if (this.isStaticImage) {
                if (this.instanceNode.node.complete) {
                  resolve();
                } else {
                  this.instanceNode.addEvent('load', e => {
                    resolve();
                  });
                  this.instanceNode.addEvent('error', e => {
                    reject();
                  });
                }
              } else {
                resolve();
              }
            });
          }

          return this.loadStaticImagePromise;
        }

        _getImageCreateSettings() {
          let setts = {
            src: {},
            srcset: {}
          };
          const quality = this.instanceOptions.isset('quality') ? this.option('quality') : null;

          if (quality !== null && this.queryParamsQuality === null) {
            setts.src.quality = quality;
          }

          const hdQuality = this.option('hdQuality');

          if (this.queryParamsQuality === null || this.instanceOptions.isset('hdQuality') && hdQuality < this.queryParamsQuality) {
            setts.srcset = {
              quality: hdQuality
            };
          }

          setts.width = this.size.width;

          if (this.size.height) {
            setts.height = this.size.height;
          }

          setts = helper.imageLib.checkMaxSize(setts, this.infoSize);

          if (this.infoSize.width === setts.width || this.infoSize.height === setts.height) {
            setts.round = false;
          }

          if ($J.DPPX > 1) {
            setts.dppx = this.dppx;
          }

          if (this.option('fit') === 'crop') {
            setts.round = false;
          } // if (this.dataBgSrc && this.option('fit') === 'crop') {
          //     this.backgroundNodeSize = this.instanceNode.size;
          //     let crop = null;
          //     let cropX2 = null;
          //     // const roundedSize = ResponsiveImage.roundImageSize(this.size);
          //     const roundedSize = this.size;
          //     const originSize = this.image.originSize;
          //     const dppx = getDPPX(roundedSize.width, roundedSize.height, originSize.width, originSize.height, (!$J.defined(setts.round) || setts.round), this.upscale);
          //     if (!this.cropPosition.type) {
          //         if (this.backgroundNodeSize.width < roundedSize.width) {
          //             if (!crop) { crop = {}; cropX2 = {}; }
          //             // crop.x = calcCropPositionForBGImage(50, this.backgroundNodeSize.width, roundedSize.width);
          //             crop.x = calcCropPositionForBGImage(this.cropPosition.x ? parseFloat(this.cropPosition.x) : 50, this.backgroundNodeSize.width, roundedSize.width);
          //             // cropX2.x = calcCropPositionForBGImage(50, this.backgroundNodeSize.width * setts.dppx, roundedSize.width * dppx);
          //             cropX2.x = calcCropPositionForBGImage(this.cropPosition.x ? parseFloat(this.cropPosition.x) : 50, this.backgroundNodeSize.width * setts.dppx, roundedSize.width * dppx);
          //             crop.width = this.backgroundNodeSize.width;
          //             cropX2.width = this.backgroundNodeSize.width * dppx;
          //         }
          //         if (this.backgroundNodeSize.height < roundedSize.height) {
          //             if (!crop) { crop = {}; cropX2 = {}; }
          //             // crop.y = calcCropPositionForBGImage(50, this.backgroundNodeSize.height, roundedSize.height);
          //             crop.y = calcCropPositionForBGImage(this.cropPosition.y ? parseFloat(this.cropPosition.y) : 50, this.backgroundNodeSize.height, roundedSize.height);
          //             // cropX2.y = calcCropPositionForBGImage(50, this.backgroundNodeSize.height * setts.dppx, roundedSize.height * dppx);
          //             cropX2.y = calcCropPositionForBGImage(this.cropPosition.y ? parseFloat(this.cropPosition.y) : 50, this.backgroundNodeSize.height * setts.dppx, roundedSize.height * dppx);
          //             crop.height = this.backgroundNodeSize.height;
          //             cropX2.height = this.backgroundNodeSize.height * dppx;
          //         }
          //         if (crop) {
          //             if (!setts.src) { setts.src = {}; }
          //             setts.src.crop = crop;
          //             if (!setts.srcset) { setts.srcset = {}; }
          //             setts.srcset.crop = cropX2;
          //         }
          //     }
          // }


          setts = this.setCrop(setts);
          return setts;
        }

        setCrop(setts) {
          if (this.option('fit') === 'crop') {
            const size = $(this.instanceNode.node).getInnerSize(!!this.dataBgSrc);

            if (!setts.imageSettings) {
              setts.imageSettings = {};
            }

            if (!setts.imageSettings.crop) {
              setts.imageSettings.crop = {};
            }

            setts.imageSettings.crop = {
              x: this.cropPosition.x || 'center',
              y: this.cropPosition.y || 'center',
              width: size.width,
              height: size.height
            };
          }

          return setts;
        }

        getImage() {
          if (this.isStaticImage) {
            return;
          }

          if (this.isNotSirv) {
            this.getNonSirvImg();
          } else {
            this.getSirvImg();
          }
        }

        getNonSirvImg() {
          if (this.isPlaceholder) {
            helper.loadImage(this.dataSrc).finally(() => {
              this.replaceSrc();
              this.appearanceState.setState(2);
              this.done();
            });
          } else {
            this.replaceSrc();
            this.appearanceState.setState(2);
            this.done();
          }
        }

        get imageClassContainer() {
          return this.image;
        }

        getSirvImg() {
          let setts = this._getImageCreateSettings();

          if (setts.width) {
            this.maxSize.width = setts.width;
          }

          if (setts.height) {
            this.maxSize.height = setts.height;
          }

          if ($J.DPPX > 1) {
            const originSize = this.image.originSize;
            this.dppx = getDPPX(setts.width, setts.height, originSize.width, originSize.height, !$J.defined(setts.round) || setts.round, this.upscale);
            setts.dppx = this.dppx;
          }

          setts = this._setHDQuality(setts);

          if (this.checkImage(setts)) {
            this.replaceSrc();
          } else {
            this.image.getImage(setts);
          }
        }

        checkSize(size) {
          const w = this.infoSize.width;
          const h = this.infoSize.height;

          if (size.width > w || size.height > h) {
            size.width = w;

            if (size.height) {
              size.height = h;
            }

            size.round = false;
          }

          return size;
        }

        done() {
          super.done(); // if (!this.dataBgSrc) {
          //     this.instanceNode.setCss({ width: '', height: '' });
          // }

          this.option('onReady')(this.id);
          this.sendEvent('ready');
        }

        inViewCallback(value) {
          if (value && !this.isStaticImage) {
            if (!this.ready && !this.isInView) {
              if (this.isStarted) {
                this.isInView = true;

                if (this.isNotSirv) {
                  if (!this.srcWasSetted) {
                    this.getImage();
                  }
                } else if (this.isInfoLoaded) {
                  this.getImage();
                }
              }
            }
          }

          this.isInView = value;
        }

        sendEvent(nameOfEvent, data) {
          /*
              image events: [
                  'ready',
              ]
          */
          if (!data) {
            data = {};
          }

          if (!data.image) {
            data.image = {};
          }

          if (!data.image.event) {
            data.image.event = {};
          }

          if (nameOfEvent === 'ready') {
            nameOfEvent = 'onLoad';
          }

          data.type = nameOfEvent;
          data.image.id = this.id;
          data.image.url = this.instanceUrl;
          data.image = Object.assign(data.image, this.api);
          data.node = this.instanceNode;
          data.image.node = this.instanceNode.node;
          data.image.event.timestamp = +new Date();
          data.image.event.type = 'lazyimage:' + nameOfEvent;
          this.emit('imagePublicEvent', {
            data: data
          });
        }

        get originImageUrl() {
          return this.src;
        }

        onResize() {
          if (!this.isStarted || this.isStaticImage || !this.option('resize') || this.isNotSirv) {
            return false;
          }

          let size;

          if (['crop', 'cover'].includes(this.option('fit'))) {
            size = $(this.instanceNode.node.parentNode).size;
          } else {
            size = this.instanceNode.size; // sometimes before the image appear in view the resize event can work and size of height of this image is 16px on android in chrome

            size.height = this.fixHeight(size.height);
          }

          size = helper.imageLib.calcProportionSize(size, this.infoSize, this.fitSize);
          this.size.width = size.width;

          if (this.size.height) {
            this.size.height = size.height;
          }

          if (this.ready && !this.isNotSirv) {
            const upscale = 50;

            if (this.option('fit') === 'crop') {
              if (Math.abs(this.size.width - this.lastImageSize.width) > upscale || Math.abs(this.size.height - this.lastImageSize.height) > upscale) {
                this.getImage();
              }
            } else if (this.size.width - this.lastImageSize.width > upscale || this.size.height - this.lastImageSize.height > upscale) {
              this.getImage();
            }
          }

          return true;
        }

        destroy() {
          if (this.dataBgSrc) {
            this.instanceNode.removeClass(P + '-bg-image');
            this.instanceNode.setCssProp('background-image', '');
          }

          if (this.isMaxWidthSet) {
            this.isMaxWidthSet = false;
            this.instanceNode.setCss({
              maxWidth: ''
            });
          }

          if (this.appearanceState) {
            this.appearanceState.destroy();
          }

          if (this.inViewModule) {
            this.inViewModule.disconnect();
            this.inViewModule = null;
          }

          $J.W.removeEvent('resize', this.resizeHandler);
          this.resizeDebounce.cancel();
          this.resizeDebounce = null;

          if (this.image) {
            this.off('imageOnload');
            this.off('imageOnerror');
            this.image.destroy();
            this.image = null;
          }

          if (this.instanceNode.node.hasAttribute('src')) {
            try {
              this.instanceNode.removeAttr('src');

              if (this.isStaticImage) {
                this.instanceNode.attr('src', this.imageUrl);
              }
            } catch (e) {// empty
            }
          }

          if (!this.isStaticImage) {
            this.instanceNode.removeAttr('src');
          } else {
            this.instanceNode.attr('src', this.src);
          }

          if (this.srcset) {
            this.instanceNode.attr('srcset', this.srcset);
          } else {
            try {
              this.instanceNode.removeAttr('srcset');
            } catch (e) {// empty
            }
          }

          this.srcset = null;

          if (!this.originAlt && this.infoAlt) {
            this.instanceNode.removeAttr('alt');
          }

          this.instanceNode.removeEvent('load');

          if (this.isPlaceholder) {
            this.instanceNode.attr('src', this.isPlaceholder);
            this.isPlaceholder = false;
          }

          super.destroy();
        }

      }

      return LazyImage;
    });
    Sirv.define('Slider', ['bHelpers', 'magicJS', 'globalVariables', 'globalFunctions', 'ResponsiveImage', 'helper', 'EventEmitter', 'ContextMenu', 'ComponentLoader', 'defaultsVideoOptions', 'ViewerImage', 'SliderBuilder', 'ProductDetail', 'Description', 'Spin', 'Zoom', 'Video'], (bHelpers, magicJS, globalVariables, globalFunctions, ResponsiveImage, helper, EventEmitter, ContextMenu, ComponentLoader, defaultsVideoOptions, ViewerImage, SliderBuilder, ProductDetail, Description, Spin, Zoom, Video) => {
      const $J = magicJS;
      const $ = $J.$;
      /* eslint-disable no-unused-vars */

      const CSS_MAIN_CLASS = 'smv';
      const SELECTOR_TAG = CSS_MAIN_CLASS + '-thumbnail';
      const SELECTOR_CLASS = CSS_MAIN_CLASS + '-selector';
      let DPPX = $J.W.node.devicePixelRatio >= 2 ? 2 : 1; // Dots per px. 2 - is equal to Retina.;

      /* eslint-env es6 */

      /* eslint-disable no-extra-semi */

      /* eslint-disable no-unused-vars */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      const defaultOptions = {
        orientation: {
          type: 'string',
          'enum': ['horizontal', 'vertical'],
          defaults: 'horizontal'
        },
        arrows: {
          type: 'boolean',
          defaults: true
        },
        loop: {
          type: 'boolean',
          defaults: true
        },
        // Quality applied to images (1x - 1.49x).
        quality: {
          type: 'number',
          minimum: 0,
          maximum: 100,
          defaults: 80
        },
        // Quality applied to hi-res images (1.5x - 2x).
        hdQuality: {
          type: 'number',
          minimum: 0,
          maximum: 100,
          defaults: 60
        },
        itemsOrder: {
          type: 'array',
          defaults: []
        },
        autostart: {
          oneOf: [
          /*
              created - init and load
              visible - init and load in view
              off - not init
          */
          {
            type: 'string',
            'enum': ['created', 'visible', 'off']
          }, {
            type: 'boolean',
            'enum': [false]
          }],
          defaults: 'visible'
        },
        // A distance from the viewport within which the in-view state should be triggered.
        threshold: {
          type: 'number',
          minimum: 0,
          defaults: 0
        },
        slide: {
          // slide.first
          first: {
            type: 'number',
            minimum: 0,
            defaults: 0
          },
          // slide.delay
          delay: {
            type: 'number',
            minimum: 9,
            defaults: 3000
          },
          // slide.preload
          preload: {
            type: 'boolean',
            defaults: true
          },
          // slide.autoplay
          autoplay: {
            type: 'boolean',
            defaults: false
          },
          animation: {
            // slide.animation.type
            type: {
              oneOf: [{
                type: 'string',
                'enum': ['off', 'slide', 'fade']
              }, {
                type: 'boolean',
                'enum': [false]
              }],
              defaults: 'fade'
            },
            // slide.animation.type
            duration: {
              type: 'number',
              minimum: 9,
              defaults: 200
            }
          },
          socialbuttons: {
            enable: {
              type: 'boolean',
              defaults: false
            },
            types: {
              facebook: {
                type: 'boolean',
                defaults: true
              },
              twitter: {
                type: 'boolean',
                defaults: true
              },
              linkedin: {
                type: 'boolean',
                defaults: true
              },
              reddit: {
                type: 'boolean',
                defaults: true
              },
              tumblr: {
                type: 'boolean',
                defaults: true
              },
              pinterest: {
                type: 'boolean',
                defaults: true
              },
              telegram: {
                type: 'boolean',
                defaults: true
              }
            }
          }
        },
        thumbnails: {
          // thumbnails.enable
          enable: {
            type: 'boolean',
            defaults: true
          },
          // thumbnails.size
          size: {
            type: 'number',
            minimum: 5,
            defaults: 70
          },
          // thumbnails.position
          position: {
            type: 'string',
            'enum': ['top', 'left', 'right', 'bottom'],
            defaults: 'bottom'
          },
          // thumbnails.type
          type: {
            type: 'string',
            'enum': ['square', 'auto', 'bullets', 'grid', 'crop'],
            defaults: 'square'
          },
          // thumbnails.always
          always: {
            type: 'boolean',
            defaults: false
          },
          // thumbnails.target
          target: {
            oneOf: [{
              type: 'string'
            }, {
              type: 'boolean',
              'enum': [false]
            }],
            defaults: false
          },
          // thumbnails.watermark
          watermark: {
            type: 'boolean',
            defaults: true
          }
        },
        fullscreen: {
          // fullscreen.enable
          enable: {
            type: 'boolean',
            defaults: true
          },
          // fullscreen.always
          always: {
            type: 'boolean',
            defaults: false
          },
          // fullscreen.native
          'native': {
            type: 'boolean',
            defaults: false
          },
          // TODO
          // +background: <color>,
          thumbnails: {
            // fullscreen.thumbnails.enable
            enable: {
              type: 'boolean',
              defaults: true
            },
            // fullscreen.thumbnails.size
            size: {
              oneOf: [{
                type: 'string',
                'enum': ['auto']
              }, {
                type: 'number',
                minimum: 5
              }],
              defaults: 'auto'
            },
            // fullscreen.thumbnails.position
            position: {
              type: 'string',
              'enum': ['top', 'left', 'right', 'bottom'],
              defaults: 'bottom'
            },
            // fullscreen.thumbnails.type
            type: {
              type: 'string',
              'enum': ['square', 'auto', 'bullets', 'grid', 'crop'],
              defaults: 'square'
            },
            // thumbnails.always
            always: {
              type: 'boolean',
              defaults: false
            },
            // fullscreen.thumbnails.autohide
            autohide: {
              type: 'boolean',
              defaults: false
            },
            // fullscreen.thumbnails.watermark
            watermark: {
              type: 'boolean',
              defaults: true
            }
          }
        },
        contextmenu: {
          // contextmenu.enable
          enable: {
            type: 'boolean',
            defaults: false
          },
          text: {
            zoom: {
              // contextmenu.text.zoom.in
              'in': {
                oneOf: [{
                  type: 'string'
                }, {
                  type: 'boolean',
                  'enum': [false]
                }],
                defaults: 'Zoom In'
              },
              // contextmenu.text.zoom.out
              out: {
                oneOf: [{
                  type: 'string'
                }, {
                  type: 'boolean',
                  'enum': [false]
                }],
                defaults: 'Zoom Out'
              }
            },
            fullscreen: {
              // contextmenu.fullscreen.enter
              enter: {
                oneOf: [{
                  type: 'string'
                }, {
                  type: 'boolean',
                  'enum': [false]
                }],
                defaults: 'Enter Full Screen'
              },
              // contextmenu.fullscreen.exit
              exit: {
                oneOf: [{
                  type: 'string'
                }, {
                  type: 'boolean',
                  'enum': [false]
                }],
                defaults: 'Exit Full Screen'
              }
            },
            // contextmenu.text.download
            download: {
              oneOf: [{
                type: 'string'
              }, {
                type: 'boolean',
                'enum': [false]
              }],
              defaults: 'Download Image'
            }
          }
        },
        productdetail: {
          enable: {
            type: 'boolean',
            defaults: false
          },
          position: {
            type: 'string',
            'enum': ['top', 'right', 'bottom', 'left'],
            defaults: 'top'
          }
        }
        /*
            TODO
            contextmenu: {
                items: [
                    { action: zoomIn, text: 'Збільшити' }
                    { action: zoomOut }
                ]
            }
         */
        // ready: { type: 'function', defaults: () => {} },
        // beforeSlideIn: { type: 'function', defaults: () => {} },
        // beforeSlideOut: { type: 'function', defaults: () => {} },
        // afterSlideIn: { type: 'function', defaults: () => {} },
        // afterSlideOut: { type: 'function', defaults: () => {} },
        // fullscreenIn: { type: 'function', defaults: () => {} },
        // fullscreenOut: { type: 'function', defaults: () => {} }
        // sendStats: { type: 'function', defaults: () => {} }

      };
      /* eslint-env es6 */

      /* global $ */

      /* global $J */

      /* global EventEmitter */

      /* global helper */

      /* global ViewerImage */

      /* global Zoom */

      /* global Spin */

      /* global Video */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint-disable no-lonely-if */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "SirvService" }] */

      class SirvService extends EventEmitter {
        constructor(node, options, additionalOptions) {
          super();
          this.node = $(node);
          this.options = options;
          this._type = globalVariables.SLIDE.TYPES.NONE;
          this.imgSrc = null;
          this.effect = null;
          this.additionalEffects = [];
          this.isStarted = false;
          this.isPrepared = false;
          this.toolOptions = {};
          this.api = {};
          this.isActive = false;
          this.additionalOptions = additionalOptions;
          this.parse();
          this.setEvents();
        }

        static isExist(node) {
          let result = false;
          const resultOfParse = helper.getSirvType(node);
          const deps = {
            Image: ViewerImage,
            Spin: Spin,
            Zoom: Zoom,
            Video: Video
          };

          if (resultOfParse && !!deps[$J.camelize('-' + globalVariables.SLIDE.NAMES[resultOfParse.type])]) {
            result = true;
          }

          return result;
        }

        createAPI() {
          if (this.effect) {
            this.api = this.effect.api;
            let methods = [];
            const t = globalVariables.SLIDE.TYPES;

            switch (this._type) {
              case t.SPIN:
                methods = ['play', 'rotate', 'rotateX', 'rotateY', 'zoomIn', 'zoomOut'];
                break;

              case t.ZOOM:
                if (this.api.zoomIn) {
                  methods = ['zoomIn', 'zoomOut'];
                }

                break;
              // no default
            }

            methods.forEach(method => {
              const _oldMethod = this.api[method];

              this.api[method] = (...args) => {
                let result = false;
                const om = _oldMethod;

                if (this.isActive) {
                  result = om.apply(this, args);
                }

                return result;
              };
            });
          }
        }

        setEvents() {
          this.on('stats', e => {
            e.stopEmptyEvent();
            e.data.component = globalVariables.SLIDE.NAMES[this._type];
          }); // init, ready, zoomIn, zoomOut

          this.on('componentEvent', e => {
            e.stopEmptyEvent();
            e.data.component = globalVariables.SLIDE.NAMES[this._type];

            if (e.data.type === 'ready') {
              if (this._type === globalVariables.SLIDE.TYPES.IMAGE && e.data.data.imageIndex !== null) {
                e.stopAll();
              }

              this.toolOptions = this.effect.options;
            }
          });
        }

        parse() {
          const resultOfParse = helper.getSirvType(this.node.node);

          if (resultOfParse) {
            this._type = resultOfParse.type;
            this.imgSrc = resultOfParse.imgSrc;
          }
        }

        push(imgNode) {
          if (ViewerImage) {
            const effect = new ViewerImage(imgNode, {
              options: this.options.image,
              isFullscreen: this.additionalOptions.isFullscreen,
              imageIndex: this.additionalEffects.length
            });
            effect.parentClass = this;
            this.additionalEffects.push({
              node: imgNode,
              src: $(imgNode).attr('src'),
              datasrc: $(imgNode).attr('data-src'),
              effect: effect
            });
          }
        }

        sendEvent(nameOfEvent) {
          if (this.effect && this.effect.sendEvent) {
            this.effect.sendEvent(nameOfEvent);
          }
        }

        resize() {
          this.broadcast('resize');
        }

        startFullInit(options) {
          if (this.effect) {
            this.effect.startFullInit(options ? options[this._type] : null);

            if (this.additionalEffects.length) {
              this.additionalEffects.forEach(effect => {
                if (effect.effect) {
                  effect.effect.startFullInit(options ? options[this._type] : null);
                }
              });
            }
          }
        }

        getSelectorImgUrl(data) {
          return this.effect.getSelectorImgUrl(data);
        }

        getInfoSize() {
          let result = null;

          if (this._type === globalVariables.SLIDE.TYPES.IMAGE) {
            result = new Promise((resolve, reject) => {
              Promise.all([this.effect.getInfoSize()].concat(this.additionalEffects.map(value => {
                return value.effect.getInfoSize();
              }))).then(values => {
                resolve(values[0]);
              }).catch(reject);
            });
          } else {
            result = this.effect.getInfoSize();
          }

          return result;
        }

        start() {
          if (this.isPrepared) {
            return;
          }

          this.isPrepared = true;
          const options = {
            isFullscreen: this.additionalOptions.isFullscreen,
            quality: this.additionalOptions.quality,
            hdQuality: this.additionalOptions.hdQuality,
            isHDQualitySet: this.additionalOptions.isHDQualitySet,
            always: this.additionalOptions.always,
            nativeFullscreen: this.additionalOptions.nativeFullscreen
          };
          const t = globalVariables.SLIDE.TYPES;

          switch (this._type) {
            case t.IMAGE:
              if (ViewerImage) {
                this.effect = new ViewerImage(this.node.node, Object.assign(options, {
                  options: this.options.image,
                  imageIndex: null
                }));
                this.effect.parentClass = this;
              }

              break;

            case t.PANZOOM:
            case t.ZOOM:
              if (Zoom) {
                this.effect = new Zoom(this.node.node, Object.assign(options, {
                  options: this.options.zoom
                }));
                this.effect.parentClass = this;
              }

              break;

            case t.SPIN:
              if (Spin) {
                this.node.setCss({
                  // fix for shadow DOM
                  width: '100%',
                  height: '100%'
                });
                this.effect = new Spin(this.node.node, Object.assign(options, {
                  options: this.options.spin
                }));
                this.effect.parentClass = this;
              }

              break;

            case t.VIDEO:
              if (Video) {
                this.effect = new Video(this.node.node, Object.assign(options, {
                  options: this.options.video,
                  nativeFullscreen: this.additionalOptions.nativeFullscreen
                }));
                this.effect.parentClass = this;
              }

              break;

            default:
          }

          this.createAPI();
        }

        isThumbnailGif() {
          if (this.effect && this._type === globalVariables.SLIDE.TYPES.SPIN) {
            return this.effect.isThumbnailGif();
          }

          return false;
        }

        isZoomSizeExist() {
          const t = globalVariables.SLIDE.TYPES;

          if (this.effect && [t.SPIN, t.PANZOOM, t.ZOOM].includes(this._type)) {
            return this.effect.isZoomSizeExist();
          }

          return false;
        }

        startGettingInfo() {
          if (this.effect) {
            this.effect.startGettingInfo();
          }
        }

        startTool(isShown, preload, firstSlideAhead) {
          if (!this.isStarted && this.effect) {
            this.isStarted = true;
            this.effect.run(isShown, preload, firstSlideAhead);

            if (this.additionalEffects.length) {
              this.additionalEffects.forEach(effect => {
                if (effect.effect) {
                  effect.effect.run(isShown, preload, firstSlideAhead);
                }
              });
            }
          }
        }

        loadContent() {
          if (this.isStarted) {
            this.effect.loadContent();
          }
        }

        loadThumbnail() {
          if (this.isStarted) {
            this.effect.loadThumbnail();
          }
        }

        get type() {
          return this._type;
        }

        getData() {
          let result = {};

          if (this.effect) {
            result = Object.assign(result, this.api);
            delete result.start;
            delete result.stop;
            delete result.refresh;
          }

          return result;
        }

        get originImageUrl() {
          if (this.effect) {
            return this.effect.originImageUrl;
          }

          return null;
        }

        getZoomData() {
          if ([globalVariables.SLIDE.TYPES.SPIN, globalVariables.SLIDE.TYPES.ZOOM].includes(this._type)) {
            return {
              isZoomed: this.effect.isZoomed(),
              zoom: this.effect.getZoomData()
            };
          }

          return null;
        }

        getSpinOrientation() {
          if (this._type === globalVariables.SLIDE.TYPES.SPIN) {
            return this.effect.orientation;
          }

          return null;
        }

        getSocialButtonData(data, isSpin) {
          let result = null;

          if (this.isStarted) {
            if (this._type === globalVariables.SLIDE.TYPES.SPIN) {
              result = this.effect.getSocialButtonData(data, isSpin);
            } else {
              result = this.effect.getSocialButtonData(data);
            }
          }

          return result;
        }

        loadVideoSources() {
          if (this.effect) {
            this.effect.addSources();
          }
        }
        /**
         * Viewer has touchdrag event for slideing slides and if we have touchdrag event in the effect (spin) it can make conflict
         * The method fixes conflict
         */


        isEffectActive() {
          if (this.effect && this._type === 'spin') {
            return this.effect.isActive();
          }

          return false;
        }

        activate() {
          if (!this.isActive) {
            this.isActive = true;
          }
        }

        deactivate() {
          this.isActive = false;
        }

        getToolOptions() {
          return this.toolOptions;
        }

        destroy() {
          if (this.effect) {
            this.effect.destroy();

            if (this.additionalEffects.length) {
              this.additionalEffects.forEach(effect => {
                if (effect.effect) {
                  effect.effect.destroy();
                } else {
                  if (!effect.src && effect.datasrc) {
                    effect.node.removeAttribute('src');
                  }
                }
              });
            }
          }

          this.toolOptions = {};
          this.api = {};
          this.isActive = false;
          this.isStarted = false;
          this.isPrepared = false;
          this.off('stats');
          this.off('componentEvent');
          super.destroy();
        }

      }
      /* eslint-env es6 */

      /* global EventEmitter */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Effect" }] */


      const Effects = {};

      const Effect = (() => {
        const getClassName = str => {
          return $J.camelize('-' + str);
        };

        const getDirection = (direction, orientation) => {
          var result;

          if (orientation === 'horizontal') {
            result = direction === 'next' ? 'right' : 'left';
          } else {
            result = direction === 'next' ? 'bottom' : 'top';
          }

          return result;
        };

        class Effect_ extends EventEmitter {
          constructor(options) {
            super();
            this.options = Object.assign({
              effect: 'blank',
              orientation: 'horizontal',
              time: 600,
              easing: 'ease-in-out'
            }, options);
            this.isMove = false;
            this.callbackData = null;
            this.effectName = 'blank';
            this.effect = null;
            this.addEvents();
          }

          addEvents() {
            this.on('effectStart', e => {
              e.data = {
                callbackData: this.callbackData
              };
              this.isMove = true;
            });
            this.on('effectEnd', e => {
              e.data = {
                callbackData: this.callbackData
              };
              this.isMove = false;
              this.effect.destroy();
              this.effect = null;
            });
          }

          make(element1, element2, options, callbackData) {
            const o = Object.assign(this.options, options || {});
            this.stop();
            let name = getClassName(o.effect);

            if (!Object.prototype.hasOwnProperty.call(Effects, name)) {
              name = 'Blank';
            }

            this.effect = new Effects[name](element1, element2, {
              time: o.time,
              easing: o.easing,
              direction: getDirection(o.direction, o.orientation)
            });
            this.effect.parentClass = this;
            this.callbackData = callbackData;
            this.effect.make();
          }

          stop() {
            if (this.effect) {
              this.effect.destroy();
              this.effect = null;
            }

            this.callbackData = null;
          }

          destroy() {
            this.stop();
            this.off('effectStart');
            this.off('effectEnd');
            this.isMove = false;
            super.destroy();
          }

        }

        return Effect_;
      })();
      /* eslint-env es6 */

      /* global Effects */

      /* global EventEmitter */

      /* eslint class-methods-use-this: ["error", {"exceptMethods": ["_move"]}] */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


      class Blank_ extends EventEmitter {
        constructor(element1, element2, options) {
          super();
          this.name = 'blank';
          this.elements = [element1, element2];
          this.elements[0].node = $(this.elements[0].node);
          this.elements[1].node = $(this.elements[1].node);
          this.options = Object.assign({}, options || {});
          this.states = {
            NOT_STARTED: 0,
            MOVING: 1,
            ENDED: 2
          };
          this.state = this.states.NOT_STARTED;
          this.isDestroyed = false;
        }

        _show(index) {
          this.elements[index].node.setCss({
            opacity: 1,
            visibility: 'visible'
          });
        }

        _hide(index) {
          this.elements[index].node.setCss({
            opacity: 0,
            visibility: 'hidden'
          });
        }

        _start() {
          this.emit('effectStart', {
            name: this.name,
            indexes: [this.elements[0].index, this.elements[1].index]
          });

          this._show(0);

          this.elements[0].node.setCssProp('z-index', 9);

          this._show(1);

          this.elements[1].node.setCssProp('z-index', 7);
        }

        _move(callback) {
          callback();
        }

        _end() {
          if (this.state !== this.states.ENDED) {
            this.state = this.states.ENDED;

            this._hide(0);

            this.emit('effectEnd', {
              name: this.name,
              indexes: [this.elements[0].index, this.elements[1].index]
            });
          }
        }

        _clear() {
          this.elements.forEach(element => {
            element.node.setCss({
              zIndex: '',
              opacity: '',
              visibility: ''
            });
          });
        }

        make() {
          if (this.state === this.states.NOT_STARTED) {
            this.state = this.states.MOVING;

            this._start();

            this._move(() => {
              this._end();

              this._clear();
            });
          }
        }

        destroy() {
          if (!this.isDestroyed) {
            this.isDestroyed = true;

            this._end();

            this._clear();

            this.state = this.states.ENDED;
            super.destroy(this);
          }
        }

      }

      Effects.Blank = Blank_;
      /* global Effects, Blank_ */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      Effects.Slide = (() => {
        const toPercentString = value => {
          return value + '%';
        };

        const getNormalizeArray = arr => {
          return arr.map(value => {
            return toPercentString(value);
          });
        };

        class Slide_ extends Blank_ {
          constructor(element1, element2, options) {
            super(element1, element2, options);
            this.options = Object.assign(this.options, Object.assign({
              direction: 'left',
              // top / left / right / bottom
              time: 600,
              easing: 'ease-in-out'
            }, options || {}));
            this.name = 'slide';
            this.from = $([0, -100]);
            this.to = $([100, 0]);

            if (['right', 'bottom'].includes(this.options.direction)) {
              this.from[1] *= -1;
              this.to[0] *= -1;
            }

            this.from = getNormalizeArray(this.from);
            this.to = getNormalizeArray(this.to);
          }

          _show(index) {
            const el = this.elements[index].node;

            if (['left', 'right'].includes(this.options.direction)) {
              this.from[index] = this.from[index] + ', 0%';
              this.to[index] = this.to[index] + ', 0%';
            } else {
              this.from[index] = '0%, ' + this.from[index];
              this.to[index] = '0%, ' + this.to[index];
            }

            el.setCssProp('transform', 'translate3d(' + this.from[index] + ', 0px)');

            super._show(index);
          }

          _move(callback) {
            const options = this.options;
            this.elements[1].node.addEvent('transitionend', e => {
              if (this.elements[1].node.node !== e.target) {
                return;
              }

              e.stop();

              super._move(callback);
            });
            this.elements.forEach((element, index) => {
              element.node.render();
              element.node.setCssProp('transition', 'transform ' + options.time + 'ms ' + options.easing);
              element.node.setCssProp('transform', 'translate3d(' + this.to[index] + ', 0px)');
            });
          }

          _clear() {
            this.elements.forEach(element => {
              element.node.removeEvent('transitionend');
              element.node.setCss({
                transform: '',
                transition: ''
              });
            });

            super._clear(this);
          }

        }

        return Slide_;
      })();
      /* eslint-env es6 */

      /* global Effects, Blank_ */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */


      class Fade_ extends Blank_ {
        constructor(element1, element2, options) {
          super(element1, element2, options);
          this.options = Object.assign(this.options, Object.assign({
            time: 600,
            easing: 'linear'
          }, options || {}));
          this.name = 'fade';
          this.from = $([1, 0]);
          this.to = $([0, 1]);
        }

        _show(index) {
          super._show(index);

          const el = this.elements[index].node;
          el.setCssProp('opacity', this.from[index]);
        }

        _move(callback) {
          const options = this.options;
          this.elements[1].node.addEvent('transitionend', e => {
            if (this.elements[1].node.node !== e.target) {
              return;
            }

            e.stop();

            super._move(callback);
          });
          this.elements.forEach((element, index) => {
            element.node.render();
            element.node.setCssProp('transition', 'opacity ' + options.time + 'ms ' + options.easing);
            element.node.setCssProp('opacity', this.to[index]);
          });
        }

        _clear() {
          this.elements.forEach(element => {
            element.node.removeEvent('transitionend');
            element.node.setCss({
              opacity: '',
              transition: ''
            });
          });

          super._clear();
        }

      }

      Effects.Fade = Fade_;
      /* eslint-env es6 */

      /* global CSS_MAIN_CLASS */

      /* global EventEmitter */

      /* eslint-disable indent */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Arrows" }] */

      const Arrows = (() => {
        const createArrows = (orientation, customClass) => {
          return $(['prev', 'next']).map(value => {
            const container = $J.$new('div').addClass(CSS_MAIN_CLASS + '-arrow-control', CSS_MAIN_CLASS + '-arrow-control-' + value);
            const arrow = $J.$new('div').addClass(CSS_MAIN_CLASS + '-button').addClass(CSS_MAIN_CLASS + '-arrow').addClass(CSS_MAIN_CLASS + '-arrow-' + value);

            if (customClass && customClass !== '') {
              arrow.addClass(CSS_MAIN_CLASS + '-arrow-' + customClass);
            }

            container.append(arrow);
            return container;
          });
        };

        class Arrows_ extends EventEmitter {
          constructor(options) {
            super();
            this.options = Object.assign({
              orientation: 'horizontal',
              customClass: ''
            }, options || {});
            this.arrows = createArrows(this.options.orientation, this.options.customClass);
            this.arrows.forEach((arrow, index) => {
              const _arrowType = !index ? 'prev' : 'next';

              const button = $(arrow.node.firstChild);
              arrow.store('arrowType', _arrowType);
              button.append($J.$new('div').addClass(CSS_MAIN_CLASS + '-icon'));
              button.addEvent(['btnclick', 'tap'], $((typeOfArrow, e) => {
                e.stop();

                if (!arrow.fetch('disabled')) {
                  this.emit('arrowAction', {
                    data: {
                      type: typeOfArrow
                    }
                  });
                }
              }).bind(this, _arrowType));
            });
            this.isShow = true;
          }

          get nodes() {
            return $([this.arrows[0], this.arrows[1]]);
          }

          show() {
            if (!this.isShow) {
              this.arrows.forEach(arrow => {
                arrow.removeClass(CSS_MAIN_CLASS + '-hidden');
              });
              this.isShow = true;
            }
          }

          hide() {
            if (this.isShow) {
              this.isShow = false;
              this.arrows.forEach(arrow => {
                arrow.addClass(CSS_MAIN_CLASS + '-hidden');
              });
            }
          }

          disable(arrow) {
            if (arrow && this.isShow) {
              const indexArrow = arrow === 'forward' ? 1 : 0;
              this.arrows[indexArrow].store('disabled', true);
              $(this.arrows[indexArrow].node.firstChild).attr('disabled', '');
            } else {
              this.arrows.forEach(element => {
                $(element.node.firstChild).removeAttr('disabled');
                element.store('disabled', false);
              });
            }
          }

          destroy() {
            this.arrows.forEach(arrow => {
              $(arrow.node.firstChild).removeEvent(['btnclick', 'tap']);
              arrow.del('arrowType');
              arrow.del('disabled');
              arrow.remove();
            });
            this.arrows = $([]);
            this.isShow = false;
            super.destroy();
          }

        }

        return Arrows_;
      })();

      const Selectors = (() => {
        /* global */

        /* eslint-disable no-unused-vars */
        const getOrientation = position => {
          let result = 'horizontal';

          if (['left', 'right'].includes(position)) {
            result = 'vertical';
          }

          return result;
        };

        const equalOptions = (opt1, opt2) => {
          return !Object.entries(opt1).some(([key, value]) => value !== opt2[key]);
        };

        const DEFAULT_SIZE = {
          width: 560,
          height: 315
        };
        const SELECTORS_STATE = {
          NONE: 0,
          STANDARD: 1,
          FULLSCREEN: 2
        };
        /* eslint-env es6 */

        /* global EventEmitter, globalFunctions, DEFAULT_SIZE, SELECTOR_TAG */

        /* eslint-disable indent */

        /* eslint-disable no-lonely-if */

        /* eslint-disable class-methods-use-this */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

        /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "SelectorContent" }] */

        class SelectorContent extends EventEmitter {
          constructor(node, type, size, orientation) {
            super();
            this.node = $(node);
            this.type = type;
            this.size = size; // 70

            this.orientation = orientation; // selectors orientation 'horizontal' | 'vertical'

            this.getPlaceholderSizePromise = null;
            this.destroyed = false;
            this.loaded = false;
            this.content = null;

            if (this.node.tagName === SELECTOR_TAG) {
              this.content = Array.from(this.node.node.childNodes);
            }
          }

          isLoaded() {
            return this.loaded;
          }

          setCssSize() {
            this.node.setCss(this.selectorSize);
          }

          get selectorSize() {
            const selectorSize = {};

            if (['square', 'crop'].includes(this.type)) {
              selectorSize.width = this.size;
              selectorSize.height = this.size;
            } else {
              if (this.orientation === 'horizontal') {
                selectorSize.height = this.size;
              } else {
                selectorSize.width = this.size;
              }
            }

            return selectorSize;
          }

          get placeholderSize() {
            if (!this.getPlaceholderSizePromise) {
              this.getPlaceholderSizePromise = new Promise(resolve => {
                const size = this.selectorSize;

                if (size.width && size.height) {
                  resolve(size);
                } else {
                  if (this.destroyed) {
                    resolve({
                      width: 0,
                      height: 0
                    });
                  } else {
                    let s;
                    this.proportion.then(_size => {
                      s = _size;
                    }).finally(() => {
                      if (!size.width) {
                        size.width = s.width / s.height * size.height;
                      } else {
                        size.height = s.height / s.width * size.width;
                      }

                      resolve(size);
                    });
                  }
                }
              });
            }

            return this.getPlaceholderSizePromise;
          }

          get proportion() {
            return Promise.resolve(DEFAULT_SIZE);
          }

          complete() {
            this.node.setCss({
              width: '',
              height: ''
            });
            this.setCssSize();
            return Promise.resolve();
          }

          appendTo(container) {
            if (this.content) {
              this.content.forEach(node => {
                container.append(node);
              });
            } else {
              container.append(this.node);
            }
          }

          destroy() {
            this.destroyed = true;
            this.node = null;
            this.getPlaceholderSizePromise = null;
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* global SelectorContent, globalFunctions, DEFAULT_SIZE, helper */

        /* eslint-disable indent */

        /* eslint-disable no-lonely-if */

        /* eslint-disable class-methods-use-this */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

        /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "ImageSelectorContent" }] */


        class ImageSelectorContent extends SelectorContent {
          constructor(node, type, size, orientation, watermark) {
            super(node, type, size, orientation);
            this.imageOrientation = 'horizontal'; // 'horizontal' | 'vertical'

            this.isSirv = false;
            this.watermark = watermark;
            this.src = null;
            this.srcset = null;
            this._imageSize = {
              width: 0,
              height: 0
            };
            this.getProportionPromise = null;
            this.getUrlPromise = null;
            this.loadImagePromise = null;
          }

          setCssSize() {
            if (['square', 'crop'].includes(this.type)) {
              this.customSquare();
            } else {
              this.removeCustomSquare();
            }

            super.setCssSize();
          }

          get proportion() {
            if (!this.getProportionPromise) {
              this.getProportionPromise = new Promise((resolve, reject) => {
                if (this.destroyed) {
                  resolve({
                    width: 0,
                    height: 0
                  });
                } else {
                  this.emit('getSelectorProportion', {
                    data: {
                      resultingCallback: data => {
                        let size = data.size;
                        this.isSirv = data.isSirv;

                        if (size) {
                          if (!size.width) {
                            size = DEFAULT_SIZE;
                          }

                          resolve(size);
                        } else {
                          resolve(DEFAULT_SIZE);
                        }
                      }
                    }
                  });
                }
              });
            }

            return this.getProportionPromise;
          }

          setImageUrl(src, srcset, alt, referrerpolicy) {
            this.src = src;
            this.srcset = srcset;

            if (this.node) {
              if (this.src || this.srcset) {
                if (referrerpolicy) {
                  this.node.attr('referrerpolicy', referrerpolicy);
                }

                if (this.srcset) {
                  this.node.attr('srcset', this.srcset + ' 2x');
                }

                this.node.attr('src', this.src);

                if (!$J.browser.mobile) {
                  // fix for firefox
                  // glueing images to cursor
                  this.node.addEvent('mousedown', e => {
                    e.stopDefaults();
                  });
                }
              }

              if (alt) {
                this.node.attr('alt', alt);
              }
            }
          }

          get url() {
            if (!this.getUrlPromise) {
              this.getUrlPromise = new Promise((resolve, reject) => {
                if (this.destroyed) {
                  resolve(this);
                } else {
                  this.emit('getSelectorImgUrl', {
                    data: {
                      crop: this.type === 'crop',
                      type: this.type,
                      watermark: this.watermark,
                      size: this.selectorSize,
                      resultingCallback: result => {
                        if (result) {
                          this.setImageUrl(result.src, result.srcset, result.alt, result.referrerpolicy);
                          resolve(this);
                        } else {
                          reject(this);
                        }
                      }
                    }
                  });
                }
              });
            }

            return this.getUrlPromise;
          }
          /**
           * @param {{ width: number; height: number; }} size
           */


          set imageSize(size) {
            this._imageSize = size;
            this.imageOrientation = this._imageSize.width >= this._imageSize.height ? 'horizontal' : 'vertical';
          }

          loadImage() {
            if (!this.loadImagePromise) {
              this.loadImagePromise = new Promise((resolve, reject) => {
                if (this.node) {
                  helper.loadImage(this.isSirv ? this.node.node : this.node.node.src).then(imageData => {
                    this.loaded = true;
                    this.imageSize = imageData.size;
                    this.setCssSize();
                    resolve(this);
                  }).catch(error => {
                    if (this.destroyed) {
                      resolve(this);
                    } else {
                      reject(this);
                    }
                  });
                } else {
                  resolve(this);
                }
              });
            }

            return this.loadImagePromise;
          }

          customSquare() {
            if (Math.abs(this._imageSize.width - this._imageSize.height) > 2 && this.node.tagName !== 'div') {
              const div = $J.$new('div').setCss({
                overflow: 'hidden',
                position: 'relative'
              });
              this.node.attr('data-image-orientation', this.imageOrientation);
              div.append(this.node);
              this.node.setCss({
                width: '',
                height: '',
                'max-width': 'none'
              });

              if (this.type === 'crop') {
                if (this.imageOrientation === 'horizontal') {
                  this.node.setCssProp('height', this.size);
                } else {
                  this.node.setCssProp('width', this.size);
                }
              } else {
                if (this.imageOrientation === 'vertical') {
                  this.node.setCssProp('height', this.size);
                } else {
                  this.node.setCssProp('width', this.size);
                }
              }

              this.node = div;
            }
          }

          removeCustomSquare() {
            if (this.node && this.node.tagName === 'div') {
              this.node.removeEvent(['touchstart', 'selectstart', 'contextmenu']); // TODO review it

              this.node.remove();
              this.node = $(this.node.node.firstChild);
              this.node.setCss({
                width: '',
                height: '',
                maxWidth: ''
              });
              this.node.removeAttr('data-image-orientation');
            }
          }

          complete() {
            return this.url.then(() => this.loadImage());
          }

          destroy() {
            if (this.node) {
              this.node.removeEvent('mousedown');
            }

            this.getProportionPromise = null;
            this.getUrlPromise = null;
            this.loadImagePromise = null;
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* global ImageSelectorContent, globalFunctions, helper, EventEmitter, CSS_MAIN_CLASS, SELECTOR_TAG, SELECTORS_STATE, equalOptions, SelectorContent */

        /* eslint-disable indent */

        /* eslint-disable no-lonely-if */

        /* eslint-disable class-methods-use-this */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

        /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Selector" }] */


        class Selector extends EventEmitter {
          constructor(parentNode, index, selector, uuid, options, infoPromise) {
            super();
            this.UUID = uuid;
            this.options = helper.deepExtend({
              standard: {
                type: 'square',
                // 'square' | 'crop' | 'auto' | 'bullets'
                size: 70,
                orientation: 'horizontal',
                // 'horizontal' | 'vertical'
                watermark: true // true | false

              },
              fullscreen: {
                type: 'square',
                // 'square' | 'crop' | 'auto' | 'bullets'
                size: 70,
                orientation: 'horizontal',
                // 'horizontal' | 'vertical'
                watermark: true // true | false

              },
              activeClass: CSS_MAIN_CLASS + '-active',
              placeholderClass: CSS_MAIN_CLASS + '-thumbnail-placeholder',
              selectorContent: null,
              disabled: false
            }, options || {});
            this.parentContainer = $(parentNode);
            this._index = index;
            this.selector = $(selector) || $J.$new('div');
            this._container = $J.$new('div').addClass(CSS_MAIN_CLASS + '-item').setCss({
              display: 'inline-block'
            }); // itemContainer

            this.placeholder = $J.$new('div').addClass(this.options.placeholderClass);
            this._size = {
              width: 0,
              height: 0
            };
            this.currentObject = null;
            this.actived = false;
            this._disabled = false;
            this._destroyed = false;

            this._container.append(this.selector);

            this.parentContainer.append(this._container);

            if (this.options.disabled) {
              this.disable();
            }

            this.infoPromise = infoPromise || Promise.resolve(false);
            this.state = SELECTORS_STATE.NONE;
            this.initPromise = null;
            this.init();
          }

          init() {
            if (!this.initPromise) {
              this.initPromise = new Promise(resolve => {
                this.infoPromise.then(() => {
                  this.standard = this.createContent(this.options.standard);

                  if (this.standard && this.standard instanceof ImageSelectorContent && equalOptions(this.options.standard, this.options.fullscreen)) {
                    this.fullscreen = this.standard;
                  } else {
                    this.fullscreen = this.createContent(this.options.fullscreen, true);
                  }

                  this.selector.append(this.placeholder);
                  const dataType = this.selector.attr('data-type');

                  if (!dataType) {
                    this.selector.setCssProp('font-size', 0);
                  }

                  this.addEvents();
                  this.addCustomClick();
                  resolve();
                });
              });
            }

            return this.initPromise;
          }

          createContent(options, fullscreen) {
            let result;

            if (options.type !== 'bullets') {
              if (this.options.selectorContent) {
                result = new SelectorContent(this.options.selectorContent, options.type, options.size, options.orientation);
              } else {
                const img = $(new Image());
                result = new ImageSelectorContent(img, options.type, options.size, options.orientation, options.watermark);
              }

              result.parentClass = this;
            }

            return result;
          }

          get proportion() {
            let result = Promise.resolve();

            if (!this._disabled) {
              if (this.state === SELECTORS_STATE.FULLSCREEN && this.fullscreen) {
                result = this.fullscreen.proportion;
              } else if (this.standard) {
                result = this.standard.proportion;
              }
            }

            return new Promise((resolve, reject) => {
              this.init().then(() => {
                result.then(resolve).catch(reject);
              });
            });
          }

          get canActivate() {
            return this.options.activated;
          }

          addEvents() {
            this.on('getSelectorProportion', e => {
              e.data.UUID = this.UUID;
            });
            this.on('getSelectorImgUrl', e => {
              e.data.UUID = this.UUID;
            });
          }

          addPlaceholder(selectorType, size) {
            this._container.attr('data-selector-type', selectorType);

            this.selector.append(this.placeholder);
            this.placeholder.setCss(size);
          }
          /*
              1 - SELECTORS_STATE.STANDARD,
              2 - SELECTORS_STATE.FULLSCREEN
          */


          toggle(state
          /* 1 or 2 only */
          ) {
            return new Promise((res, rej) => {
              this.init().then(() => {
                let result;

                const _resolve = Promise.resolve();

                if (this.state !== state) {
                  this.state = state;

                  if (this._disabled) {
                    result = _resolve;
                  } else {
                    let selector = this.standard;
                    let selectorType = this.options.standard.type;

                    if (state === 2) {
                      selector = this.fullscreen;
                      selectorType = this.options.fullscreen.type;
                    }

                    if (selectorType === 'bullets') {
                      this.selector.node.innerHTML = '';
                      this.currentObject = selectorType;

                      this._container.attr('data-selector-type', selectorType);

                      this.emit('resize');
                      result = _resolve;
                    } else {
                      if (!(selector instanceof ImageSelectorContent)) {
                        this._container.attr('data-selector-type', selectorType);
                      }

                      result = new Promise((resolve, reject) => {
                        if (selector) {
                          selector.placeholderSize.then(size => {
                            if (this.state === state && !this._destroyed) {
                              if (!selector.isLoaded() && !this.options.selectorContent) {
                                // NOTE: this.selector.node.innerHTML = ''; doesn't work properly in IE 11
                                while (this.selector.node.firstChild) {
                                  this.selector.node.removeChild(this.selector.node.firstChild);
                                }

                                this.addPlaceholder(selectorType, size);
                              }

                              resolve();
                              selector.complete().then(() => {
                                if (this.state === state && !this._destroyed) {
                                  this._container.attr('data-selector-type', selectorType);

                                  this.placeholder.remove(); // NOTE: this.selector.node.innerHTML = ''; doesn't work properly in IE 11

                                  while (this.selector.node.firstChild) {
                                    this.selector.node.removeChild(this.selector.node.firstChild);
                                  }

                                  selector.appendTo(this.selector);
                                  this.currentObject = selector;
                                  this.emit('resize');
                                }
                              }).catch(() => {// empty
                              });
                            } else {
                              resolve();
                            }
                          });
                        } else {
                          resolve();
                        }
                      });
                    }
                  }
                } else {
                  result = _resolve;
                }

                result.then(res).catch(rej);
              });
            });
          }

          addClick() {
            this._container.addEvent(['btnclick', 'tap'], e => {
              e.stop();
              this.emit('selectorAction', {
                data: this.UUID
              });
            });
          }

          addCustomClick() {
            if (this.options.selectorContent && $J.$(this.options.selectorContent).tagName === SELECTOR_TAG) {
              const nodesList = $(this.options.selectorContent).node.querySelectorAll('a');
              Array.from(nodesList).forEach(item => {
                $J.$(item).addEvent(['btnclick', 'tap'], e => {
                  e.stop();

                  if ($J.$(item).attr('href')[0] === '#') {
                    $J.W.node.location.hash = '';
                    $J.W.node.location.hash = $J.$(item).attr('href');
                  } else {
                    $J.W.node.open($J.$(item).attr('href'));
                  }
                });
              });
            }
          }

          activate() {
            if (!this.actived) {
              this.actived = true;

              this._container.addClass(this.options.activeClass);
            }
          }

          get activated() {
            return this.actived;
          }

          deactivate() {
            if (this.actived) {
              this.actived = false;

              this._container.removeClass(this.options.activeClass);
            }
          }

          get size() {
            this._size = this._container.size;
            return this._size;
          }

          disable() {
            if (!this._disabled) {
              this._disabled = true;

              this._container.attr('disabled', 'true');

              this._container.setCssProp('display', 'none');

              this.deactivate();
              this.emit('resize');
            }
          }

          _toggleForEnable() {
            let neededType;

            if (this.state !== SELECTORS_STATE.NONE) {
              if (this.state === SELECTORS_STATE.STANDARD) {
                neededType = this.standard || 'bullets';
              } else {
                neededType = this.fullscreen || 'bullets';
              }
            }

            let result;

            if (neededType !== this.currentObject) {
              const last = this.state;
              this.state = SELECTORS_STATE.NONE;
              result = this.toggle(last);
            } else {
              result = Promise.resolve();
            }

            return result;
          }

          enable() {
            if (this._disabled) {
              this._disabled = false;

              this._toggleForEnable().then(() => {
                if (!this._disabled) {
                  this._container.removeAttr('disabled');

                  this._container.setCssProp('display', '');

                  this.emit('resize');
                }
              });
            }
          }
          /**
           * @param {number} index
           */


          set index(index) {
            this._index = index;
          }

          get index() {
            return this._index;
          }

          get container() {
            return this._container;
          }

          get pinnedPosition() {
            return this.options.pinned;
          }

          get destroyed() {
            return this._destroyed;
          }

          get disabled() {
            return this._disabled;
          }

          destroy() {
            this._destroyed = true;
            this.placeholder.remove();
            this.off('getSelectorProportion');
            this.off('getSelectorImgUrl');

            if (this.standard) {
              this.standard.destroy();
              this.standard = null;
            }

            if (this.fullscreen) {
              this.fullscreen.destroy();
              this.fullscreen = null;
            }

            this._container.removeEvent(['btnclick', 'tap']);

            this._container.remove();

            this._container = null;
            this.parentContainer = null;
            this.selector = null;
            super.destroy();
          }

        }
        /* eslint-env es6 */

        /* global globalFunctions, helper, EventEmitter, CSS_MAIN_CLASS, SELECTORS_STATE, Selector, getOrientation, Arrows */

        /* eslint-disable indent */

        /* eslint-disable no-lonely-if */

        /* eslint-disable class-methods-use-this */

        /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

        /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Selectors_" }] */


        const SELECTORS = 'selectors';

        const getTime = (maxTime, width, step) => {
          let result = maxTime;
          const minTime = parseInt(maxTime / 3, 10);
          result = parseInt(Math.abs(step) / width * maxTime, 10);

          if (result < minTime) {
            result = minTime;
          } else if (result > maxTime) {
            result = maxTime;
          }

          return result;
        };

        const convertToTranslateString = (value, isHorizontal) => {
          if (isHorizontal) {
            value += 'px, 0';
          } else {
            value = '0, ' + value + 'px';
          }

          return value;
        };

        const normalizeIndex = (index, length) => {
          if (index < 0) {
            index = 0;
          } else if (index > length - 1) {
            index = length - 1;
          }

          return index;
        };

        const isPinned = value => {
          return value === 'start' || value === 'end';
        };

        class Selectors_ extends EventEmitter {
          constructor(selectors, options) {
            super();
            this.options = Object.assign({
              isStandardGrid: false,
              standardStyle: 'square',
              // square | crop | auto | bullets
              standardSize: 70,
              standardPosition: 'bottom',
              // top, left, right, bottom, false
              standardWatermark: true,
              isFullscreenGrid: false,
              fullscreenStyle: 'square',
              // square | crop | auto | bullets
              fullscreenSize: 70,
              fullscreenPosition: 'bottom',
              // top, left, right, bottom, false
              fullscreenAutohide: false,
              fullscreenWatermark: true,
              arrows: true,
              activeClass: CSS_MAIN_CLASS + '-active'
            }, options || {});
            this.instanceNode = $J.$new('div').addClass(CSS_MAIN_CLASS + '-' + SELECTORS).setCss({
              opacity: 0,
              visibility: 'hidden',
              transition: ''
            });
            this.selectorsContainer = $J.$new('div').addClass(CSS_MAIN_CLASS + '-ss');
            this.selectorsScroll = $J.$new('div').addClass(CSS_MAIN_CLASS + '-scroll').setCss({
              transform: 'translate3d(0, 0, 0)'
            });
            this.controlButton = $J.$new('div').addClass(CSS_MAIN_CLASS + '-' + SELECTORS + '-toggle-switch');
            this.selectorsScrollContainer = $J.$new('div').addClass(CSS_MAIN_CLASS + '-selectors-scroll-container');
            this.startPinnedNode = null;
            this.endPinnedNode = null;
            this.baseSelectorsList = [];
            this.pinnedStartList = [];
            this.pinnedEndList = [];
            this.isMove = false;
            this.currentPosition = 0;
            this.containerSize = {
              width: 0,
              height: 0
            };
            this.halfContainerSize = 0;
            this.scrollSize = {
              width: 0,
              height: 0
            };
            this.halfScrollSize = 0;
            this.currentActiveItem = null;
            this.isShown = false;
            this.isControlShown = true;
            this.isControlInDoc = false;
            this.controlDebounce = null;
            this.isReady = false;
            this.resizeTimeout = null;
            this.isActionsEnabled = true;
            this.isDone = false;
            this.isInView = false;
            this.state = SELECTORS_STATE.STANDARD;
            this.arrows = null;
            this._currentStylePosition = this.options.standardPosition;
            this.longSide = null;
            this._shortSide = null;
            this.currentAxis = 'x';
            this.isStarted = false;
            this.isDestroyed = false;

            if (selectors.some(data => !!data.pinned)) {
              this.initPinnedBlocks();
            }

            this.selectors = selectors.map((_selector, index) => this.createSelector(_selector, index));
            this.sortPinnedSelectors();
            this.identifyVariables();
            this.setContainerCss();
          }
          /**
           * find selector by uuid
           * @param {number} uuid 
           * @returns {Selector}
           */


          findSelector(uuid) {
            return this.selectors.find(selector => selector.UUID === uuid) ?? null;
          }

          get hasPinnedSelector() {
            return !!(this.pinnedStartList.length || this.pinnedEndList.length);
          }

          insertBefore(index, selector) {
            let selectors = this.selectors;
            let selectorsScroll = this.selectorsScroll;

            if (this.hasPinnedSelector) {
              if (selector.pinnedPosition === 'start') {
                selectors = this.pinnedStartList;
                selectorsScroll = $J.$(this.startPinnedNode?.node.firstChild.firstChild ?? null);
              } else if (selector.pinnedPosition === 'end') {
                selectors = this.pinnedEndList;
                selectorsScroll = $J.$(this.endPinnedNode?.node.firstChild.firstChild ?? null);
              } else {
                selectors = this.baseSelectorsList;
              }

              index = selectors.indexOf(selector);
            }

            let referenceElement = null;

            if (index + 1 < selectors.length) {
              referenceElement = selectors[index + 1].container;
            }

            this.hide();
            selectorsScroll.node.insertBefore(selector.container.node, referenceElement ? referenceElement.node : referenceElement);
          }

          insert(selectorIndex, selectorObj) {
            if (!!selectorObj.pinned) {
              this.initPinnedBlocks();
              this.appendPinnedBlocks();
            }

            const selector = this.createSelector(selectorObj, selectorIndex);

            if (this.isDone) {
              selector.addClick();
            }

            this.hide();
            this.selectors.splice(selectorIndex, 0, selector);
            this.selectors.forEach((_selector, index) => {
              _selector.index = index;
            });
            this.sortPinnedSelectors();
            this.insertBefore(selectorIndex, selector);
            selector.toggle(this.state);
          }

          disable(uuid) {
            const selector = this.findSelector(uuid);

            if (selector) {
              if (this.currentActiveItem && this.currentActiveItem === selector) {
                this.currentActiveItem = null;
              }

              this.hide();
              selector.disable();
            }
          }

          enable(uuid) {
            const selector = this.findSelector(uuid);

            if (selector) {
              this.hide();
              selector.enable();
            }
          }

          pickOut(uuid) {
            const selector = this.findSelector(uuid);

            if (selector) {
              selector.destroy();
              this.selectors.splice(selector.index, 1);
              this.selectors.forEach((_selector, _index) => {
                _selector.index = _index;
              });
              this.sortPinnedSelectors();
            }
          }

          createSelector(selectorData, index) {
            let container = this.selectorsScroll;

            if (selectorData.pinned === 'start') {
              container = this.startPinnedNode?.node.firstChild.firstChild ?? null;
            } else if (selectorData.pinned === 'end') {
              container = this.endPinnedNode?.node.firstChild.firstChild ?? null;
            }

            const selector = new Selector(container, index, selectorData.node, selectorData.UUID, {
              standard: {
                type: this.options.standardStyle,
                size: this.options.standardSize,
                orientation: getOrientation(this.options.standardPosition),
                watermark: this.options.standardWatermark
              },
              fullscreen: {
                type: this.options.fullscreenStyle,
                size: this.options.fullscreenSize,
                orientation: getOrientation(this.options.fullscreenPosition),
                watermark: this.options.fullscreenWatermark
              },
              activeClass: this.options.activeClass,
              selectorContent: selectorData.selectorContent,
              disabled: selectorData.disabled,
              pinned: selectorData.pinned,
              activated: selectorData.activated
            }, selectorData.infoPromise);
            selector.parentClass = this;
            return selector;
          }

          addEventsFromSelectors() {
            this.on('selectorAction', e => {
              e.stopAll();
              this.emit('changeSlide', {
                data: {
                  UUID: e.data
                }
              });
              const index = this.selectors.find(selector => selector.UUID === e.data);

              if (index !== $J.U) {
                this.activateItem(index);
              }
            });
            let timer;
            this.on('resize', e => {
              e.stopAll();
              clearTimeout(timer);
              timer = setTimeout(() => {
                this.onResize();
              }, 16);
            });
          }

          initPinnedBlocks() {
            if (!this.pinnedBlocksInited) {
              const createNodes = className => {
                return $J.$new('div').addClass(CSS_MAIN_CLASS + className).append($J.$new('div').addClass(CSS_MAIN_CLASS + '-ss').append($J.$new('div').addClass(CSS_MAIN_CLASS + '-scroll').setCss({
                  transform: 'translate3d(0, 0, 0)'
                })));
              };

              this.startPinnedNode = createNodes('-selectors-pinned-start');
              this.endPinnedNode = createNodes('-selectors-pinned-end');
            }
          }

          get pinnedBlocksInited() {
            return !!this.startPinnedNode && !!this.endPinnedNode;
          }

          appendPinnedBlocks() {
            if (this.pinnedBlocksInited) {
              this.instanceNode.append(this.startPinnedNode);
              this.instanceNode.append(this.endPinnedNode);
            }
          }

          sortPinnedSelectors() {
            this.pinnedStartList = this.selectors.filter(selector => selector.pinnedPosition === 'start');
            this.pinnedEndList = this.selectors.filter(selector => selector.pinnedPosition === 'end');
            this.baseSelectorsList = this.selectors.filter(selector => !selector.pinnedPosition);
          }

          init() {
            this.createArrows();
            this.selectorsScrollContainer.append(this.selectorsContainer).appendTo(this.instanceNode);
            this.appendPinnedBlocks();

            if (this.arrows) {
              this.arrows.hide();
              const arrowsNodes = this.arrows.nodes;
              this.selectorsScrollContainer.append(arrowsNodes[0]);
              this.selectorsScrollContainer.append(arrowsNodes[1]);
            }

            this.selectorsContainer.append(this.selectorsScroll);
            this.isShown = true;
            this.hide();
            this.identifyVariables();
            this.addEventsFromSelectors();

            if (!this._currentStylePosition) {
              this.instanceNode.setCssProp('display', 'none');
            }

            Promise.all(this.selectors.map(selector => selector.proportion)).finally(() => {
              this.isReady = true;
              this.emit('selectorsReady');
            });
          }

          identifyVariables() {
            if (this._currentStylePosition) {
              const isHorizontal = getOrientation(this._currentStylePosition) === 'horizontal';
              this.longSide = isHorizontal ? 'width' : 'height';
              this._shortSide = this.longSide === 'width' ? 'height' : 'width';
              this.currentAxis = isHorizontal ? 'x' : 'y';
            } else {
              this.longSide = null;
              this._shortSide = null;
            }
          }

          changeSelectors(direction) {
            return Promise.all(this.selectors.map(selector => selector.toggle(direction)));
          }

          getSelectorsSize() {
            return this.selectors.filter(selector => !selector.destroyed).map(selector => selector.size);
          }

          enableActions() {
            if (!this.isActionsEnabled) {
              this.isActionsEnabled = true;
              this.show();

              if (this.options.fullscreenAutohide) {
                this.selectorsState = true;
              }
            }
          }

          disableActions() {
            if (this.isActionsEnabled) {
              this.isActionsEnabled = false;
              this.hide();

              if (this.controlDebounce) {
                this.controlDebounce.cancel();
              }
            }
          }

          show(force) {
            if (!this.isShown && this.isActionsEnabled && !this.isDestroyed) {
              const _transition = force ? '' : 'opacity 400ms linear';

              this.isShown = true;
              this.selectorsScroll.setCss({
                display: 'inline-flex'
              }); // for rendering

              this.getSizes();
              this.jump(this.activatedItem, true);
              this.instanceNode.setCss({
                opacity: 1,
                visibility: 'visible',
                transition: _transition
              });
            }
          }

          get activatedItem() {
            return this.currentActiveItem ? this.currentActiveItem.index : 0;
          }

          activateCurrentItemByUUID(uuid) {
            const selector = this.findSelector(uuid);

            if (selector && !this.currentActiveItem) {
              this.currentActiveItem = selector;
            }
          }

          hide() {
            if (this.isShown) {
              this.isShown = false;
              this.instanceNode.setCss({
                opacity: 0,
                visibility: 'hidden',
                transition: ''
              });
            }
          }

          start(parentSlider) {
            if (!this.isStarted && this.isInView) {
              this.isStarted = true;

              if (this._currentStylePosition) {
                this.changeSelectors(1).then(() => globalFunctions.rootDOM.addMainStyle(parentSlider)).then(() => {
                  if (!this.isDestroyed) {
                    this.getSelectorsSize();
                    this.done();
                    this.show();
                  }
                });
              } else {
                this.done();
              }
            }
          }

          addControl() {
            if (!this.isControlInDoc) {
              this.instanceNode.addEvent(['mouseover', 'mouseout'], e => {
                let relatedTarget = e.related;

                if (relatedTarget) {
                  relatedTarget = $(relatedTarget);
                }

                while (relatedTarget && relatedTarget.node !== this.instanceNode.node && relatedTarget.node !== $J.D.node.body) {
                  relatedTarget = relatedTarget.node.parentNode;

                  if (relatedTarget) {
                    relatedTarget = $(relatedTarget);
                  }
                }

                if (!relatedTarget || relatedTarget.node !== this.instanceNode.node) {
                  this.setControlTimeout(e.type === 'mouseover');
                }
              });
              this.controlButton.addEvent(['btnclick', 'tap'], e => {
                this.setControlTimeout(true);
                this.selectorsState = !this.isControlShown;
              });
              $(this.instanceNode.node.parentNode).append(this.controlButton);
              this.controlDebounce = helper.debounce(() => {
                this.selectorsState = false;
              }, 3000);
              this.isControlInDoc = true;
            }
          }

          removeControl() {
            if (this.isControlInDoc) {
              this.instanceNode.removeEvent(['mouseover', 'mouseout']);
              this.controlDebounce.cancel();
              this.isControlShown = true;
              this.controlButton.removeEvent(['btnclick', 'tap']);
              this.controlButton.remove();
              this.isControlInDoc = false;
            }
          }
          /**
           * @param {boolean} open
           */


          set selectorsState(open) {
            this.isControlShown = open;
            this.setControlTimeout();
            this.emit('visibility', {
              action: this.isControlShown ? 'show' : 'hide'
            });
          }

          setControlTimeout(justClear) {
            if (this.isControlInDoc) {
              this.controlDebounce.cancel();

              if (this.isControlShown && !justClear) {
                this.controlDebounce();
              }
            }
          }

          get node() {
            return this.instanceNode;
          }

          get horizontal() {
            return getOrientation(this._currentStylePosition) === 'horizontal';
          }

          inView(value, parentSlider) {
            this.isInView = value; // sometimes selectors can be inside external container and we do not know which container with 'Sirv' class name inicialide it
            // so we need pass it for right adding css in shadow dom

            this.start(parentSlider);
          }

          done() {
            if (!this.isDone && !this.isDestroyed) {
              this.isDone = true;
              this.getSizes();
              this.selectors.forEach(selector => {
                selector.addClick();
              });
              this.onResize();
              this.setDrag();
              this.emit('selectorsDone');
            }
          }

          activateItem(index) {
            const selector = this.selectors[index];

            if (selector) {
              if (this.currentActiveItem) {
                this.currentActiveItem.deactivate();
              }

              if (!selector.disabled && selector.canActivate) {
                selector.activate();
                this.currentActiveItem = selector;
              }

              if (!selector.activated && this.currentActiveItem) {
                this.currentActiveItem.activate();
              }
            }
          }

          createArrows() {
            if (!this.options.arrows || this.options.standardStyle === 'grid' && this.options.standardStyle === 'grid') {
              return;
            }

            this.arrows = new Arrows({
              orientation: getOrientation(this.currentPosition || this.options.fullscreenPosition),
              customClass: 'thumbnails'
            });
            this.arrows.parentClass = this;
            this.on('arrowAction', e => {
              e.stopAll();
              this.jump(e.data.type);
            });
          }

          isGrid() {
            if (this.state === SELECTORS_STATE.FULLSCREEN) {
              return this.options.isFullscreenGrid;
            }

            return this.options.isStandardGrid;
          }

          calculateContainerScroll() {
            if (this.hasPinnedSelector || this.pinnedBlocksInited) {
              const instanceSize = this.instanceNode.size;

              if (this.arrows) {
                this.arrows.hide();
              }

              let maxWidth = instanceSize[this.longSide] - (this.startPinnedNode.size[this.longSide] + this.endPinnedNode.size[this.longSide]);

              if (maxWidth < 0) {
                maxWidth = 0;
              }

              if (this.scrollSize[this.longSide] < maxWidth) {
                maxWidth = this.scrollSize[this.longSide];
              }

              this.selectorsScrollContainer.setCssProp('max-' + this.longSide, maxWidth);
              this.getSizes();
            }
          }

          normalizePositionValue(value) {
            const max = this.containerSize[this.longSide] - this.scrollSize[this.longSide];

            if (this.arrows) {
              this.arrows.disable();

              if (max >= 0 || this.isGrid()) {
                this.arrows.hide();
                this.getSizes();
              } else {
                if (!this.arrows.isShow) {
                  this.arrows.show();
                  this.getSizes();
                }
              }
            }

            if (max === 0) {
              return 0;
            }

            if (this.halfScrollSize <= this.halfContainerSize) {
              value = this.halfContainerSize - this.halfScrollSize;
            } else {
              if (value >= 0) {
                value = 0;

                if (this.arrows) {
                  this.arrows.disable('backward');
                }
              }

              if (value <= max) {
                value = max;

                if (this.arrows) {
                  this.arrows.disable('forward');
                }
              }
            }

            return value;
          }

          findItemPosition(index) {
            if (!this.selectors[index] || this.selectors[index].pinnedPosition) {
              return null;
            }

            index = normalizeIndex(index, this.selectors.length);

            if (this.hasPinnedSelector) {
              const i = this.baseSelectorsList.indexOf(this.selectors[index]);

              if (i < 0) {
                i = index;
              }

              index = i;
            }

            const halfSelectorSize = this.selectors[index].size[this.longSide] / 2;
            let position = 0;
            let currentIndex = 0;

            while (currentIndex < index) {
              if (this.selectors[currentIndex]) {
                position += this.selectors[currentIndex].size[this.longSide];
              }

              currentIndex += 1;
            }

            const transitionPosition = this.halfContainerSize - (position + halfSelectorSize);
            return this.normalizePositionValue(transitionPosition);
          }

          stopMoving() {
            if (this.isMove) {
              let position = helper.getMatrix(this.selectorsScroll);

              if (position) {
                position = position.transform[this.currentAxis];
                this.currentPosition = position;
              }

              this.clearAnimation();
              this.selectorsScroll.setCssProp('transform', 'translate3d(' + convertToTranslateString(this.currentPosition, this.horizontal) + ', 0)');
            }
          }

          clearAnimation() {
            if (this.selectorsScroll) {
              this.selectorsScroll.removeEvent('transitionend');
              this.selectorsScroll.setCssProp('transition', '');
            }

            this.isMove = false;
          }

          jump(direction, withoutAnimation) {
            let value = this.currentPosition;
            this.stopMoving();

            if ($J.typeOf(direction) === 'string' || $J.typeOf(direction) === 'number') {
              if ($J.typeOf(direction) === 'string') {
                if (direction === 'next') {
                  value -= this.containerSize[this.longSide];
                } else {
                  value += this.containerSize[this.longSide];
                }

                value = this.normalizePositionValue(value);
              } else {
                value = this.findItemPosition(direction);
              }
            } else {
              return;
            }

            if (value !== null) {
              this.move(value, null, withoutAnimation);
            }
          }

          move(value, speed, withoutAnimation) {
            if (!speed) {
              speed = 400;
            }

            if (this.currentPosition === value) {
              return;
            }

            this.selectorsScroll.removeEvent('transitionend');
            const css = {};

            if (!withoutAnimation) {
              this.isMove = true;
              this.selectorsScroll.addEvent('transitionend', e => {
                e.stop();
                this.clearAnimation();
              });
              css.transition = 'transform ' + getTime(speed, this.containerSize[this.longSide], Math.abs(value) - Math.abs(this.currentPosition)) + 'ms ease';
            }

            css.transform = 'translate3d(' + convertToTranslateString(value, this.horizontal) + ', 0)';
            this.selectorsScroll.setCss(css);
            this.currentPosition = value;
          }

          getSizes() {
            this.containerSize = this.selectorsContainer.size;
            this.halfContainerSize = this.containerSize[this.longSide] / 2;
            this.scrollSize = this.selectorsScroll.size;
            this.halfScrollSize = this.scrollSize[this.longSide] / 2;
          }

          setDrag() {
            const fns = {};
            let lastXY = {
              x: null,
              y: null
            };
            let move = false;
            let containerPosition;
            let last;
            let diffSize;
            let distance;
            let axis;
            let otherAxis;
            let side;
            let direction;
            let startTimeStamp;
            let dragState = 0; // 0 - nothing, 1 - drag, 2 - sroll page

            const getXY = (x, y) => {
              return {
                x: x - containerPosition.left,
                y: y - containerPosition.top
              };
            };

            const getDirection = (oldValue, newValue) => {
              return oldValue > newValue ? 'next' : 'prev';
            };

            const culcDistance = (dist, speed) => {
              const min = dist / 2; // const max = dist * 2;

              return dist + min;
            };

            const onDrag = e => {
              fns[e.state](e);
            };

            fns.dragstart = e => {
              axis = this.currentAxis;
              otherAxis = axis === 'x' ? 'y' : 'x';
              side = this.longSide;
              lastXY = {
                x: e.x,
                y: e.y
              };

              if (this.containerSize[side] < this.scrollSize[side]) {
                move = true;
              }

              containerPosition = this.selectorsContainer.position;
              this.stopMoving();
              last = getXY(e.x, e.y)[axis];
              diffSize = this.containerSize[side] - this.scrollSize[side];
              distance = 0;
              startTimeStamp = e.timeStamp;
            };

            fns.dragend = e => {
              let value;
              let speed;

              if (move) {
                move = false;
                e.stop();
                speed = e.timeStamp - startTimeStamp;
                value = this.currentPosition - culcDistance(distance, speed);

                if (value > 0 || value < diffSize) {
                  if (value > 0) {
                    value = 0;
                  } else {
                    value = diffSize;
                  }
                }

                value = this.normalizePositionValue(value);
                this.move(value);
                direction = null;
              }

              dragState = 0;
            };

            fns.dragmove = e => {
              let point;
              let diff;
              let dir;

              if (!dragState) {
                if (Math.abs(lastXY[axis] - e[axis]) > Math.abs(lastXY[otherAxis] - e[otherAxis])) {
                  dragState = 1;
                } else {
                  dragState = 2;
                }
              }

              if (move && dragState === 1) {
                point = getXY(e.x, e.y);

                if (point[axis] > point[otherAxis]) {
                  e.stop();
                  diff = last - point[axis];
                  this.currentPosition -= diff;
                  dir = getDirection(last, point[axis]);

                  if (!direction || dir !== direction) {
                    distance = 0;
                  }

                  distance += diff;
                  last = point[axis];
                  direction = dir;
                }

                this.selectorsScroll.setCssProp('transform', 'translate3d(' + convertToTranslateString(this.currentPosition, this.horizontal) + ', 0)');
              }

              lastXY = {
                x: e.x,
                y: e.y
              };
            };

            this.selectorsContainer.addEvent(['mousedrag', 'touchdrag'], onDrag);
          }

          setContainerCss() {
            const css = {};
            let size = this.options.standardSize;

            if (this.state === SELECTORS_STATE.FULLSCREEN) {
              size = this.options.fullscreenSize;
            }

            css['min-' + this._shortSide] = size + 'px';
            css[this._shortSide] = '100%';
            this.instanceNode.setCss(css);
          }

          beforeEnterFullscreen() {
            this.hide();
            this.state = SELECTORS_STATE.FULLSCREEN;
            this._currentStylePosition = this.options.fullscreenPosition;

            if (!this._currentStylePosition) {
              this.instanceNode.setCssProp('display', 'none');
              $(this.instanceNode.node.parentNode).setCssProp('display', 'none');
            }

            this.identifyVariables();
          }

          afterEnterFullscreen() {
            if (this._currentStylePosition) {
              this.instanceNode.setCssProp('display', '');
              $(this.instanceNode.node.parentNode).setCssProp('display', '');
              this.setContainerCss();

              if (this.options.fullscreenAutohide) {
                this.addControl();

                if (this.isActionsEnabled) {
                  this.selectorsState = true;
                }
              }

              this.removeStyleForIE();
              this.changeSelectors(2).then(() => {
                this.getSelectorsSize();
                setTimeout(() => {
                  this.show();
                }, 150); // must be more than resize timeout

                if (this._currentStylePosition && this.isActionsEnabled) {
                  setTimeout(() => {
                    this.selectorsState = true;
                  }, 1000);
                }
              });
            }
          }

          beforeExitFullscreen() {
            this.hide();
            this.state = SELECTORS_STATE.STANDARD;
            this._currentStylePosition = this.options.standardPosition;

            if (this.options.fullscreenAutohide) {
              this.removeControl();
            }

            if (!this._currentStylePosition) {
              this.instanceNode.setCssProp('display', 'none');
              $(this.instanceNode.node.parentNode).setCssProp('display', 'none');
            }

            this.identifyVariables();
          }

          afterExitFullscreen() {
            if (this._currentStylePosition) {
              this.instanceNode.setCssProp('display', '');
              $(this.instanceNode.node.parentNode).setCssProp('display', '');
              this.setContainerCss();
              this.removeStyleForIE();
              this.changeSelectors(1).then(() => {
                this.getSelectorsSize();
                this.show();
              });
            }
          }

          get currentStylePosition() {
            if (this.state === SELECTORS_STATE.FULLSCREEN) {
              return this.options.fullscreenPosition;
            } else {
              return this.options.standardPosition;
            }
          }

          removeStyleForIE() {
            if ($J.browser.uaName === 'ie') {
              this.selectorsScroll.setCssProp(this.shortSide, '');
            }
          }

          removeStyleForIE() {
            if ($J.browser.uaName === 'ie') {
              this.selectorsScroll.setCssProp(this.shortSide, '');
            }
          }

          isSelectorsActionEnabled() {
            return this.isActionsEnabled;
          }

          get shortSide() {
            return this._shortSide;
          }

          sortSelectors(uuidList, orderLength) {
            this.selectors = uuidList.map(uuid => this.selectors.find(selector => selector.UUID === uuid));
            this.selectors.forEach((selector, index) => {
              selector.index = index;
            });

            for (let i = orderLength - 1; i >= 0; i--) {
              this.selectorsScroll.node.insertBefore(this.selectors[i].container.node, this.selectorsScroll.node.firstChild);
            }
          }

          onResize() {
            if (this.isDone && this._currentStylePosition && !this.isDestroyed) {
              clearTimeout(this.resizeTimeout);
              this.resizeTimeout = setTimeout(() => {
                // the timer helps calc new size of selectors after changing size of images
                const itemIndex = this.activatedItem;
                this.clearAnimation();

                if ($J.browser.uaName === 'ie') {
                  const selectorSize = this.isGrid() ? '' : this.selectors.reduce((previousValue, selector) => {
                    if (!selector.destroyed) {
                      previousValue += selector.size[this.longSide];
                    }

                    return previousValue;
                  }, 0);
                  this.selectorsScroll.setCssProp(this.longSide, selectorSize);
                }

                this.getSizes();
                this.calculateContainerScroll();
                this.activateItem(itemIndex);
                this.normalizePositionValue();
                this.jump(itemIndex, true);
                this.show();
              }, 100);
            }
          }

          destroy() {
            this.isDestroyed = true;
            clearTimeout(this.resizeTimeout);
            this.instanceNode.removeEvent('transitionend');
            this.removeControl();
            this.controlButton = null;
            this.off('selectorAction');
            this.off('resize');
            this.clearAnimation();

            if (this.arrows) {
              this.arrows.destroy();
              this.arrows = null;
              this.off('arrowAction');
            }

            this.selectors.forEach(selector => {
              selector.destroy();
            });
            this.selectorsScroll.remove();
            this.selectorsScroll = null;
            this.selectorsContainer.remove();
            this.selectorsContainer = null;
            this.instanceNode.remove();
            this.instanceNode = null;
            this.currentActiveItem = null;

            if (this.pinnedBlocksInited) {
              this.baseSelectorsList = [];
              this.pinnedStartList = [];
              this.pinnedEndList = [];
              this.endPinnedNode = null;
              this.startPinnedNode = null;
              this.selectorsScrollContainer = null;
              this.pinnedStartList = null;
              this.pinnedEndList = null;
            }

            super.destroy();
          }

        }

        return Selectors_;
      })();
      /* eslint-env es6 */

      /* global defaultsVideoOptions */

      /* global EventEmitter */

      /* global helper */

      /* global CSS_MAIN_CLASS */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "slideVideo" }] */


      const slideVideo = (() => {
        const correctVideoSrc = node => {
          node = $(node);

          const _src = node.attr('data-src');

          if (_src) {
            node.attr('data-src', _src.split('?')[0]);
            node.removeAttr('src');
          } else {
            node.node.src = node.node.src.split('?')[0];
          }

          return node;
        };

        const getOptions = (node, opts) => {
          const options = new $J.Options(defaultsVideoOptions);
          options.fromJSON(opts.common.common);
          options.fromString(opts.local.common);
          options.fromString(node.attr('data-options') || '');

          if ($J.browser.touchScreen && $J.browser.mobile) {
            // options.parseSchema(mobileDefaults, true);
            options.fromJSON(opts.common.mobile);
            options.fromString(opts.local.mobile);
            options.fromString(node.attr('data-mobile-options') || '');
          }

          return options;
        };

        class HTMLVideo extends EventEmitter {
          constructor(node, options) {
            super();
            this._node = $(node);
            this.instanceOptions = getOptions(this._node, options);

            this.option = (...args) => {
              if (args.length > 1) {
                return this.instanceOptions.set(args[0], args[1]);
              }

              return this.instanceOptions.get(args[0]);
            };

            this.type = 'video';
            this.player = null;
            this.state = globalVariables.VIDEO.NONE;
            this.isReady = false;
            this.isShown = false;
            this.id = null;
            this.playDebounce = null;
            this.currentTime = 0;
            this.videoNode = $J.$new('div');
            this.videoWrapper = $J.$new('div').addClass(CSS_MAIN_CLASS + '-video').setCss({
              transition: 'opacity .3 linear'
            });
            this.videoWrapper.attr('data-video-type', this.type);
            this.fullscreen = this.option('controls.fullscreen');
            this.hide();
          }

          get autoplay() {
            return this.option('autoplay');
          }

          onBeforeFullscreenIn() {
            this.getCurrentTime();
            this.fullscreen = false;
          }

          onAfterFullscreenIn() {}

          onBeforeFullscreenOut() {
            this.getCurrentTime();
            this.fullscreen = this.option('controls.fullscreen');
          }

          onAfterFullscreenOut() {}

          getSize() {
            return new Promise(resolve => {
              const size = this.videoWrapper.size;

              if (size.width && size.height) {
                resolve(size);
              } else {
                helper.videoModule.getAspectRatio(this._node).then(aspectratio => {
                  if (size.width) {
                    size.height = size.width * aspectratio;
                  } else {
                    size.width = size.height / aspectratio;
                  }

                  resolve(size);
                }).catch(() => {
                  resolve(null);
                });
              }
            });
          }

          createPlayer(player) {
            this.player = {
              ready: true,
              play: () => {
                this.playDebounce();
              },
              pause: () => {
                this.player.player.node.pause();
              },
              player: this._node
            };
            this.playDebounce = helper.debounce(() => {
              this.player.player.node.play();
            }, 100);

            if (this.option('loop')) {
              this.player.player.attr('loop', 'loop');
            } else {
              this.player.player.removeAttr('loop');
            }

            this.player.player.attr('playsinline', 'playsinline');

            if (this.option('controls.enable')) {
              this.player.player.attr('controls', 'controls');
            } else {
              this.player.player.removeAttr('controls');
            }

            if (this.autoplay) {
              this.player.player.volume = 0;
              this.player.player.attr('muted', 'muted');
            } else {
              this.player.player.volume = this.option('volume') / 100;
            }

            this.player.player.attr('preload', this.option('preload') ? 'auto' : 'none');
            this.addEvents();
            this.emit('slideVideoReady', {
              data: {
                type: this.type,
                error: null
              }
            });
            return Promise.resolve();
          }

          get node() {
            return this.videoWrapper;
          }

          init() {
            if (this.type === 'video') {
              let _src = this._node.attr('data-src');

              if (_src) {
                this._node.attr('src', _src);
              }

              Array.from(this._node.node.children).forEach(child => {
                child = $(child);

                if (child && child.tagName === 'source') {
                  _src = child.attr('data-src');

                  if (_src) {
                    child.attr('src', _src);

                    if ($J.browser.engine === 'gecko') {
                      child.node.parentNode.load();
                    }
                  }
                }
              });
              this.videoNode = this._node;
            }

            this.id = this.type + '-' + helper.generateUUID();
            this.videoNode.attr('id', this.id);
            this.videoWrapper.append(this.videoNode);
            const data = {
              type: this.type,
              error: null
            };
            helper.videoModule.getAPI(this._node).then(player => {
              this.createPlayer(player).then(() => {
                data.error = false;
              }).catch(_err => {
                data.error = !!_err;
              }).finally(() => {
                this.isReady = true; // this.emit('slideVideoReady', { data: data });
              });
            }).catch(err => {
              data.error = true;
              this.emit('slideVideoReady', {
                data: data
              });
            });
          }

          addEvents() {
            this.player.player.addEvent('play', e => {
              e.stop();
              this.state = globalVariables.VIDEO.PLAY;
              this.emit('slideVideoPlay', {
                data: {
                  type: this.type
                }
              });
            });
            this.player.player.addEvent('pause', e => {
              e.stop();
              this.state = globalVariables.VIDEO.PAUSE;
              this.emit('slideVideoPause', {
                data: {
                  type: this.type
                }
              });
            });
            this.player.player.addEvent('ended', e => {
              e.stop();
              this.state = globalVariables.VIDEO.PAUSE;
              this.emit('slideVideoEnd', {
                data: {
                  type: this.type
                }
              });
            });
          }

          play() {
            if (this.player && this.player.ready) {
              this.setCurrentTime();
              this.player.play();
            }
          }

          pause() {
            if (this.player && this.player.ready) {
              this.player.pause();
            }
          }

          getCurrentTime() {
            if (this.player && this.player.player) {
              this.currentTime = this.player.player.currentTime;
            }
          }

          setCurrentTime() {
            if (this.player && this.player.ready) {
              this.player.player.currentTime = this.currentTime;
            }
          }

          get preStart() {
            return this.state === globalVariables.VIDEO.NONE;
          }

          get paused() {
            return this.state === globalVariables.VIDEO.PAUSE;
          }

          show() {
            this.isShown = true;
            this.videoWrapper.setCssProp('opacity', 1);
          }

          hide() {
            this.isShown = false;
            this.videoWrapper.setCssProp('opacity', 0);
          }

          destroy() {
            if (this.playDebounce) {
              this.playDebounce.cancel();
              this.playDebounce = null;
            }

            this.pause();
            this.videoWrapper.remove();
            this._node = correctVideoSrc(this._node);

            if (this.type === 'video') {
              Array.from(this._node.node.children).forEach(child => {
                if ($(child).tagName === 'source') {
                  correctVideoSrc(child);
                }
              });
            }

            super.destroy();
          }

        }

        class YouTubeVideo extends HTMLVideo {
          constructor(node, options) {
            super(node, options);
            this.type = 'youtube';
            this.playerState = -1;
            this.videoWrapper.attr('data-video-type', this.type);
            this.apiPlayer = null;
          }

          setCurrentTime() {
            if (this.player && this.player.ready) {
              this.player.player.seekTo(this.currentTime);
            }
          }

          getCurrentTime() {
            if (this.player && this.player.player) {
              if (this.player.player.getCurrentTime) {
                this.currentTime = this.player.player.getCurrentTime();
              } else {
                this.currentTime = 0;
              }
            }
          }

          destroyVideoPlayer() {
            this.getCurrentTime();

            if (this.player && this.player.player) {
              this.player.ready = false;
              this.player.player.destroy();
            }

            this.playerState = -1;
          }

          onBeforeFullscreenIn() {
            this.fullscreen = false; // we must destroy and create player because the 'onStateChange' won't work after change DOM

            this.destroyVideoPlayer();
          }

          onAfterFullscreenIn() {
            this.createPlayer(this.apiPlayer);
          }

          onBeforeFullscreenOut() {
            this.fullscreen = this.option('controls.fullscreen'); // we must destroy and create player because the 'onStateChange' won't work after change DOM

            this.destroyVideoPlayer();
          }

          onAfterFullscreenOut() {
            this.createPlayer(this.apiPlayer);
          }

          createPlayer(player) {
            this.apiPlayer = player;
            return new Promise((resolve, reject) => {
              const videoID = helper.videoModule.getId(this._node);
              this.player = {
                ready: false,
                play: () => {
                  this.player.player.playVideo();
                },
                pause: () => {
                  this.player.player.pauseVideo();
                },
                player: new player.Player(this.id, {
                  videoId: videoID,
                  playerVars: {
                    playlist: videoID,
                    // it is just for loop parameter
                    fs: this.fullscreen ? 1 : 0,
                    rel: 0,
                    loop: this.option('loop') ? 1 : 0,
                    autoplay: 0,
                    playsinline: 1,
                    controls: this.option('controls.enable') ? 1 : 0
                  },
                  events: {
                    'onReady': () => {
                      this.playerState = -1;
                      this.player.ready = true;
                      this.player.player.setVolume(this.option('volume'));
                      this.emit('slideVideoReady', {
                        data: {
                          type: this.type,
                          error: null
                        }
                      });
                      resolve();
                    },
                    'onError': err => {
                      if (err.data === 100) {
                        // 'Video is not found'
                        this.player = null;
                      }

                      this.emit('slideVideoReady', {
                        data: {
                          type: this.type,
                          error: true
                        }
                      });
                      reject(true);
                    },
                    'onStateChange': this.addEvents.bind(this)
                  }
                })
              };
            });
          }

          addEvents(e) {
            const state = (e.target || e.target).getPlayerState();
            this.playerState = state;

            if (this.state === globalVariables.VIDEO.PLAY) {
              this.state = globalVariables.VIDEO.PAUSE;
            }

            switch (state) {
              case -1:
                break;

              case 0:
                // console.log('finish');
                if (!this.option('loop')) {
                  this.player.pause();
                }

                this.emit('slideVideoEnd', {
                  data: {
                    type: this.type
                  }
                });
                break;

              case 1:
                // console.log('play');
                this.state = globalVariables.VIDEO.PLAY;
                this.emit('slideVideoPlay', {
                  data: {
                    type: this.type
                  }
                });
                break;

              case 2:
                // console.log('pause');
                this.state = globalVariables.VIDEO.PAUSE;
                this.emit('slideVideoPause', {
                  data: {
                    type: this.type
                  }
                });
                break;

              case 3:
                // console.log('buffering');
                break;

              case 5:
                // console.log('video cued');
                break;
              // no default
            }
          }

          destroy() {
            super.destroy();

            if (this.player && this.player.player) {
              this.player.player.destroy();
              this.player.player = null;
            }
          }

        } // urls
        // http://vimeo.com/6701902
        // http://vimeo.com/670190233
        // https://vimeo.com/11111111
        // https://www.vimeo.com/11111111
        // http://player.vimeo.com/video/67019023
        // http://player.vimeo.com/video/67019022?title=0&byline=0&portrait=0
        // https://vimeo.com/channels/11111111
        // http://vimeo.com/channels/vimeogirls/6701902
        // http://vimeo.com/channels/staffpicks/6701902
        // https://vimeo.com/album/2222222/video/11111111
        // https://vimeo.com/groups/name/videos/11111111
        // https://vimeo.com/11111111?param=test
        // wrong
        // http://vimeo.com/videoschool
        // http://vimeo.com/videoschool/archive/behind_the_scenes
        // http://vimeo.com/forums/screening_room
        // http://vimeo.com/forums/screening_room/topic:42708


        class VimeoVideo extends HTMLVideo {
          constructor(node, options) {
            super(node, options);
            this.type = 'vimeo';
            this.apiPlayer = null;
            this.videoWrapper.attr('data-video-type', this.type);
          }

          createPlayer(player) {
            this.apiPlayer = player;
            return new Promise((resolve, reject) => {
              this.videoNode.attr('data-vimeo-id', helper.videoModule.getId(this._node));

              if (player.Player) {
                const tmp = this.videoNode.attr('data-src');

                if (tmp) {
                  this.videoNode.attr('src', tmp);
                }

                const opt = {
                  id: helper.videoModule.getId(this._node),
                  loop: this.option('loop'),
                  controls: this.option('controls.enable'),
                  speed: this.option('controls.speed')
                };
                this.player = {
                  ready: false,
                  play: () => {
                    this.player.player.setVolume(0);
                    this.player.player.play();
                  },
                  pause: () => {
                    this.player.player.pause();
                  },
                  player: new player.Player(this.videoNode.node, opt)
                };
                this.addEvents(resolve);
              } else {
                reject(true);
              }
            });
          }

          destroyVideoPlayer() {
            if (this.player && this.player.player) {
              this.player.ready = false;
              this.player.player.destroy();
            }
          }

          play() {
            if (this.player && this.player.ready) {
              this.setCurrentTime();
              this.player.play();
            }
          }

          onBeforeFullscreenIn() {
            this.destroyVideoPlayer();
          }

          onAfterFullscreenIn() {
            this.createPlayer(this.apiPlayer);
          }

          onBeforeFullscreenOut() {
            this.destroyVideoPlayer();
          }

          onAfterFullscreenOut() {
            this.createPlayer(this.apiPlayer);
          }

          getCurrentTime() {}

          setCurrentTime() {
            if (this.player && this.player.ready) {
              this.player.player.setCurrentTime(this.currentTime);
            }
          }

          addEvents(callback) {
            this.player.player.on('play', () => {
              this.state = globalVariables.VIDEO.PLAY;
              this.emit('slideVideoPlay', {
                data: {
                  type: this.type
                }
              });
            });
            this.player.player.on('pause', () => {
              this.state = globalVariables.VIDEO.PAUSE;
              this.emit('slideVideoPause', {
                data: {
                  type: this.type
                }
              });
            });
            this.player.player.on('ended', () => {
              this.state = globalVariables.VIDEO.PAUSE;
              this.emit('slideVideoEnd', {
                data: {
                  type: this.type
                }
              });
            });
            this.player.player.on('loaded', () => {// empty
            });
            this.player.player.on('timeupdate', data => {
              this.currentTime = data.seconds;
            }); // vimeo api bug
            // If we use the ready event before then we add listerners of vimeo events then events do not work

            if (this.player.player) {
              this.player.player.ready().then(() => {
                this.player.ready = true;

                if (this.state === globalVariables.VIDEO.PLAY) {
                  this.state = globalVariables.VIDEO.PAUSE;
                }

                this.player.player.setVolume(0); // this.player.player.setVolume(this.option('volume') / 100);

                this.emit('slideVideoReady', {
                  data: {
                    type: this.type,
                    error: null
                  }
                });
                callback();
              });
            } else {
              this.emit('slideVideoReady', {
                data: {
                  type: this.type,
                  error: new Error('Player does not exist.')
                }
              });
            }
          }

          destroy() {
            super.destroy();
            this.videoNode.remove();
            this.videoNode = null;
            this.videoWrapper.remove();
            this.videoWrapper = null;

            if (this.player && this.player.player) {
              this.player.player.destroy();
              this.player.player = null;
            }

            this._node = null;
          }

        }

        return {
          HTMLVideo: HTMLVideo,
          YouTubeVideo: YouTubeVideo,
          VimeoVideo: VimeoVideo
        };
      })();
      /* eslint-env es6 */

      /* global helper */

      /* global $, $J, EventEmitter, SocialButtons */

      /* global ComponentLoader, ResponsiveImage */

      /* eslint-disable no-lonely-if */

      /* global SirvService, CSS_MAIN_CLASS, SELECTOR_TAG, SELECTOR_CLASS, slideVideo */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Slide" }] */


      const Slide = (() => {
        const CAN_ZOOM_CLASS = CSS_MAIN_CLASS + '-can-zoom';
        /**
         * because that css can take much time for loading
         * and we can get wrong sizes
         */

        const NECESSARY_CSS = {
          top: 0,
          left: 0,
          width: '100%',
          height: '100%'
        };

        const getContentSize = (node, count) => {
          return new Promise(resolve => {
            node = $(node);

            if (count === undefined) {
              count = 10;
            }

            if (count > 0) {
              const size = node.size;

              if (!size.width || !size.height) {
                setTimeout(() => {
                  count -= 1;
                  getContentSize(node, count).then(resolve);
                }, 32);
              } else {
                resolve(size);
              }
            } else {
              resolve(null);
            }
          });
        };

        const findSomethingForSelector = node => {
          const result = {
            type: 'node',
            data: null
          };

          if (helper.videoModule.isVideo(node)) {
            result.type = helper.videoModule.getType(node);

            if (!result.type) {
              result.data = $J.$new('div');
            }
          } else {
            let tmp;
            let src;

            if ($(node).tagName === 'img') {
              tmp = node;
            } else {
              try {
                tmp = node.getElementsByTagName('img')[0];
              } catch (e) {// empty
              }
            }

            if (tmp) {
              src = helper.sliderLib.getSrc($(tmp).attr('src')) || helper.sliderLib.getSrc($(tmp).attr('data-src'));
            }

            if (src) {
              result.type = 'img';
              result.data = src;
            } else {
              if (node.cloneNode) {
                tmp = node.cloneNode(true);
              } else {
                tmp = $J.$new('div');
              }

              result.data = tmp;
            }
          }

          return result;
        };

        const getCustomSelectorNode = node => {
          let result = $(node.node.querySelector(SELECTOR_TAG));

          if (!result) {
            if (node.tagName === SELECTOR_TAG) {
              result = node;
            } else {
              result = null;
            }
          }

          return result;
        };

        class Slide_ extends EventEmitter {
          constructor(node, index, options, isCustomAdded) {
            super();
            this.$J_UUID = $J.$uuid(this);
            this.groups = ($(node).attr('data-group') || '').split(/\s*(?:,|$)\s*/);
            const slideData = Slide.parse(node);
            this.id = slideData.id; // data-id attr

            this._enabled = slideData.enabled;
            this.type = slideData.type;
            this.url = slideData.url;
            this.slideContent = $(node);
            this._index = index;
            this.isCustomAdded = isCustomAdded || false;
            this._options = {};
            this.options = options;
            this.instanceNode = $J.$new('div').addClass(CSS_MAIN_CLASS + '-slide').setCss({
              position: 'absolute'
            });
            this.instanceNode.setCss(NECESSARY_CSS);
            this.contentWrapper = $J.$new('div').addClass(CSS_MAIN_CLASS + '-content');
            this.contentWrapper.setCss(NECESSARY_CSS);
            this.fullscreenOnlyNode = null;
            this.selector = {
              UUID: this.$J_UUID,
              isCustom: false,
              node: getCustomSelectorNode(this.slideContent),
              isSirv: false,
              isVideo: false,
              selectorContent: null,
              size: {
                width: 0,
                height: 0
              },
              src: null,
              srcset: null,
              pinned: null,
              activated: true,
              infoPromise: null,
              isStatic: false
            };
            this.selector.isStatic = Slide_.checkNonSirv(this.selector.node);
            this.selector.pinned = Slide_.findPinnedSelectorSide(this.slideContent.node.querySelector(SELECTOR_TAG) || this.slideContent.node);
            this.selector.isCustom = !!this.selector.node;
            this.thumbnailReferrerPolicy = this.getSelectorReferrerPolicy();
            this.availableSlide = true;
            this.isStartedFullInit = false;
            this.fullscreenState = globalVariables.FULLSCREEN.CLOSED;
            this.isStarted = false;
            this.sirvService = null;
            this.componentSize = null;
            this.inView = false;
            this.isActive = false;
            this.isReady = false;
            this.video = null;
            this.isVideoPaused = false;
            this.isVideoReady = false;
            this.slideShownBy = globalVariables.SLIDE_SHOWN_BY.NONE;
            this.componentLoader = null;
            this.infoSize = null;
            this.sizePromise = null;
            this.isInDom = 0; // 0 / 1

            this.multiImages = [];
            this.lastOriginNode = null;
            this.dataThumbnailImage = this.getThumbnailImage();
            this.dataThumbnailHtml = this.slideContent.attr('data-thumbnail-html');
            this.dataHiddenSelector = this.slideContent.hasAttribute('data-hidden-selector'); // Disables switching slides by swipe on touchscreen.

            this.swipeDisabled = this.slideContent.hasAttribute('data-swipe-disabled');
            this.spinWasInited = false;
            this.socialbuttons = null;
            this.getVideoThumbnailPromise = null;
            this.isPlaceholder = false;
            this.customThumbnailImageClassPromise = null;
            const this_ = this;
            this._api = {
              get index() {
                return this_.index;
              },

              get component() {
                if (this_.sirvService) {
                  return globalVariables.SLIDE.NAMES[this_.sirvService.type];
                }

                return 'unknown';
              },

              get groups() {
                return this_.groups;
              },

              get thumbnail() {
                return this_.selector.node?.node ?? null;
              },

              isDisabled() {
                return !this_.enabled;
              },

              isActive() {
                return this_.isActive;
              },

              getSelector() {
                return this.thumbnail;
              } // for backward compatibility


            };

            this.sendEventCloseFullscreenByClick = e => {
              e.stop();
              this.emit('goToFullscreenOut');
            };

            this.beforeParseSlide();
            this.parseSlide();
          }

          static findPinnedSelectorSide(node) {
            if (node.hasAttribute('data-pinned')) {
              const attrValue = $J.$(node).attr('data-pinned');
              return attrValue !== 'start' ? 'end' : attrValue;
            }

            return null;
          }

          static parse(node) {
            node = $(node); // const result = { node: node.node };

            const result = {};
            result.node = node.node;
            result.id = node.attr('data-id');
            let url = null;
            let type = globalVariables.SLIDE.TYPES.HTML;
            let enabled = true;
            /*
                spin, zoom, image, video, html
            */

            if (Slide.isSirvComponent(node)) {
              const tmp = helper.getSirvType(node);
              type = tmp.type;
              url = tmp.imgSrc;
            } else if (helper.videoModule.isVideo(node)) {
              type = globalVariables.SLIDE.TYPES.VIDEO;
              url = helper.videoModule.getSrc(node);
            } else if (node.tagName === 'img' || node.tagName === 'div' && node.attr('data-src')) {
              type = globalVariables.SLIDE.TYPES.IMAGE;
              url = node.attr('data-src') || node.attr('src');
            }

            result.type = type;
            result.url = url;
            const slideIsDisabled = node.node.getAttribute('data-disabled'); // don't use .attr() method

            if (slideIsDisabled && slideIsDisabled !== 'false' || slideIsDisabled === '') {
              enabled = false;
            }

            result.enabled = enabled;
            return result;
          }

          static checkNonSirv(node) {
            if (node && $(node).attr('data-type') === 'static') {
              return true;
            }

            return false;
          }

          static isSirvComponent(node) {
            node = $(node); // const dataEffect = node.attr('data-type') || node.attr('data-effect');

            const dataSrc = node.attr('data-src');
            const src = node.attr('src');
            const nonSirv = Slide.checkNonSirv(node);
            const tagName = node.tagName;
            const viewContent = node.fetch('view-content');

            if (!nonSirv && ( // (tagName === 'div' && !['youtube', 'vimeo'].includes(helper.videoModule.getType(dataSrc)) && (dataEffect === 'zoom' || helper.isSpin(dataSrc) || helper.isVideo(dataSrc))) ||
            viewContent || tagName === 'div' && !['youtube', 'vimeo'].includes(helper.videoModule.getType(dataSrc)) && dataSrc || tagName === 'img' && (dataSrc || src))) {
              return true;
            }

            return false;
          }

          static hasComponent(node) {
            return SirvService.isExist(node);
          }

          isSwipeDisabled() {
            return this.swipeDisabled;
          }

          getThumbnailImage() {
            let result = this.slideContent.attr('data-thumbnail-image');

            if (!result && this.selector.isCustom) {
              result = this.selector.node.attr('data-src');

              if (!result) {
                const children = this.selector.node.node.children;

                if (children.length === 1 && $(children[0]).tagName === 'img') {
                  result = $(children[0]).attr('data-src') || $(children[0]).attr('src');
                }
              }
            }

            return result;
          }

          startGettingInfo() {
            if (this.sirv) {
              this.sirvService.startGettingInfo();
            }
          }

          loadContent() {
            if (this.sirv) {
              this.getSlideSize().then(infoSize => {
                if (this.isInDom) {
                  this.sirvService.loadContent();
                }
              }).catch(err => {});
            }
          }

          loadThumbnail() {
            if (this.sirv) {
              this.getSlideSize().then(infoSize => {
                if (this.isInDom) {
                  this.sirvService.loadThumbnail();
                }
              }).catch(err => {});
            }
          }

          get videoSlide() {
            let result = false;

            if (this.sirv) {
              result = this.sirvService.type === globalVariables.SLIDE.TYPES.VIDEO;
            } else if (this.video) {
              result = true;
            }

            return result;
          }

          belongsTo(group) {
            let result = false;

            if (group) {
              if ($J.typeOf(group) === 'string') {
                group = [group];
              }

              result = group.some(g => this.groups.includes(g));
            }

            return result;
          }

          addGroup(newGroup) {
            let result = false;

            if (newGroup && $J.typeOf(newGroup) === 'string' && !this.groups.includes(newGroup)) {
              result = true;
              this.groups.push(newGroup);
            }

            return result;
          }

          removeGroup(group) {
            let result = false;

            if (group && $J.typeOf(group) === 'string') {
              const index = this.groups.indexOf(group);

              if (index > -1) {
                result = true;
                this.groups.splice(index, 1);
              }
            }

            return result;
          }

          get customSelector() {
            return this.selector.isCustom;
          }

          single(isSingle) {
            if (this.sirv) {
              this.broadcast('isSingleSlide', {
                data: {
                  isSingle: isSingle
                }
              });
            }
          }
          /**
           * @param {number} index
           */


          set newIndex(index) {
            this._index = index;
          }

          get index() {
            return this._index;
          }

          checkReadiness(eventName, component) {
            let result = false;

            if (this.sirv && globalVariables.SLIDE.NAMES[this.sirvService.type] === component) {
              if (eventName === 'init') {
                result = this.spinWasInited;
              } else {
                result = this.isReady;
              }
            }

            return result;
          }

          sendReadyEvent(eventName, component) {
            if (this.sirv && globalVariables.SLIDE.NAMES[this.sirvService.type] === component) {
              this.sirvService.sendEvent(eventName);
            }
          }

          createFullscreenOnlyScreen() {
            if (this._options.fullscreenOnly) {
              this.fullscreenOnlyNode = $J.$new('div').addClass(CSS_MAIN_CLASS + '-fullscreen-always'); // this.fullscreenOnlyNode.addEvent(['mousedown', 'touchstart'], (e) => {

              this.fullscreenOnlyNode.addEvent(['btnclick', 'tap'], e => {
                e.stop();
                this.emit('goToFullscreen');
              });
              this.createPinchEvent(this.fullscreenOnlyNode);
              this.instanceNode.append(this.fullscreenOnlyNode, 'top');
            }
          }

          createPinchEvent(node) {
            if ($J.browser.touchScreen) {
              // difference between scale
              const FS_IN = 2;
              node.addEvent('pinch', e => {
                e.stop();

                switch (e.state) {
                  case 'pinchend':
                    if (this.fullscreenState === 0 && e.scale >= FS_IN) {
                      this.emit('goToFullscreen');
                    }

                    break;

                  default:
                }
              });
            }
          }

          get enabled() {
            return this._enabled;
          }

          disable() {
            this._enabled = false;

            if (this.video) {
              this.video.pause();
            }

            if (this.componentLoader) {
              this.componentLoader.hide(true);
            }
          }

          enable() {
            this._enabled = true;
          }

          get blokedTouchdrag() {
            let result = false;

            if (this.sirv) {
              if (this.sirvService.type === globalVariables.SLIDE.TYPES.SPIN) {
                result = true;
              } else {
                result = this.sirvService.isEffectActive();
              }
            }

            return result;
          }

          set options(options) {
            this._options = Object.assign({
              spin: {},
              zoom: {},
              image: {},
              video: {},
              fullscreenOnly: false
            }, options || {});
          }

          dragEvent(type) {
            if (this.sirvService) {
              this.broadcast('dragEvent', {
                data: {
                  type: type
                }
              });
            }
          }

          startFullInit(options) {
            if (this.isStartedFullInit) {
              return;
            }

            this.isStartedFullInit = true;

            if (options) {
              this.options = options;
            }

            if (this.sirvService) {
              this.sirvService.startFullInit(options ? this._options : null);
            }

            this.hide();
            this.instanceNode.append(this.contentWrapper);

            if (!this.sirv) {
              this.appendToDOM();
            }
          }

          createComponentLoader() {
            if (!this.componentLoader) {
              this.componentLoader = new ComponentLoader(this.instanceNode);
              this.componentLoader.show();
            }
          }

          get slideAvailable() {
            return this.availableSlide;
          }

          get selectorPinned() {
            return ['start', 'end'].includes(this.selector.pinned);
          }

          get pinnedSelectorSide() {
            return this.selector.pinned;
          }

          setFullscreenEvents() {
            this.on('beforeFullscreenIn', e => {
              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENING) {
                e.stopPropagation();
              } else {
                this.fullscreenState = globalVariables.FULLSCREEN.OPENING;

                if (this.video) {
                  this.isVideoPaused = this.video.paused;
                  this.video.onBeforeFullscreenIn();
                }
              }

              if (this.fullscreenOnlyNode) {
                this.fullscreenOnlyNode.setCssProp('display', 'none');
              }

              this.addEventCloseFullscreenByClick();
            });
            this.on('afterFullscreenIn', e => {
              if (this.socialbuttons) {
                this.socialbuttons.closeButtons();
              }

              if (this.fullscreenState === globalVariables.FULLSCREEN.OPENED) {
                e.stopPropagation();
              } else {
                this.fullscreenState = globalVariables.FULLSCREEN.OPENED;

                if (this.sirv && this.componentLoader.isHiding()) {
                  this.componentLoader.hide(true);
                }

                if (this.video) {
                  this.video.onAfterFullscreenIn();

                  if (this.video.autoplay || !this.video.preStart) {
                    this.playVideo();
                  }
                }
              }
            });
            this.on('beforeFullscreenOut', e => {
              if (this.socialbuttons) {
                this.socialbuttons.closeButtons();
              }

              if (this.fullscreenState === globalVariables.FULLSCREEN.CLOSING) {
                e.stopPropagation();
              } else {
                this.fullscreenState = globalVariables.FULLSCREEN.CLOSING;

                if (this.video) {
                  this.isVideoPaused = this.video.paused;
                  this.video.onBeforeFullscreenOut();
                }
              }

              if (this.fullscreenOnlyNode) {
                this.fullscreenOnlyNode.setCssProp('display', '');
              }
            });
            this.on('afterFullscreenOut', e => {
              if (this.fullscreenState === globalVariables.FULLSCREEN.CLOSED) {
                e.stopPropagation();
              } else {
                this.fullscreenState = globalVariables.FULLSCREEN.CLOSED;

                if (this.video) {
                  this.video.onAfterFullscreenOut();

                  if (this.video.autoplay || !this.video.preStart) {
                    this.playVideo();
                  }
                }
              }

              this.removeEventCloseFullscreeByClick();
            });
            this.on('inView', e => {
              this.inView = e.data;

              if (this.video) {
                if (this.inView) {
                  if (!this.isVideoPaused && !this.video.preStart || this.video.autoplay) {
                    this.playVideo();
                  }
                } else {
                  this.isVideoPaused = this.video.paused;
                  this.video.getCurrentTime();
                  this.video.pause();
                }
              }
            });
          }

          addEventCloseFullscreenByClick() {
            if (this._options.fullscreenOnly && this.type === globalVariables.SLIDE.TYPES.IMAGE) {
              this.contentWrapper.addEvent(['btnclick', 'tap'], this.sendEventCloseFullscreenByClick);
              this.slideContent.addEvent(['btnclick', 'tap'], this.sendEventCloseFullscreenByClick);
            }
          }

          removeEventCloseFullscreeByClick() {
            if (this._options.fullscreenOnly && this.type === globalVariables.SLIDE.TYPES.IMAGE) {
              this.contentWrapper.removeEvent(['btnclick', 'tap'], this.sendEventCloseFullscreenByClick);
              this.slideContent.removeEvent(['btnclick', 'tap'], this.sendEventCloseFullscreenByClick);
            }
          }

          get sirv() {
            return !!this.sirvService;
          }

          get node() {
            return this.instanceNode;
          }

          get originNode() {
            return this.lastOriginNode || this.slideContent;
          }

          get originImageUrl() {
            if (this.sirv) {
              return this.sirvService.originImageUrl;
            }

            return null;
          }

          zoomIn(x, y) {
            this.broadcast('zoomUp', {
              data: {
                x: x,
                y: y
              }
            });
          }

          zoomOut(x, y) {
            this.broadcast('zoomDown', {
              data: {
                x: x,
                y: y
              }
            });
          }

          mouseAction(type, originEvent) {
            if (this.sirv) {
              this.broadcast('mouseAction', {
                data: {
                  type: type,
                  originEvent: originEvent
                }
              });
            }
          }

          get zoomData() {
            if (this.sirv) {
              return this.sirvService.getZoomData();
            }

            return null;
          }

          get typeOfSlide() {
            let result = null;

            if (this.sirv) {
              result = this.sirvService.type;
            }

            return result;
          }

          get options() {
            return this.sirv ? this.sirvService.getToolOptions() : {};
          }

          createSlideApi() {
            if (this.sirv && !this.isStarted) {
              this.isStarted = true;
              this.api[globalVariables.SLIDE.NAMES[this.sirvService.type]] = this.sirvService.getData();
            }
          }

          beforeShow() {
            this.isActive = true;
            this.show();

            if (this.sirv) {
              this.sirvService.activate();
            }

            this.createSlideApi();
          }

          afterShow(whoUse) {
            this.slideShownBy = whoUse || globalVariables.SLIDE_SHOWN_BY.NONE;
            this.broadcast('startActions', {
              who: this.slideShownBy
            });

            if (this.video && this.video.autoplay) {
              this.playVideo();
            }
          }

          beforeHide() {
            if (this.video) {
              this.video.pause();
            } else {
              this.broadcast('stopActions');
            }
          }

          afterHide() {
            this.slideShownBy = globalVariables.SLIDE_SHOWN_BY.NONE;
            this.isActive = false;
            this.hide();

            if (this.sirv) {
              this.sirvService.deactivate();
            }

            if (this.socialbuttons) {
              this.socialbuttons.closeButtons();
            }
          }

          show() {
            this.instanceNode.removeClass(CSS_MAIN_CLASS + '-hidden');
            this.instanceNode.addClass(CSS_MAIN_CLASS + '-shown');
          }

          hide() {
            this.instanceNode.removeClass(CSS_MAIN_CLASS + '-shown');
            this.instanceNode.addClass(CSS_MAIN_CLASS + '-hidden');
          }

          get zoomSizeExist() {
            if (this.sirv) {
              return this.sirvService.isZoomSizeExist();
            }

            return false;
          }

          startTool(isShown, preload, firstSlideAhead) {
            if (this.sirv) {
              this.getSlideSize().then(infoSize => {
                if (this.isInDom && this.sirvService) {
                  this.sirvService.startTool(isShown || this.isActive, preload, firstSlideAhead);
                  this.addSocialButtons();
                } else {
                  this.emit('contentLoaded', {
                    data: {
                      slide: {
                        index: this._index
                      }
                    }
                  });
                }
              }).catch(err => {});
            } else {
              this.getSlideSize().then(() => {
                this.emit('contentLoaded', {
                  data: {
                    slide: {
                      index: this._index
                    }
                  }
                });
              });
            }
          }

          getSlideSize() {
            if (!this.sizePromise) {
              this.sizePromise = new Promise((resolve, reject) => {
                if (this.sirv) {
                  const result = {
                    UUID: this.$J_UUID
                  };
                  this.sirvService.getInfoSize().then(infoSize => {
                    if (!this.infoSize && infoSize.size) {
                      this.infoSize = infoSize.size;
                    }

                    result.size = this.infoSize;
                    resolve(result);
                  }).catch(err => {
                    result.error = true;

                    if (this.sirvService) {
                      const typeOfSirvService = this.sirvService.type;
                      this.removeSirvService();

                      if (err && err.error && err.error.status && err.error.status === 404) {
                        result.error = err.error;
                        reject(result);
                      } else if (err && (err.error === 'changeSpinToImage' || typeOfSirvService === globalVariables.SLIDE.TYPES.IMAGE || err.isPlaceholder)) {
                        this.isPlaceholder = err.isPlaceholder;

                        if (typeOfSirvService === globalVariables.SLIDE.TYPES.IMAGE) {
                          this.isInDom = 0;
                          this.appendToDOM();
                          const data = findSomethingForSelector(this.slideContent.node);

                          if (!this.selector.isCustom) {
                            this.selector.src = data ? data.data : null;
                            this.selector.isSirv = false;
                          }
                        } else {
                          this.changeSpinToImage();
                        } // финт ушами


                        const oldPromise = this.sizePromise;
                        this.sizePromise = null;
                        const newPromise = this.getSlideSize();
                        this.sizePromise = oldPromise;
                        newPromise.then(resolve).catch(reject);
                      } else {
                        result.error = {
                          status: 404
                        };
                        reject(result);
                      }
                    } else {
                      result.error = {
                        status: 404
                      };
                      reject(result);
                    }
                  }).finally(() => {
                    if (this.isCustomAdded) {
                      this.emit('infoReady', {
                        data: {
                          index: this._index
                        }
                      });
                    }
                  });
                } else {
                  let img;
                  let src;

                  if (this.slideContent.tagName === 'img') {
                    img = this.slideContent.node;
                  } else {
                    try {
                      img = this.slideContent.node.getElementsByTagName('img')[0];
                    } catch (e) {// empty
                    }
                  }

                  if (img) {
                    src = helper.sliderLib.getSrc($(img).attr('src'));

                    if (!src) {
                      src = helper.sliderLib.getSrc($(img).attr('data-src'));
                    } // } else {
                    //     src = helper.sliderLib.getSrc($(img).attr('data-src'));

                  }

                  if (src) {
                    helper.loadImage(src).then(imageData => {
                      this.infoSize = imageData.size;
                      resolve({
                        size: this.infoSize,
                        UUID: this.$J_UUID
                      });
                    }).catch(error => {
                      resolve({
                        size: this.infoSize,
                        UUID: this.$J_UUID,
                        error: {
                          status: 404
                        }
                      });
                    });
                  } else {
                    if (this.video) {
                      this.video.getSize().then(size => {
                        this.infoSize = size || {
                          width: 0,
                          height: 0
                        };
                        resolve({
                          size: this.infoSize,
                          UUID: this.$J_UUID
                        });
                      }).catch(err => {
                        reject({
                          size: this.infoSize,
                          UUID: this.$J_UUID,
                          error: err
                        });
                      });
                    } else {
                      getContentSize(this.slideContent.node).then(size => {
                        this.infoSize = size || {
                          width: 0,
                          height: 0
                        };
                        resolve({
                          size: this.infoSize,
                          UUID: this.$J_UUID
                        });
                      }).catch(err => {
                        reject({
                          size: this.infoSize,
                          UUID: this.$J_UUID,
                          error: err
                        });
                      });
                    }
                  }
                }
              });
            }

            return this.sizePromise;
          }

          get api() {
            return this._api;
          }

          removeSirvService() {
            this.infoSize = null;

            if (this.slideContent) {
              this.slideContent.remove();
            }

            if (this.selector.node) {
              this.selector.node.removeAttr('data-type');
            }

            if (this.sirvService) {
              this.sirvService.destroy();
              this.sirvService = null;
            }

            this.selector.isSirv = false;
            this.off('stats');
            this.off('componentEvent');
            this.off('beforeFullscreenIn');
            this.off('afterFullscreenIn');
            this.off('beforeFullscreenOut');
            this.off('afterFullscreenOut');

            if (this.componentLoader) {
              this.componentLoader.hide(true);
              this.componentLoader.destroy();
              this.componentLoader = null;
            }

            if (this.fullscreenOnlyNode) {
              this.fullscreenOnlyNode.kill();
              this.fullscreenOnlyNode = null;
            }
          }

          changeSpinToImage() {
            this.slideContent.removeClass(CSS_MAIN_CLASS + '-component');
            this.contentWrapper.removeClass(CSS_MAIN_CLASS + '-content-' + globalVariables.SLIDE.NAMES[this.typeOfSlide]);
            this.lastOriginNode = this.slideContent;
            this.slideContent = $J.$new('img', {
              'data-src': this.slideContent.attr('data-src')
            });
            this.slideContent.addClass(CSS_MAIN_CLASS + '-component');
            this.parseSlide();
            this.isInDom = 0;
            this.appendToDOM();

            if (this.isPlaceholder) {
              const data = findSomethingForSelector(this.slideContent);

              if (!this.selector.isCustom) {
                this.selector.src = data ? data.data : null;
              }
            }

            if (this.selector.node && !this.selector.isCustom) {
              this.selector.node.attr('data-type', globalVariables.SLIDE.NAMES[this.typeOfSlide]);
            }

            if (this.isStartedFullInit) {
              this.isStartedFullInit = false;
              this.startFullInit();
            }
          }

          setSirvEvents() {
            this.on('stats', e => {
              e.stopEmptyEvent();
              e.data.index = this._index;
            }); // init, ready, zoomIn, zoomOut

            this.on('componentEvent', e => {
              e.stopEmptyEvent();
              const eventData = e.data.data;
              eventData.type = e.data.type;
              eventData.node = this.slideContent;

              if (e.data.type === 'ready') {
                this.isReady = true;
              }

              e.data.slide = this.api;
              e.data.componentEventData = eventData;

              if (e.data.component === globalVariables.SLIDE.NAMES[globalVariables.SLIDE.TYPES.SPIN]) {
                if (e.data.type === 'init') {
                  this.componentLoader.hide();
                  this.spinWasInited = true;
                  const spinTypeClassMap = {
                    row: 'spin-x',
                    col: 'spin-y',
                    'multi-row': 'spin-xy'
                  };

                  if (this.selector.node) {
                    this.selector.node.addClass(spinTypeClassMap[this.sirvService.getSpinOrientation()] || '');
                  }
                }
              } else {
                if (e.data.type === 'ready') {
                  this.componentLoader.hide();
                }
              }

              if (e.data.type === 'ready' && ['spin', 'zoom'].includes(e.data.component)) {
                if (this.sirvService.isZoomSizeExist()) {
                  this.contentWrapper.addClass(CAN_ZOOM_CLASS);
                }
              }
            });
          }

          addSocialButtons() {
            if (this.validateComponentSocialButton()) {
              const arr = ['facebook', 'twitter', 'linkedin', 'reddit', 'tumblr', 'pinterest', 'telegram'];
              const sTypes = {};
              arr.forEach(value => {
                sTypes[value] = this._options['sb' + $J.camelize('-' + value)];
              });
              const dataImageSB = SocialButtons.getDataImage();
              const links = {};
              arr.forEach(value => {
                links[value] = this.getLinkSocialButton(dataImageSB[value], sTypes[value]);
              });
              this.socialbuttons = new SocialButtons({
                'text': this.slideContent.attr('alt'),
                'link': links,
                'title': this.slideContent.attr('title')
              }, sTypes, this.instanceNode);
            }
          }

          validateComponentSocialButton() {
            if (this._options.sbEnable && SocialButtons && !this.socialbuttons) {
              if (this.sirv && this.sirvService.type !== globalVariables.SLIDE.TYPES.VIDEO || this.video && this.video.type !== 'video' || this.slideContent.tagName === 'img') {
                return true;
              }
            }

            return false;
          }

          getLinkSocialButton(data, isSpin, enable) {
            let result = null;

            if (enable) {
              if (this.sirv) {
                result = this.sirvService.getSocialButtonData(data, this.api.component === globalVariables.SLIDE.NAMES[globalVariables.SLIDE.TYPES.SPIN]);
              } else if (this.slideContent.tagName === 'iframe') {
                result = this.video.node.attr('data-src');
              } else {
                result = this.slideContent.attr('data-src');
              }
            }

            return result;
          }

          searchImagesInHtmlContent() {
            let result = false;
            const images = Array.from(this.slideContent.node.querySelectorAll('img'));

            if (images.length) {
              result = true;
              this.multiImages = images;
              images.forEach((img, index) => {
                const isSirvImage = !Slide.checkNonSirv(img);

                if (isSirvImage) {
                  if (!this.sirvService) {
                    this.setSirvEvents();
                    this.selector.isSirv = true;
                    this.sirvService = new SirvService(img, this._options, {
                      quality: this._options.quality,
                      hdQuality: this._options.hdQuality,
                      isHDQualitySet: this._options.isHDQualitySet,
                      always: this._options.fullscreenOnly,
                      isFullscreen: this._options.isFullscreen,
                      nativeFullscreen: this._options.nativeFullscreen
                    });
                    this.sirvService.parentClass = this;
                    this.sirvService.start();
                    this.createSlideApi();
                  } else {
                    this.sirvService.push(img);
                  }
                }

                this.multiImages.push({
                  isSirv: isSirvImage,
                  node: img,
                  src: $(img).attr('src'),
                  datasrc: $(img).attr('data-src')
                });
              });
            }

            return result;
          }

          isCustomSlideEmpty() {
            if (this.customSelector) {
              const smvSelector = this.slideContent.node.querySelector(SELECTOR_TAG);

              if (smvSelector) {
                $J.$(smvSelector).remove();
                const length = Array.from(this.slideContent.node.children).length;
                this.slideContent.append(smvSelector);

                if (Slide.isSirvComponent(this.slideContent) && Slide.hasComponent(this.slideContent) && !this.isPlaceholder || length || helper.videoModule.isVideo(this.slideContent)) {
                  return false;
                }
              }
            }

            return true;
          }

          beforeParseSlide() {
            if (this.customSelector) {
              if (this.isCustomSlideEmpty()) {
                this.availableSlide = false;
                this.selector.activated = false;
              }

              this.selector.node.remove();
            }
          }

          createImgFromDiv() {
            if (this.slideContent.tagName === 'div' && this.type === globalVariables.SLIDE.TYPES.IMAGE) {
              const old = this.slideContent;
              this.slideContent = $J.$new('img');
              this.slideContent.attr('data-src', this.url);
              let tmp = old.attr('alt');

              if (tmp) {
                this.slideContent.attr('alt', tmp);
              }

              tmp = old.attr('title');

              if (tmp) {
                this.slideContent.attr('title', tmp);
              }

              tmp = old.attr('data-alt');

              if (tmp) {
                this.slideContent.attr('data-alt', tmp);
              }

              tmp = old.attr('data-referrerpolicy');

              if (tmp) {
                this.slideContent.attr('data-referrerpolicy', tmp);
              }
            }
          }

          parseSlide() {
            if (Slide.isSirvComponent(this.slideContent) && Slide.hasComponent(this.slideContent) && !this.isPlaceholder) {
              this.setSirvEvents();
              this.createImgFromDiv();
              this.sirvService = new SirvService(this.slideContent.node, this._options, {
                quality: this._options.quality,
                hdQuality: this._options.hdQuality,
                isHDQualitySet: this._options.isHDQualitySet,
                always: this._options.fullscreenOnly,
                isFullscreen: this._options.isFullscreen,
                nativeFullscreen: this._options.nativeFullscreen
              });
              this.sirvService.parentClass = this;
              this.selector.isSirv = true;
              this.sirvService.start();
              this.createSlideApi();
              this.selector.isVideo = this.sirvService.type === globalVariables.SLIDE.TYPES.VIDEO;
              this.contentWrapper.addClass(CSS_MAIN_CLASS + '-content-' + globalVariables.SLIDE.NAMES[this.typeOfSlide]);
            } else {
              this.createImgFromDiv();
              this.searchImagesInHtmlContent();

              if (helper.videoModule.isVideo(this.slideContent)) {
                this.selector.isVideo = true;
                this.initVideo();
                this.contentWrapper.addClass(CSS_MAIN_CLASS + '-content-video');
              }
            }

            if (this.dataThumbnailImage || this.dataThumbnailHtml) {
              this.selector.isSirv = false;
            }
          }

          appendToDOM() {
            if (!this.isInDom) {
              this.isInDom = 1;
              this.createFullscreenOnlyScreen();

              if (this.sirv || this.video) {
                this.createComponentLoader();

                if (this.video) {
                  this.contentWrapper.append(this.video.node);
                } else {
                  this.contentWrapper.append(this.slideContent);
                }
              } else {
                if (this.slideContent.tagName === 'img') {
                  this.contentWrapper.addClass(CSS_MAIN_CLASS + '-slide-img');

                  if (!helper.sliderLib.getSrc(this.slideContent.attr('src'))) {
                    this.slideContent.attr('src', this.slideContent.attr('data-src'));
                  }
                }

                if (this.multiImages.length) {
                  this.multiImages.forEach(img => {
                    if (!img.src && img.datasrc) {
                      $(img.node).attr('src', img.datasrc);
                    }
                  });
                }

                this.contentWrapper.append(this.slideContent);
              }

              this.setFullscreenEvents();
            }
          }

          initVideoPlayer() {
            if (this.video) {
              this.video.init();
            } else if (this.sirv && this.sirvService.type === globalVariables.SLIDE.TYPES.VIDEO) {
              this.sirvService.loadVideoSources();
            }
          }

          secondSelectorClick() {
            if (this.sirv) {
              this.broadcast('secondSelectorClick', {
                data: {
                  slideIndex: this._index
                }
              });
            } else {
              if (this.video) {
                this.video.pause();
              }
            }
          }

          isSirvSelector() {
            if (!this.selector.isCustom) {
              return this.sirv && this.sirvService.type !== globalVariables.SLIDE.TYPES.VIDEO;
            }

            return false;
          }

          getSelectorProportion() {
            let result;

            if (this.dataThumbnailImage) {
              result = new Promise((resolve, reject) => {
                this.getResponsiveImage().then(() => resolve(Object.assign({}, this.selector))).catch(error => {
                  helper.loadImage(this.dataThumbnailImage).then(imageData => {
                    this.selector.size = imageData.size;
                    resolve(Object.assign({}, this.selector));
                  }).catch(error => {
                    reject(error);
                  });
                });
              });
            } else if (this.video) {
              // because proportions of video is not the same as video thumbnail proportions
              result = this.getNonSirvVideoThumbnail();
            } else {
              result = this.getSlideSize();
            }

            return result;
          }

          getSelectorReferrerPolicy() {
            const baseReferrerPolicy = 'no-referrer-when-downgrade';

            if (this.selector.isCustom) {
              if (this.selector.node.hasAttribute('data-referrerpolicy')) {
                return this.selector.node.attr('data-referrerpolicy');
              }

              const listImg = Array.from(this.selector.node.node.children).filter(item => {
                return $(item).tagName === 'img';
              });

              if (listImg.length === 1) {
                return $(listImg[0]).attr('referrerpolicy') || baseReferrerPolicy;
              }
            }

            return this.slideContent.attr('data-referrerpolicy') || this.slideContent.attr('referrerpolicy') || baseReferrerPolicy;
          }

          getResponsiveImage() {
            if (!this.customThumbnailImageClassPromise) {
              this.customThumbnailImageClassPromise = new Promise((resolve, reject) => {
                const image = new ResponsiveImage(this.dataThumbnailImage);
                image.loadInfo().then(info => {
                  this.selector.isSirv = true;
                  this.selector.size = image.originSize;
                  resolve(image);
                }).catch(reject);
              });
            }

            return this.customThumbnailImageClassPromise;
          }

          getSirvThumbnailForCustomSelector(data_) {
            return new Promise((resolve, reject) => {
              this.getResponsiveImage().then(rImageInstance => {
                const data = rImageInstance.getThumbnail(data_);
                data.referrerpolicy = this.thumbnailReferrerPolicy;
                resolve(data);
              }).catch(reject);
            });
          }

          getSelectorImgUrl(type, size, crop, watermark) {
            const data = {
              crop,
              watermark
            };

            if (size.width) {
              data.width = size.width;
            }

            if (size.height) {
              data.height = size.height;
            }

            const extend = _data => {
              if (_data.src) {
                this.selector.src = _data.src;
              }

              if (_data.srcset) {
                this.selector.srcset = _data.srcset;
              }

              let selectorData = Object.assign({}, _data);
              selectorData = Object.assign(selectorData, this.selector);
              return selectorData;
            };

            return new Promise((resolve, reject) => {
              const getNonSirvThumbnail = () => {
                if (this.selector.isCustom && this.dataThumbnailImage) {
                  if (this.selector.isStatic) {
                    resolve(Object.assign({}, this.selector));
                  } else {
                    this.getSirvThumbnailForCustomSelector(data).then(_result => resolve(extend(_result))).catch(() => resolve(Object.assign({}, this.selector)));
                  }
                } else if (this.slideContent.tagName === 'img' || this.multiImages.length) {
                  resolve(Object.assign({}, this.selector));
                } else if (this.video) {
                  this.getNonSirvVideoThumbnail().then(resolve).catch(reject);
                } // if (this.slideContent.tagName === 'img' || this.multiImages.length || this.dataThumbnailImage) {
                //     resolve(Object.assign({}, this.selector));
                // } else if (this.video) {
                //     this.getNonSirvVideoThumbnail().then(resolve).catch(reject);
                // }

              };

              if (this.sirv) {
                this.sirvService.getInfoSize().then(infoSize => {
                  if (this.selector.isCustom) {
                    if (this.selector.isStatic) {
                      resolve(Object.assign({}, this.selector));
                    } else {
                      this.getSirvThumbnailForCustomSelector(data).then(result => resolve(extend(result))).catch(() => resolve(Object.assign({}, this.selector)));
                    }
                  } else {
                    this.sirvService.getSelectorImgUrl(data).then(result => {
                      result.referrerpolicy = this.thumbnailReferrerPolicy;
                      resolve(extend(result));
                    }).catch(reject);
                  }
                }).catch(() => {
                  if (this.selector.isCustom) {
                    getNonSirvThumbnail();
                  } else {
                    reject();
                  }
                });
              } else {
                getNonSirvThumbnail();
              }
            });
          }

          getNonSirvVideoThumbnail() {
            if (!this.getVideoThumbnailPromise) {
              this.getVideoThumbnailPromise = new Promise((resolve, reject) => {
                helper.videoModule.getImageSrc(this.slideContent, true).then(data => {
                  if (!this.selector.isCustom) {
                    this.selector.src = data.thumbnail.url;
                    this.selector.size = {
                      width: data.thumbnail.width,
                      height: data.thumbnail.height
                    };
                  }

                  resolve(Object.assign({}, this.selector));
                }).catch(err => {
                  if (!err || err === true) {
                    err = {
                      UUID: this.$J_UUID
                    };
                  } else {
                    err.UUID = this.$J_UUID;
                  }

                  reject(err);
                });
              });
            }

            return this.getVideoThumbnailPromise;
          }

          get spinInited() {
            return this.spinWasInited;
          }

          get slideReady() {
            return this.isReady;
          }

          get selectorData() {
            if (this.dataHiddenSelector) {
              return null;
            }

            if (!this.selector.node) {
              this.selector.node = $J.$new(SELECTOR_TAG);
              this.selector.node.addClass(SELECTOR_CLASS);
            }

            if (this.dataThumbnailImage) {
              const typeOfSlide = this.typeOfSlide;

              if (typeOfSlide !== null) {
                this.selector.node.attr('data-type', globalVariables.SLIDE.NAMES[typeOfSlide]);
              }

              this.selector.src = this.dataThumbnailImage;

              if (!this.selector.isStatic) {
                this.selector.infoPromise = new Promise(resolve => {
                  this.getResponsiveImage().catch(err => {}).finally(() => {
                    resolve(this.selector.isSirv, this.selector.size);
                  });
                });
              }
            } else if (this.dataThumbnailHtml) {
              const tmp = $J.$new('div');
              tmp.node.innerHTML = this.dataThumbnailHtml;
              this.selector.selectorContent = tmp.node.firstChild;
              this.selector.node.attr('data-type', 'html');
            } else if (this.selector.isCustom) {
              this.selector.node.attr('data-type', 'html');
              this.selector.selectorContent = this.selector.node;
            } else {
              if (this.sirv) {
                const t = this.typeOfSlide;
                this.selector.node.attr('data-type', globalVariables.SLIDE.NAMES[t]);

                if (t === globalVariables.SLIDE.TYPES.SPIN && this.sirvService.isThumbnailGif()) {
                  this.selector.node.addClass('spin-thumbnail-gif');
                }
              } else {
                const data = findSomethingForSelector(this.slideContent.node);

                if (['youtube', 'vimeo', 'video'].includes(data.type)) {
                  this.selector.node.attr('data-type', data.type);
                } else if (data.type === 'img') {
                  this.selector.src = data.data;
                } else {
                  this.selector.selectorContent = data.data;
                  this.selector.node.attr('data-type', 'html');
                }
              }
            }

            if (this.selector.isCustom) {
              this.selector.node.addClass(CSS_MAIN_CLASS + '-custom-thumbnail');
            }

            this.selector.disabled = !this._enabled;
            return this.selector;
          }

          get UUID() {
            return this.$J_UUID;
          }

          get slideActive() {
            return this.isActive;
          }

          playVideo() {
            if (this.isActive && this.inView && this.video && (this.fullscreenState === globalVariables.FULLSCREEN.OPENED || [globalVariables.SLIDE_SHOWN_BY.AUTOPLAY, globalVariables.SLIDE_SHOWN_BY.USER, globalVariables.SLIDE_SHOWN_BY.INIT].includes(this.slideShownBy))) {
              this.video.play();
            }
          }

          initVideo() {
            this.on('slideVideoReady', e => {
              e.stop();

              if (!this.isVideoReady) {
                this.isVideoReady = true;
                this.isReady = true;
                this.video.show();
                this.componentLoader.hide();
              }

              if (this.video.autoplay || !this.video.preStart) {
                this.playVideo();
              }
            });
            this.on('slideVideoPlay', e => {
              // e.stop();
              e.data.slide = this.api;

              if (this.isVideoPaused && !this.video.autoplay) {
                this.video.pause();
              }

              this.isVideoPaused = false;
            });
            this.on('slideVideoPause', e => {
              // e.stop();
              e.data.slide = this.api;
            });
            this.on('slideVideoEnd', e => {
              // e.stop();
              e.data.slide = this.api;
            });
            const videoOptions = this._options.video;

            switch (helper.videoModule.getType(this.slideContent)) {
              case 'youtube':
                this.video = new slideVideo.YouTubeVideo(this.slideContent, videoOptions);
                break;

              case 'vimeo':
                this.video = new slideVideo.VimeoVideo(this.slideContent, videoOptions);
                break;

              case 'video':
                this.video = new slideVideo.HTMLVideo(this.slideContent, videoOptions);
                break;

              default: // empty

            }

            this.video.parentClass = this;
          }

          resize() {
            if (!this._enabled) {
              return;
            }

            if (this.sirvService) {
              this.sirvService.resize();
              const t = globalVariables.SLIDE.TYPES;

              if (this.isReady && [t.SPIN, t.ZOOM].includes(this.typeOfSlide)) {
                if (this.sirvService.isZoomSizeExist()) {
                  this.contentWrapper.addClass(CAN_ZOOM_CLASS);
                } else {
                  this.contentWrapper.removeClass(CAN_ZOOM_CLASS);
                }
              }
            } else {// when video leaves viewport and then appears the browser generates resize event on android
              // if (this.video) {
              //     this.video.pause();
              // }
            }
          }

          destroy() {
            if (this.sirvService) {
              this.sirvService.destroy();
              this.sirvService = null;
              this.off('stats');
              this.off('componentEvent');
            } else if (this.multiImages.length) {
              this.multiImages.forEach(img => {
                if (!img.src && img.datasrc) {
                  img.node.removeAttribute('src');
                }
              });
            }

            this.slideContent.del('view-content');
            this.removeEventCloseFullscreeByClick();
            this.sendEventCloseFullscreenByClick = null;

            if (this.lastOriginNode) {
              this.slideContent.remove();
              this.slideContent = this.lastOriginNode;
              this.lastOriginNode = null;
            }

            if (this.fullscreenOnlyNode) {
              this.fullscreenOnlyNode.kill();
              this.fullscreenOnlyNode = null;
            }

            this.off('beforeFullscreenIn');
            this.off('afterFullscreenIn');
            this.off('beforeFullscreenOut');
            this.off('afterFullscreenOut');
            this.off('inView');

            if (this.video) {
              this.off('slideVideoReady');
              this.off('slideVideoPlay');
              this.off('slideVideoPause');
              this.off('slideVideoEnd');
              this.video.destroy();
            }

            this.video = null;

            if (this.componentLoader) {
              this.componentLoader.destroy();
              this.componentLoader = null;
            }

            if (this.socialbuttons) {
              this.socialbuttons.destroy();
            }

            this.sizePromise = null;
            this.componentSize = null;
            this.contentWrapper.remove();
            this.contentWrapper = null;
            this.instanceNode.remove();
            this.instanceNode = null;
            this.slideContent = null;
            this.isReady = false;
            this.availableSlide = null;
            super.destroy();
          }

        }

        return Slide_;
      })();
      /* eslint-env es6 */

      /* global $, $J, Slide, Selectors, Arrows, Effect, CSS_MAIN_CLASS, SELECTOR_TAG, EventEmitter, ContextMenu, helper, globalVariables, remoteModules, ProductDetail*/

      /* eslint-disable indent */

      /* eslint-disable no-lonely-if */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "SirvSlider" }] */


      let isHandset = null; // DIV used to correctly measure viewport height in Safari > 10 on iPhone

      let iPhoneSafariViewportRuler = null;

      const SirvSlider = (() => {
        const FULLSCREEN = 'fullscreen';

        const _FULLSCREEN = $J.camelize('-' + FULLSCREEN);

        const STANDARD_BUTTON_CLASS = CSS_MAIN_CLASS + '-button-' + FULLSCREEN + '-open';
        const FULLSCREEN_BUTTON_CLASS = CSS_MAIN_CLASS + '-button-' + FULLSCREEN + '-close';
        const FULLSCREEN_BUTTON_HIDE_CLASS = CSS_MAIN_CLASS + '-button-hidden'; // const SIZE_MESSAGE = 'can\'t get size';

        const PSEUDO_FULLSCREEN_CLASS = CSS_MAIN_CLASS + '-pseudo-' + FULLSCREEN;
        const STANDARD_CSS = {
          width: '100%',
          height: '100%'
        };
        const MIN_AUTOPLAY = 1000;
        const MAX_SLIDES_TO_CHANGE_PRELOAD_BEHAVIOR = 8;

        const isCustomId = id => {
          let result = false;
          id = id.split('-');
          id.splice(id.length - 1, 1);
          id = id.join('-');

          if (id === CSS_MAIN_CLASS) {
            result = true;
          }

          return result;
        };

        const getThumbnailsType = type => {
          let result = 'thumbnails';

          if (type === 'bullets') {
            result = type;
          }

          return result;
        }; // const getSelectorsSide = (position) => {
        //     let result = null;
        //     switch (position) {
        //         case 'left':
        //         case 'right':
        //             result = 'width';
        //             break;
        //         case 'top':
        //         case 'bottom':
        //             result = 'height';
        //             break;
        //         // no default
        //     }


        const slidePinnedFilter = rawSlides => {
          const slides = [];
          let pinnedAtTheEnd = 0;
          let pinnedAtTheStart = 0;

          for (let indexSlide = 0, l = rawSlides.length; indexSlide < l; indexSlide++) {
            let currentNode = rawSlides[indexSlide];

            if (currentNode.querySelector(SELECTOR_TAG)) {
              currentNode = currentNode.querySelector(SELECTOR_TAG);
            }

            const dataPinned = $J.$(currentNode).attr('data-pinned');
            const pinnedAttr = currentNode.hasAttribute('data-pinned');

            if (pinnedAtTheStart >= 3 && dataPinned === 'start' || pinnedAtTheEnd >= 3 && (pinnedAttr && dataPinned && (dataPinned === 'end' || dataPinned !== 'end' && dataPinned !== 'start') || pinnedAttr && !dataPinned)) {
              // eslint-disable-next-line
              continue;
            }

            if (pinnedAtTheStart < 3 && dataPinned === 'start') {
              pinnedAtTheStart++;
            }

            if (pinnedAtTheEnd < 3 && pinnedAttr && dataPinned && (dataPinned === 'end' || dataPinned !== 'end' && dataPinned !== 'start') || pinnedAttr && !dataPinned) {
              pinnedAtTheEnd++;
            }

            slides.push(rawSlides[indexSlide]);
          }

          return slides;
        };

        class Slider extends EventEmitter {
          constructor(node, options) {
            super();
            this.instanceNode = $(node);
            this.instanceOptions = options.options;
            this.viewerFileContent = options.viewerFileContent;

            this.option = (...args) => {
              if (args.length > 1) {
                return this.instanceOptions.set(args[0], args[1]);
              }

              return this.instanceOptions.get(args[0]);
            };

            this.slideOptions = Object.assign(options.slideOptions, {
              quality: this.instanceOptions.isset('quality') ? this.option('quality') : null,
              hdQuality: this.option('hdQuality'),
              isHDQualitySet: this.instanceOptions.isset('hdQuality'),
              fullscreenOnly: this.option(FULLSCREEN + '.always'),
              isFullscreen: this.option(FULLSCREEN + '.enable'),
              nativeFullscreen: this.option(FULLSCREEN + '.native'),
              sbEnable: this.option('slide.socialbuttons.enable'),
              sbFacebook: this.option('slide.socialbuttons.types.facebook'),
              sbTwitter: this.option('slide.socialbuttons.types.twitter'),
              sbLinkedin: this.option('slide.socialbuttons.types.linkedin'),
              sbReddit: this.option('slide.socialbuttons.types.reddit'),
              sbTumblr: this.option('slide.socialbuttons.types.tumblr'),
              sbPinterest: this.option('slide.socialbuttons.types.pinterest'),
              sbTelegram: this.option('slide.socialbuttons.types.telegram')
            });
            this.id = this.instanceNode.attr('id');

            if (!this.id) {
              this.id = CSS_MAIN_CLASS + '-' + helper.generateUUID();
              this.instanceNode.attr('id', this.id);
            }

            this.lazyInit = options.lazyInit;
            this.movingContainer = $J.$new('div').addClass(CSS_MAIN_CLASS);
            this.slideWrapper = $J.$new('div').addClass(CSS_MAIN_CLASS + '-slides-box');
            this.slidesContainer = $J.$new('div').addClass(CSS_MAIN_CLASS + '-slides');
            this.selectorsWrapper = $J.$new('div').addClass(CSS_MAIN_CLASS + '-selectors-box');
            this.fullScreenBox = $J.$new('div').addClass(CSS_MAIN_CLASS + '-' + FULLSCREEN + '-box');
            this.controlsWrapper = $J.$new('div').addClass(CSS_MAIN_CLASS + '-controls');
            this.producDetailsText = this.instanceNode.attr('data-product-detail');
            this.productDetail = null;
            this.fullScreenBox.addEvent(['mousescroll', 'touchstart'], e => {
              e.stopDistribution();
            });
            this.isReady = false;
            this.isMoving = false;
            this.isSelectorsReady = false;
            this.isToolStarted = false;
            this.isInitialized = false;
            this.isStartedFullInit = false;
            this.inViewModule = null;
            this.isInView = false;
            this.firstSlideAhead = false;
            this.rootMargin = 0;
            this.fullscreenButton = null;
            this.doSetSize = false;
            this.heightProportion = null;
            this.slides = [];
            this.enabledIndexesOfSlides = [];
            this.selectors = null;
            this.arrows = null;
            this.contextMenu = null;
            this.countOfSizes = $([]);
            this.isFullscreen = globalVariables.FULLSCREEN.CLOSED;
            this.fullscreenStartTime = null;
            this.index = 0;
            this.movingContainerId = CSS_MAIN_CLASS + '-' + helper.generateUUID();
            this.cssRulesId = 'sirv_css_rules-' + helper.generateUUID();
            this.isComponentPinching = false;
            this.isZoomIn = false;
            this.hasSize = false;
            this.isPseudo = false;
            this.doHistory = true;
            this.isAutoplay = this.option('slide.autoplay');
            this.autoplayDelay = this.option('slide.delay');
            this.residualAutoplayTime = this.autoplayDelay;
            this.sliderNodes = [];
            this.destroyed = false;
            this.autoplayTimer = null;
            this.timerRemove = null;
            this.onResizeDebounce = helper.debounce(() => {
              this.onResizeWithoutSelectors();
            }, 16);
            this.selectorsDebounce = null;

            if (this.doHistory) {
              this.fullscreenViewId = Math.floor(Math.random() * +new Date());
              globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.push(this.fullscreenViewId);
            }

            this.controlsWrapperWasAppended = false;
            this.isStandardGrid = false;
            this.isFullscreenGrid = false; // conflict with pinch event make us to inject the timer
            // this.touchDragTimer = null;

            this.clearingTouchdragFunction = null;
            this.classes = {
              standard: {
                movingContainerClasses: $([]),
                selectorsWrapperClasses: $([])
              },
              fullscreen: {
                movingContainerClasses: $([]),
                selectorsWrapperClasses: $([])
              }
            };
            this.externalContainer = null;

            if ($J.browser.mobile) {
              this.movingContainer.addClass(CSS_MAIN_CLASS + '-mobile');
            }

            this.onResizeHandler = this.onResize.bind(this);

            this.pseudoFSEvent = e => {
              if (e.oe.keyCode === 27) {
                // Esc
                $($J.D).removeEvent('keydown', this.pseudoFSEvent);
                this.exitFullScreen();
              }
            };

            this.keyBoardArrowsCallback = e => {
              let d;
              const kc = e.oe.keyCode;

              if (this.isReady) {
                if ([37, 39].includes(kc)) {
                  e.stop();
                  d = kc === 37 ? 'prev' : 'next';
                  this.jump(d, 2);
                }
              }
            };

            this.onHistoryStateChange = e => {
              try {
                if (e.oe.state && e.oe.state.name === 'Sirv.viewer') {
                  if (globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.indexOf(e.oe.state.hash) < 0) {
                    globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.splice(globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.indexOf(this.fullscreenViewId), 1);
                    this.fullscreenViewId = e.oe.state.hash;
                    globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.push(this.fullscreenViewId);
                  }

                  if (e.oe.state.hash === this.fullscreenViewId) {
                    this.enterFullScreen();
                  }
                } else {
                  if (this.isFullscreenState()) {
                    this.exitFullScreen();
                  }
                }
              } catch (ex) {// empty
              }
            };

            const parsedSlides = this.getSlides();
            this.addComponentsCSS = helper.debounce(() => {
              globalFunctions.rootDOM.addCSSStringToHtml();
            }, 100);
            globalFunctions.rootDOM.addCSSStringToHtml();
            globalFunctions.rootDOM.addCSSString(this.instanceNode.node);
            this.setComponentsEvents();
            this.createSlides(parsedSlides);

            if ($J.browser.ready || $J.D.node.readyState !== 'loading') {
              this.startFullInit();
            }

            if (ProductDetail && this.option('productdetail.enable') && this.producDetailsText) {
              this.createProductDetails();
            }
          }

          isFullscreenState() {
            return [globalVariables.FULLSCREEN.OPENING, globalVariables.FULLSCREEN.OPENED].includes(this.isFullscreen);
          }

          createProductDetails() {
            this.productDetail = new ProductDetail({
              text: this.producDetailsText,
              position: this.option('productdetail.position')
            }, this.movingContainer, this.fullScreenBox);
          }

          setRootMargin() {
            let value = parseInt(this.option('threshold'), 10);

            if ($J.typeOf(this.option('threshold')) === 'string') {
              const v = ($J.W.node.innerHeight || $J.D.node.documentElement.clientHeight) / 100 * value;
              value = v;
            }

            this.rootMargin = value;
          }

          startFullInit(options) {
            // the method must be launched after 'this.createSlides' method
            if (this.isStartedFullInit || !this.slides.length) {
              return;
            }

            this.isStartedFullInit = true;

            if (this.isHiddenSlides()) {
              return;
            }

            if (options) {
              this.instanceOptions = options.options;

              this.option = (...args) => {
                if (args.length > 1) {
                  return this.instanceOptions.set(args[0], args[1]);
                }

                return this.instanceOptions.get(args[0]);
              };

              this.slideOptions = Object.assign(options.slideOptions, {
                fullscreenOnly: this.option(FULLSCREEN + '.always'),
                autoplay: this.option('video.autoplay')
              });
              this.lazyInit = options.lazyInit;
              this.isAutoplay = this.option('slide.autoplay');
              this.autoplayDelay = this.option('slide.delay');
              this.residualAutoplayTime = this.autoplayDelay;
            }

            if (this.option(FULLSCREEN + '.always')) {
              this.movingContainer.addClass(CSS_MAIN_CLASS + '-fullsreen-always');
            }

            if (isHandset === null) {
              isHandset = $J.browser.mobile && window.matchMedia && window.matchMedia('(max-device-width: 767px), (max-device-height: 767px)').matches;
            } // Create a ruler div to properly handle viewport height in Safari (>10) on iPhone with and without address bar, bookmark bar and status bar.
            // if (isHandset && $J.browser.platform === 'ios' && $J.browser.uaName === 'safari' && parseInt($J.browser.uaVersion, 10) > 10) {


            if (isHandset && $J.browser.platform === 'ios') {
              iPhoneSafariViewportRuler = $J.$new('div').setCss({
                position: 'fixed',
                top: 0,
                width: 0,
                height: '100vh'
              });
            }

            this.normalizeOptions();
            this.setRootMargin();
            this.slideWrapper.addClass(CSS_MAIN_CLASS + '-' + (this.option('orientation') === 'horizontal' ? 'h' : 'v'));
            this.index = this.option('slide.first');
            const l = this.slides.length;

            if (this.index > l - 1) {
              this.index = 0;
            }

            if (l > 0 && (!this.slides[this.index].enabled || !this.slides[this.index].slideAvailable)) {
              let index = null;

              for (let i = 0; i < l; i++) {
                const tmpIndex = helper.sliderLib.findIndex('next', this.index + i, l, true);

                if (this.slides[tmpIndex].enabled && this.slides[tmpIndex].slideAvailable) {
                  index = tmpIndex;
                  break;
                }
              }

              if (index === null) {
                // eslint-disable-next-line no-console
                console.warn('Sirv Media Viewer: All items are disabled.', this.instanceNode.node);
                this.emit('destroy', {
                  data: {
                    id: this.id,
                    node: this.instanceNode.node
                  }
                });
                return;
              }

              this.index = index;
            }

            this.createContextMenu();
            this.setInViewAction();

            if (this.option('thumbnails.enable') && this.option('thumbnails.target')) {
              this.externalContainer = $($J.D.node.querySelector(this.option('thumbnails.target')));

              if (!this.externalContainer) {
                this.externalContainer = null;
              }
            }

            const fragment = $J.D.node.createDocumentFragment();
            fragment.appendChild(this.movingContainer.node);
            this.movingContainer.setCss(STANDARD_CSS);
            this.movingContainer.setCssProp('font-size', 0);
            this.movingContainer.append(this.slideWrapper); // this.slideWrapper.setCss(STANDARD_CSS);

            this.slides.forEach(slide => {
              slide.startFullInit(options ? this.slideOptions : null);
            });
            this.appendSelectors(true);
            this.createClasses();
            this.setClasses(); // css takes too long time to loading
            // and we have size because display = block by default
            // if selectors wrapper is vertical orientation
            // this.selectorsWrapper.setCssProp('display', 'inline-block');

            this.instanceNode.append(fragment);
            this.instanceNode.setCssProp('font-size', 0);
            this.slideWrapper.append(this.slidesContainer);
            this.slidesContainer.setCss(STANDARD_CSS);
            this.instanceNode.render();
            this.movingContainer.render();
            this.selectorsWrapper.render();
            this.slideWrapper.render();
            const containerHasHeight = this.instanceNode.size.height > 0;
            this.createSelectors();

            if (this.selectors && this.isStandardGrid) {
              this.selectorsWrapper.setCss({
                flexBasis: this.option('thumbnails.size') + 'px'
              });
            }

            let steps = 10;

            const getSize = () => {
              if (this.destroyed) {
                return;
              }

              let size = this.slidesContainer.node.getBoundingClientRect();

              if (!size.height) {
                size = this.slideWrapper.node.getBoundingClientRect();
              }

              steps -= 1;

              if (steps > 0 && (!size.width && !size.height || containerHasHeight && !size.height)) {
                setTimeout(getSize, 16);
              } else {
                this.instanceNode.setCssProp('font-size', '');

                if (size.width) {
                  // size.height / size.width < 0.25 - fix for ie and firefox
                  // if (!size.height || size.height / size.width < 0.25) {
                  if (!size.height) {
                    this.doSetSize = true;
                  }
                } else {
                  // Fix for display none
                  this.doSetSize = true;
                }

                this.slides.forEach(slide => {
                  if (slide.slideAvailable) {
                    this.slidesContainer.append(slide.node);
                  }

                  slide.appendToDOM(); // all elements must be in dom

                  slide.initVideoPlayer();
                });
                this.setClasses();
                this.searchingOfProportions();

                if (this.selectors) {
                  this.selectors.init();
                }

                this.postInitialization();
              }
            };

            if (this.firstSlideAhead) {
              // if autostart is false
              this.broadcast('inView', {
                data: this.isInView
              });
            }

            setTimeout(getSize, 16);
          }

          visibleSlides() {
            return this.slides.filter(slide => slide.slideAvailable && slide.enabled).length;
          }

          searchingOfProportions() {
            const l = this.slides.length;

            const initOtherComponents = () => {
              const i = this.index;
              const p = this.firstSlideAhead ? false : this.option('slide.preload');
              this.hasSize = this.setContainerSize();

              if (this.inViewModule && ['edge', 'ie'].includes($J.browser.uaName)) {
                this.inViewModule.takeRecords();
              }

              this.slides.forEach((_slide, index) => {
                _slide.startTool(i === index, p, this.firstSlideAhead);
              });
              this.createEffect();
              this.isToolStarted = true;
              this.checkSingleSlide();
              this.slides[this.index].beforeShow();
              this.slides[this.index].afterShow(globalVariables.SLIDE_SHOWN_BY.INIT);
              this.postInitialization();
            };

            const getSlideSize = (index, indexes) => {
              return new Promise((resolve, reject) => {
                const slide = this.slides[index];
                const slidesCount = this.slides.length;
                indexes.push(index);

                if (slide) {
                  const nextSearching = () => {
                    let nextIndex = helper.getArrayIndex(index + 1, l);

                    if (slidesCount !== this.slides.length && nextIndex > index) {
                      nextIndex = index;
                    }

                    if (indexes.includes(nextIndex)) {
                      const tmp = this.slidesContainer.size;

                      if (!tmp.width) {
                        tmp.width = 500; // we don'n have any size
                      }

                      if (!tmp.height) {
                        // it can be video without sizes or html, but we have width
                        tmp.height = tmp.width * 0.5625; // (9/16)
                      }

                      this.heightProportion = tmp;
                      resolve();
                    } else {
                      getSlideSize(nextIndex, indexes).then(resolve);
                    }
                  };

                  slide.getSlideSize().then(data => {
                    const size = data.size;

                    if (size && size.width && size.height) {
                      this.heightProportion = size;
                      resolve();
                    } else {
                      nextSearching();
                    }
                  }).catch(err => {
                    let _l = this.slides.length;

                    if (err && err.error && err.error.status === 404) {
                      _l -= 1;
                      this.pickOut(err.UUID);
                    }

                    if (_l > 0) {
                      nextSearching();
                    } else {
                      reject();
                    }
                  });
                }
              });
            };

            if (this.doSetSize) {
              getSlideSize(this.index, []).then(() => {
                initOtherComponents();
              }).catch(() => {});
            } else {
              initOtherComponents();
            }
          }

          initTouchDrag() {
            let axises = ['x', 'left', 'width'];
            let otherAxise = 'y';
            let containerPosition;
            let isMoving = false;
            let startPosition;
            let lastPercent;
            let size;
            let firstSlide = null;
            let middleSlide = null;
            let lastSlide = null;
            const loop = this.option('loop');
            let lastDirection = null;
            let lastPosition = null;
            let makeAnimation = true;
            let isChanging = true;
            let nextSlide = null;
            let useless = null;
            let stateOfScroll = 0; // 0 - nothing, 1 - drag slide, 2 - scroll page

            let lastXY = {
              x: null,
              y: null
            };
            let lastAnimation = false;

            const getSlidePercent = value => {
              return value / size * 100;
            };

            const getStyleValue = value => {
              const pos = {
                x: 0,
                y: 0
              };
              pos[axises[0]] = value;
              return 'translate3d(' + pos.x + '%, ' + pos.y + '%, 0px)';
            };

            const setCss = (node, value) => {
              if (node) {
                node.node.setCssProp('transform', getStyleValue(value));
              }
            };

            const setSlidesCss = value => {
              setCss(firstSlide, value - 100);
              setCss(middleSlide, value);
              setCss(lastSlide, value + 100);
            };

            const endOfEffect = direction => {
              return new Promise((resolve, reject) => {
                let tmp;
                let currentSlidePosition = 100;
                let nextSlidePosition = 0;
                const abs = Math.abs(lastPercent);

                if (abs < 25 || stateOfScroll === 2 || direction === 'next' && lastPercent < 0 || direction === 'prev' && lastPercent > 0) {
                  isChanging = false;
                }

                if (!isChanging) {
                  if (lastPercent < 0) {
                    direction = 'prev';
                  } else {
                    direction = 'next';
                  }
                }

                nextSlide = direction === 'next' ? firstSlide : lastSlide;
                useless = direction === 'next' ? lastSlide : firstSlide;

                if (direction !== 'next') {
                  currentSlidePosition *= -1;
                }

                if (useless) {
                  useless.node.setCssProp('transform', '');
                  useless.afterHide();
                }

                if (isChanging) {
                  middleSlide.beforeHide();
                  this.sendEvent('beforeSlideIn', {
                    slide: nextSlide.api
                  });
                  this.sendEvent('beforeSlideOut', {
                    slide: middleSlide.api
                  });
                  this.index = nextSlide.index;
                } else {
                  tmp = currentSlidePosition;
                  currentSlidePosition = nextSlidePosition;
                  nextSlidePosition = tmp;
                  nextSlidePosition *= -1;

                  if (abs < 2) {
                    makeAnimation = false;
                  }
                }

                if (makeAnimation) {
                  middleSlide.node.addEvent('transitionend', e => {
                    e.stop();
                    resolve();
                  });

                  if (nextSlide) {
                    nextSlide.node.setCssProp('transition', 'transform, .3s');
                  }

                  middleSlide.node.setCssProp('transition', 'transform, .3s'); // eslint-disable-next-line no-unused-vars

                  let s;

                  if (nextSlide) {
                    s = nextSlide.node.size;
                  }

                  s = middleSlide.node.size;

                  if (this.selectors) {
                    this.selectors.activateItem(this.index);
                    this.selectors.jump(this.index);
                  }
                }

                if (nextSlide) {
                  setCss(nextSlide, nextSlidePosition);
                }

                setCss(middleSlide, currentSlidePosition);

                if (!makeAnimation) {
                  resolve();
                }
              });
            };

            const fullClear = () => {
              if (isMoving) {
                const css = {
                  'transform': '',
                  'transition': ''
                };
                middleSlide.node.removeEvent('transitionend');

                if (nextSlide) {
                  if (isChanging) {
                    this.checkLoop(this.index);
                    nextSlide.afterShow(globalVariables.SLIDE_SHOWN_BY.USER);
                    middleSlide.afterHide();
                    this.sendEvent('afterSlideIn', {
                      slide: nextSlide.api
                    });
                    this.sendEvent('afterSlideOut', {
                      slide: middleSlide.api
                    });
                  } else {
                    if (nextSlide) {
                      nextSlide.afterHide();
                    }
                  }

                  if (nextSlide) {
                    nextSlide.node.setCss(css);
                  }
                }

                middleSlide.node.setCss(css);
                makeAnimation = true;
                isChanging = true;
                nextSlide = null;
                useless = null;
                this.enableFullscreenButton();
                this.autoplay();
                isMoving = false;
                this.isMoving = false;
                lastDirection = null;
                lastPosition = null;
                firstSlide = null;
                middleSlide = null;
                lastSlide = null;
                lastAnimation = false;
              }
            };

            const getNextSlide = (direction, fromIndex) => {
              let result = null;
              let currentIndex = fromIndex;

              if (currentIndex === $J.U) {
                currentIndex = this.index;
              }

              const index = this.getNextIndex(direction, currentIndex, this.slides.length, loop);

              if (index !== null) {
                const slide = this.slides[index];

                if (slide.index !== this.index) {
                  if (!slide.enabled) {
                    result = getNextSlide(direction, slide.index);
                  } else {
                    result = slide;
                  }
                }
              }

              return result;
            };

            const start = e => {
              if (lastAnimation) {
                return;
              }

              fullClear();
              this.effect.stop();

              if (this.index === null) {
                return;
              }

              middleSlide = this.slides[this.index];

              if (middleSlide.isSwipeDisabled()) {
                return;
              }

              isMoving = true;
              this.isMoving = true;
              containerPosition = this.slidesContainer.position[axises[1]];
              size = this.slidesContainer.size[axises[2]];
              lastPosition = e[axises[0]] - containerPosition;
              startPosition = getSlidePercent(lastPosition);
              lastPercent = startPosition; // const l = this.slides.length;
              // firstSlide = this.slides[helper.sliderLib.getIndexFromDirection(this.index, 'prev', l, loop)];
              // lastSlide = this.slides[helper.sliderLib.getIndexFromDirection(this.index, 'next', l, loop)];

              firstSlide = getNextSlide('prev');
              lastSlide = getNextSlide('next');

              if (firstSlide && lastSlide) {
                if (firstSlide.index === lastSlide.index) {
                  if (firstSlide.index < middleSlide.index) {
                    lastSlide = null;
                  } else {
                    firstSlide = null;
                  }
                } else if (firstSlide.index === middleSlide.index || middleSlide.index === lastSlide.index) {
                  if (firstSlide.index === middleSlide.index) {
                    firstSlide = null;
                  } else {
                    lastSlide = null;
                  }
                }
              }

              if (firstSlide) {
                setCss(firstSlide, -100);
                firstSlide.beforeShow();
              }

              if (lastSlide) {
                setCss(lastSlide, 100);
                lastSlide.beforeShow();
              }

              this.disableFullscreenButton();
            };

            const move = e => {
              let direction;
              let current;

              if (isMoving && !lastAnimation) {
                isMoving = true;
                e.stop();
                current = e[axises[0]] - containerPosition;

                if (current < lastPosition) {
                  direction = 'prev';
                } else if (current > lastPosition) {
                  direction = 'next';
                } else {
                  if (!direction) {
                    direction = lastPercent > 0 ? 'next' : 'prev';
                  }
                }

                lastPosition = current;
                lastDirection = direction;
                lastPercent = getSlidePercent(lastPosition) - startPosition;

                if (!lastSlide && lastPercent < -10) {
                  lastPercent = -10;
                }

                if (!firstSlide && lastPercent > 10) {
                  lastPercent = 10;
                }

                setSlidesCss(lastPercent);
              }
            };

            const end = e => {
              if (isMoving && !lastAnimation) {
                if (stateOfScroll === 1) {
                  e.stop();
                }

                middleSlide.dragEvent(e.state);
                lastAnimation = true;
                endOfEffect(lastDirection).finally(() => {
                  lastAnimation = false;
                  fullClear();
                });
              }
            };

            const onDrag = e => {
              if (this.isComponentPinching || this.isZoomIn || this.slides[this.index].blokedTouchdrag || this.option(FULLSCREEN + '.always') && this.isFullscreen !== globalVariables.FULLSCREEN.OPENED) {
                return;
              }

              if (e.state === 'dragstart') {
                // clearTimeout(this.touchDragTimer);
                lastXY = {
                  x: e.x,
                  y: e.y
                }; // this.touchDragTimer = setTimeout(() => {

                start(e);
                middleSlide.dragEvent(e.state); // }, 16);
              } else if (e.state === 'dragmove') {
                if (!stateOfScroll) {
                  if (Math.abs(lastXY[axises[0]] - e[axises[0]]) > Math.abs(lastXY[otherAxise] - e[otherAxise])) {
                    stateOfScroll = 1;
                  } else {
                    stateOfScroll = 2;
                  }
                }

                if (stateOfScroll === 1) {
                  move(e);
                }

                lastXY = {
                  x: e.x,
                  y: e.y
                };
              } else if (e.state === 'dragend') {
                // clearTimeout(this.touchDragTimer);
                // this.touchDragTimer = null;
                end(e);
                stateOfScroll = 0;
                lastXY = {
                  x: null,
                  y: null
                };
              }
            };

            if (this.option('orientation') === 'vertical') {
              axises = ['y', 'top', 'height'];
              otherAxise = 'x';
            }

            this.clearingTouchdragFunction = fullClear;
            this.slidesContainer.addEvent('touchdrag', onDrag); // this.slidesContainer.addEvent(['mousedrag', 'touchdrag'], onDrag);
          }

          appendSelectors(start) {
            let container = this.movingContainer;

            if (this.externalContainer) {
              if (!this.isFullscreenState()) {
                container = this.externalContainer;
                this.selectorsWrapper.addClass(CSS_MAIN_CLASS + '-external');
              } else {
                this.selectorsWrapper.removeClass(CSS_MAIN_CLASS + '-external');
              }
            }

            if (start || this.externalContainer) {
              container.append(this.selectorsWrapper);
            }
          }

          createClasses() {
            const option = this.option;

            const getOrientation = value => {
              if (['left', 'right'].includes(value)) {
                return 'v';
              }

              return 'h';
            };

            ['standard', 'fullscreen'].forEach(_type => {
              const isStandard = _type === 'standard';
              const en = isStandard ? option('thumbnails.enable') : option('fullscreen.thumbnails.enable');
              const s = isStandard ? option('thumbnails.position') : option('fullscreen.thumbnails.position');
              const ss = getThumbnailsType(isStandard ? option('thumbnails.type') : option('fullscreen.thumbnails.type'));
              const grid = isStandard ? this.isStandardGrid : this.isFullscreenGrid;

              if (en) {
                if (!isStandard || !this.externalContainer) {
                  this.classes[_type].movingContainerClasses.push(CSS_MAIN_CLASS + '-selectors-' + s);
                }

                this.classes[_type].selectorsWrapperClasses.push(CSS_MAIN_CLASS + '-' + ss);

                this.classes[_type].selectorsWrapperClasses.push(CSS_MAIN_CLASS + '-' + getOrientation(s));

                if (grid) {
                  this.classes[_type].selectorsWrapperClasses.push(CSS_MAIN_CLASS + '-grid');
                }

                if (option('fullscreen.thumbnails.autohide') && !isStandard) {
                  this.classes[_type].movingContainerClasses.push(CSS_MAIN_CLASS + '-autohide');

                  this.classes[_type].movingContainerClasses.push(CSS_MAIN_CLASS + '-selectors-closed');
                }
              }
            });
          }

          changeClasses(obj, remove) {
            const action = remove ? 'removeClass' : 'addClass';
            obj.movingContainerClasses.forEach(className => {
              this.movingContainer[action](className);
            });
            obj.selectorsWrapperClasses.forEach(className => {
              this.selectorsWrapper[action](className);
            });
          }

          setClasses() {
            if (this.isFullscreenState()) {
              this.changeClasses(this.classes.standard, true);
              this.changeClasses(this.classes.fullscreen);
            } else {
              this.changeClasses(this.classes.fullscreen, true);
              this.changeClasses(this.classes.standard);
            }
          }

          setInViewAction() {
            if (this.option('autostart') === 'visible') {
              this.inViewModule = new helper.InViewModule(entries => {
                entries.forEach(entry => {
                  const last = this.isInView; // https://github.com/verlok/vanilla-lazyload/issues/293#issuecomment-469100338
                  // Sometimes 'intersectionRatio' can be 0 but 'isIntersecting' is true

                  let iv = entry.isIntersecting || entry.intersectionRatio > 0;

                  if (this.isFullscreenState() && !iv) {
                    iv = true;
                  }

                  if (last !== iv) {
                    this.isInView = iv;
                    this.postInitialization();
                    this.broadcast('inView', {
                      data: iv
                    });

                    if (this.isInView) {
                      this.autoplay();
                    } else {
                      this.pauseAutoplay();
                    }
                  }
                });
              }, {
                rootMargin: this.rootMargin + 'px 0px'
              });
              this.inViewModule.observe(this.instanceNode.node);
            } else {
              this.isInView = true;
            }
          }

          sendEvent(nameOfEvent, data) {
            /*
                slider events: [
                    'ready',
                    'beforeSlideIn',
                    'beforeSlideOut',
                    'afterSlideIn',
                    'afterSlideOut',
                    'fullscreenIn',
                    'fullscreenOut',
                    'enableItem',
                    'disableItem'
                ]
            */
            if (!data) {
              data = {};
            }

            data.node = this.instanceNode;

            if (!data.slider) {
              data.slider = {
                type: nameOfEvent
              };
            }

            this.emit('viewerPublicEvent', {
              data: data
            });
          }

          checkReadiness(eventName, component) {
            let result = false;

            if (['init', 'ready'].includes(eventName)) {
              if (component === 'viewer') {
                if (eventName === 'ready') {
                  result = this.isReady;
                }
              } else {
                for (let i = 0, l = this.slides.length; i < l; i++) {
                  if (this.slides[i].checkReadiness(eventName, component)) {
                    result = true;
                    break;
                  }
                }
              }
            }

            return result;
          }

          sendReadyEvent(eventName, component) {
            if (component === 'viewer') {
              this.sendEvent('ready');
            } else {
              this.slides.forEach(slide => {
                slide.sendReadyEvent(eventName, component);
              });
            }
          }

          sendStats(typeOfEvent, data) {
            if (!data) {
              data = {};
            }

            data.slider = this.id;

            if (typeOfEvent) {
              data.data = {};
              data.data.event = typeOfEvent;
            }

            let stats;
            let serverStats;

            switch (data.component) {
              case 'spin':
                stats = {
                  account: data.account,
                  event: {
                    type: data.component,
                    name: data.event,
                    data: data.data || {},
                    sessionId: data.sessionId,
                    origin: data.origin
                  }
                };
                stats.event[data.event === 'sessionStart' ? 'ts' : 'time'] = data.eventTime;
                serverStats = JSON.parse(JSON.stringify(stats));
                serverStats.event = JSON.stringify(serverStats.event);
                break;
              // no default
            }

            if (stats) {
              if (data.useBeacon === true) {
                helper.sendRawStats(serverStats, true);
              } else {
                setTimeout(() => {
                  helper.sendRawStats(serverStats);
                }, 1);
              }

              this.sendEvent('sendStats', $J.detach(stats));
            }
          }

          setComponentsEvents() {
            // const size = this.slidesContainer.size;
            // const getProportionSize = (proportions) => {
            //     let i;
            //     let result = null;
            //     for (i = 0; i < proportions.length; i++) {
            //         if (proportions[i].size) {
            //             result = proportions[i].size;
            //             break;
            //         }
            //     }
            //     return result;
            // };
            const loadContent = index => {
              if (this.firstSlideAhead && index === this.index) {
                const p = this.option('slide.preload');
                this.enabledIndexesOfSlides.forEach(slideIndex => {
                  this.slides[slideIndex].startGettingInfo();

                  if (p) {
                    this.slides[slideIndex].loadContent();
                  } else {
                    this.slides[slideIndex].loadThumbnail();
                  }
                });
              }
            };

            const play = index => {
              if (this.index === index) {
                this.autoplay();
              }
            };

            const pause = index => {
              if (this.index === index) {
                this.pauseAutoplay();
              }
            };

            this.on('stats', e => {
              /*
                  e.data = {
                      event: 'rotate',  // name of event
                      data: {},         // event data
                      index: 0          // slide Index
                      component: 'spin' // type of component
                  }
              */
              e.stopAll();
              const doc = $J.D.node;
              const win = $J.W.node;
              const scrn = win.screen;

              if (e.data.event === 'sessionStart') {
                if (!e.data.data) {
                  e.data.data = {};
                }

                e.data.data.screen = {
                  width: scrn.width,
                  height: scrn.height,
                  availWidth: scrn.availWidth,
                  availHeight: scrn.availHeight,
                  colorDepth: scrn.colorDepth,
                  pixelDepth: scrn.pixelDepth
                };
                e.data.data.browser = {
                  width: win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth || 0,
                  height: win.innerHeight || doc.documentElement.clientWidth || doc.body.clientWidth || 0
                };
              }

              this.sendStats(null, e.data);
            });
            this.on('slideVideoPlay', e => {
              e.stopAll();
              pause(e.data.slide.index);
            });
            this.on('slideVideoPause', e => {
              e.stopAll(); // pause(e.data.slide.index);
            });
            this.on('slideVideoEnd', e => {
              e.stopAll();
              play(e.data.slide.index);
            }); // if slide is not sirv component

            this.on('contentLoaded', e => {
              e.stopAll();
              loadContent(e.data.slide.index);
            }); // init,ready,zoomIn,zoomOut
            // fullscreenIn, fullscreenOut
            // pinchStart, pinchEnd

            this.on('componentEvent', e => {
              const event = e.data.type;
              e.stopAll();

              switch (event) {
                case 'init':
                  if (this.index === e.data.slide.index || this.slides[this.index] && this.slides[this.index].spinInited) {
                    this.addControllWrapper();
                    this.enableFullscreenButton();
                    this.visibleFullscreenButton();
                  }

                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'ready':
                  if (this.index === e.data.slide.index && e.data.component !== 'spin' && (!this.slides[e.data.slide.index].videoSlide || this.isFullscreenState())) {
                    this.addControllWrapper();
                    this.enableFullscreenButton();
                    this.visibleFullscreenButton();
                  }

                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'rotate':
                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'fullscreenIn':
                  if (e.data.component === 'video') {
                    this.sendEvent('componentEvent', e.data);
                  } else if (this.option(FULLSCREEN + '.enable') && this.isFullscreen === globalVariables.FULLSCREEN.CLOSED) {
                    this.enterFullScreen();
                  }

                  break;

                case 'fullscreenOut':
                  if (e.data.component === 'video') {
                    this.sendEvent('componentEvent', e.data);
                  } else {
                    this.exitFullScreen();
                  }

                  break;

                case 'pinchStart':
                  // clearTimeout(this.touchDragTimer);
                  // this.touchDragTimer = null;
                  this.isComponentPinching = true;
                  break;

                case 'pinchEnd':
                  this.isComponentPinching = false;
                  break;

                case 'zoomIn':
                  this.isZoomIn = true;
                  pause(e.data.slide.index);
                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'zoomOut':
                  this.isZoomIn = false;
                  play(e.data.slide.index);
                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'hotspotOpened':
                  pause(e.data.slide.index);
                  break;

                case 'hotspotClosed':
                  play(e.data.slide.index);
                  break;

                case 'spinStart':
                  pause(e.data.slide.index);
                  break;

                case 'spinEnd':
                  play(e.data.slide.index);
                  break;

                case 'play':
                  if (e.data.component === 'video') {
                    pause(e.data.slide.index);
                    this.sendEvent('componentEvent', e.data);
                  }

                  break;

                case 'resume':
                  if (e.data.component === 'video') {
                    pause(e.data.slide.index);
                    this.sendEvent('componentEvent', e.data);
                  }

                  break;

                case 'pause':
                  if (e.data.component === 'video') {
                    this.sendEvent('componentEvent', e.data);
                  }

                  break;

                case 'end':
                  if (e.data.component === 'video') {
                    play(e.data.slide.index);
                    this.sendEvent('componentEvent', e.data);
                  }

                  break;

                case 'seek':
                  // video component event
                  this.sendEvent('componentEvent', e.data);
                  break;

                case 'contentLoaded':
                  loadContent(e.data.slide.index);
                  break;

                default: // no default

              }
            });
            this.on('goTo' + _FULLSCREEN, e => {
              e.stopAll();

              if (this.option(FULLSCREEN + '.enable') && this.isFullscreen === globalVariables.FULLSCREEN.CLOSED) {
                this.enterFullScreen();
              }
            });
            this.on('goTo' + _FULLSCREEN + 'Out', e => {
              e.stopAll();
              this.exitFullScreen();
            });
            this.on('infoReady', e => {
              // if slide was added by api
              e.stop();

              if (this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                const slide = this.slides[e.data.index];
                slide.broadcast('before' + _FULLSCREEN + 'In', {
                  data: {
                    pseudo: this.isPseudo
                  }
                });
                slide.broadcast('after' + _FULLSCREEN + 'In', {
                  data: {
                    pseudo: this.isPseudo
                  }
                });
              }
            });
            this.on(e => {
              e.stopAll();
            });
          }

          normalizeOptions() {
            const opts = $(['contextmenu.text.zoom.in', 'contextmenu.text.zoom.out', 'contextmenu.' + FULLSCREEN + '.enter', 'contextmenu.' + FULLSCREEN + '.exit', 'contextmenu.text.download']);

            const isEmpty = str => {
              return $J.typeOf(str) === 'string' && str.trim() === '';
            };

            if (this.option('fullscreen.thumbnails.size') === 'auto') {
              this.option('fullscreen.thumbnails.size', this.option('thumbnails.size'));
            }

            if (this.option('slide.animation.type') === 'off') {
              this.option('slide.animation.type', false);
            }

            if (this.option('thumbnails.type') === 'grid') {
              this.isStandardGrid = true;
              this.option('thumbnails.type', 'square');
            }

            if (this.option('fullscreen.thumbnails.type') === 'grid') {
              this.isFullscreenGrid = false;
              this.option('fullscreen.thumbnails.type', 'square');
            }

            opts.forEach(opt => {
              if (isEmpty(this.option(opt))) {
                this.option(opt, false);
              }
            });

            if (this.option('thumbnails.enable') && this.option('thumbnails.target') && this.option('thumbnails.target').trim() === '') {
              this.option('thumbnails.target', false);
            }

            if (this.option('slide.socialbuttons.enable') && !this.option('slide.socialbuttons.types.facebook') && !this.option('slide.socialbuttons.types.twitter') && !this.option('slide.socialbuttons.types.linkedin') && !this.option('slide.socialbuttons.types.reddit') && !this.option('slide.socialbuttons.types.tumblr') && !this.option('slide.socialbuttons.types.pinterest') && !this.option('slide.socialbuttons.types.telegram')) {
              this.option('slide.socialbuttons.enable', false);
            }

            this.slideOptions.sbEnable = this.option('slide.socialbuttons.enable');
          }

          addControllWrapper() {
            if (!this.controlsWrapperWasAppended && this.controlsWrapper.node.childNodes.length) {
              this.controlsWrapperWasAppended = true;
              this.slideWrapper.append(this.controlsWrapper);
            }
          }

          postInitialization() {
            if (!this.isInitialized && this.isInView && this.isSelectorsReady && this.isToolStarted && this.isStartedFullInit) {
              this.isInitialized = true;

              if (!this.hasSize) {
                this.setContainerSize();
              }

              this.broadcast('inView', {
                data: this.isInView
              });
              this.createArrows();

              if (this.selectors) {
                this.selectors.inView(this.isInView, this.instanceNode);
                this.selectors.activateItem(this.index);
              }

              if (!$J.browser.mobile) {
                const eventName = ['edge', 'ie'].includes($J.browser.uaName) ? 'pointerout' : 'mouseout';
                this.movingContainer.addEvent(eventName, e => {
                  if (e.pointerType && e.pointerType !== 'mouse') {
                    return;
                  }

                  let toElement = e.related;

                  while (toElement && toElement !== this.movingContainer.node) {
                    toElement = toElement.parentNode;
                  }

                  if (this.movingContainer.node !== toElement && this.index !== null) {
                    this.slides[this.index].mouseAction('mouseout', e);
                  }
                });
              }

              if (this.slides.length > 1) {
                this.initTouchDrag();
              }

              $($J.W).addEvent('resize', this.onResizeHandler);
              this.showHideArrows();
              this.showHideSelectors();

              if (this.option(FULLSCREEN + '.always')) {
                this.slideWrapper.addClass(globalVariables.CSS_CURSOR_FULSCREEN_ALWAYS);
              }

              this.movingContainer.attr('id', this.movingContainerId);
              this.createFullscreenButton();
              this.addControllWrapper();

              if (this.slides[this.index] && !this.slides[this.index].sirv && (!this.slides[this.index].videoSlide || this.isFullscreenState())) {
                this.enableFullscreenButton();
                this.visibleFullscreenButton();
              }

              this.checkLoop(this.index); // we can't reset this style earlier, because youtube and vimeo can't get size if it is first slide

              this.movingContainer.setCssProp('font-size', '');

              if (this.doHistory) {
                $($J.W).addEvent('popstate', this.onHistoryStateChange);
              }

              this.autoplay();
              this.isReady = true;
              this.sendEvent('ready');
            }
          }

          addHistory() {
            if (this.doHistory) {
              // Modify browser history so that expanded view can be closed by browser's Back button
              const urlHash = '#sirv-viewer-' + this.fullscreenViewId;

              if ($J.W.node.location.hash !== urlHash) {
                const state = {
                  name: 'Sirv.viewer',
                  hash: this.fullscreenViewId
                };
                const title = $J.D.node.body.title || 'Sirv viewer';

                try {
                  if ($J.W.node.history.state && $J.W.node.history.state.name === 'Sirv.viewer') {
                    $J.W.node.history.replaceState(null, title, '');
                  }

                  $J.W.node.history.pushState(state, title, urlHash);
                } catch (e) {// empty
                }
              }
            }
          }

          setContainerSize() {
            let result = false;
            let ss = 0;

            if (this.selectors) {
              ss = this.selectorsWrapper.size[this.selectors.shortSide];
            }

            const size = this.movingContainer.size;
            const selectors = this.option('thumbnails.position');
            const isSelectorsContainer = this.option('thumbnails.enable') && this.canShowSelectors(this.slides.length) && ss > 0 && !this.externalContainer;

            if (size.width || size.height) {
              result = true;

              if (this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                this.movingContainer.setCssProp('height', '');
                this.slideWrapper.setCssProp('height', '');
              } else {
                if (this.doSetSize && this.heightProportion) {
                  if (isSelectorsContainer && ['left', 'right'].includes(selectors)) {
                    size.width -= ss;
                  }

                  let height = size.width * (this.heightProportion.height / this.heightProportion.width);

                  if (height > this.heightProportion.height) {
                    height = this.heightProportion.height;
                  } // if (isSelectorsContainer && ['top', 'bottom'].includes(selectors)) { height += ss; }
                  // this.movingContainer.setCssProp('height', height + 'px');


                  if (!isSelectorsContainer || ['left', 'right'].includes(selectors) && !this.isStandardGrid) {
                    this.movingContainer.setCssProp('height', height + 'px');
                  } else {
                    this.slideWrapper.setCssProp('height', height + 'px');
                  }
                }
              }
            }

            return result;
          }

          findSlideIndex(id) {
            let result = -1;

            for (let i = 0, l = this.slides.length; i < l; i++) {
              if (this.slides[i].id && this.slides[i].id === id) {
                result = this.slides[i].index;
                break;
              }
            }

            return result;
          }

          getCountOfEnabledSlides(isDisabled) {
            let result = this.enabledIndexesOfSlides.length;

            if (isDisabled) {
              result = this.slides.length - result;
            }

            return result;
          }

          getItems(settings) {
            /*
                settings = undefined
                settings = {
                    enabled: true|false,
                    group: 'group'|['group', ...]
                }
            */
            let isEnabled = null;
            let slides = this.slides;

            if (settings) {
              if ($J.defined(settings.enabled)) {
                isEnabled = settings.enabled;
              }

              if (settings.group) {
                slides = this.getSlidesByGroup(settings.group);
              }
            }

            const result = [];
            slides.forEach(slide => {
              if (isEnabled === true) {
                if (slide.enabled) {
                  result.push(slide.api);
                }
              } else if (isEnabled === false) {
                if (!slide.enabled) {
                  result.push(slide.api);
                }
              } else {
                result.push(slide.api);
              }
            });
            return result;
          }

          controlEnabledSlides(indexOfSlide, remove) {
            if (remove) {
              this.enabledIndexesOfSlides.splice(this.enabledIndexesOfSlides.indexOf(indexOfSlide), 1);
            } else {
              this.enabledIndexesOfSlides.push(indexOfSlide);
              this.enabledIndexesOfSlides = this.enabledIndexesOfSlides.sort((a, b) => {
                let result = 0;

                if (a < b) {
                  result = -1;
                } else if (a > b) {
                  result = 1;
                }

                return result;
              });
            }
          }

          disableSlide(indexOfSlide, withoutEvent) {
            let result = false;
            let nextSlide = 'next';
            const l = this.slides.length;

            if ($J.typeOf(indexOfSlide) === 'string') {
              indexOfSlide = this.findSlideIndex(indexOfSlide);
            }

            if ($J.typeOf(indexOfSlide) === 'number' && indexOfSlide >= 0 && indexOfSlide < this.slides.length && this.slides[indexOfSlide].enabled) {
              const slideUUID = this.slides[indexOfSlide].$J_UUID;

              if (this.effect) {
                this.effect.stop();
              }

              if (this.slides[indexOfSlide].isActive) {
                if (this.index === l - 1 && this.option('loop')) {
                  nextSlide = 0;
                }

                if (!this.jump(nextSlide, 4, true)) {
                  this.slides[indexOfSlide].beforeHide();
                  this.slides[indexOfSlide].afterHide();
                }
              }

              if (this.slides[indexOfSlide].enabled) {
                this.controlEnabledSlides(indexOfSlide, true);
              }

              this.slides[indexOfSlide].disable();
              this.checkLoop(this.index);

              if (!this.enabledIndexesOfSlides.length) {
                this.index = null;
              }

              if (this.selectors) {
                this.selectors.disable(slideUUID);
              }

              if (!withoutEvent) {
                this.sendEvent('disableItem', {
                  slide: this.slides[indexOfSlide].api
                });
              }

              this.checkSingleSlide();
              this.showHideArrows();
              this.showHideSelectors();
              result = true;
            }

            return result;
          }

          enableSlide(slideIndex) {
            let result = false;

            if ($J.typeOf(slideIndex) === 'string') {
              slideIndex = this.findSlideIndex(slideIndex);
            }

            if ($J.typeOf(slideIndex) === 'number' && slideIndex >= 0 && slideIndex < this.slides.length && !this.slides[slideIndex].enabled) {
              this.slides[slideIndex].startGettingInfo();
              this.slides[slideIndex].loadThumbnail();
              this.slides[slideIndex].enable();
              this.slides[slideIndex].resize();
              const lenghtAvailableSlides = this.enabledIndexesOfSlides.filter(index => {
                return this.slides[index].slideAvailable;
              });

              if (!this.enabledIndexesOfSlides.length) {
                this.index = slideIndex;
              }

              if (this.slides[slideIndex].slideAvailable && !lenghtAvailableSlides.length) {
                this.index = slideIndex;
                this.slides[slideIndex].loadContent();
                this.slides[slideIndex].beforeShow();
                this.slides[slideIndex].afterShow(globalVariables.SLIDE_SHOWN_BY.ENABLE);
              }

              this.controlEnabledSlides(slideIndex);
              this.checkLoop(this.index);

              if (this.selectors) {
                this.selectors.enable(this.slides[slideIndex].UUID);

                if (this.slides[slideIndex].slideAvailable) {
                  this.selectors.activateCurrentItemByUUID(this.slides[slideIndex].UUID);
                }
              }

              this.sendEvent('enableItem', {
                slide: this.slides[slideIndex].api
              });
              this.checkSingleSlide();
              this.showHideArrows();
              this.showHideSelectors();
              result = true;
            }

            return result;
          }

          getSlidesByGroup(group) {
            let result = null;

            if (group) {
              result = [];
              this.slides.forEach(slide => {
                if (slide.belongsTo(group)) {
                  result.push(slide);
                }
              });
            }

            return result;
          }

          enableGroupOfSlides(group) {
            let result = false;
            const slides = this.getSlidesByGroup(group);

            if (slides && slides.length) {
              result = true;
              slides.forEach(slide => {
                this.enableSlide(slide.index);
              });
            }

            return result;
          }

          disableGroupOfSlides(group) {
            let result = false;
            const slides = this.getSlidesByGroup(group);

            if (slides && slides.length) {
              result = true;
              slides.forEach(slide => {
                this.disableSlide(slide.index);
              });
            }

            return result;
          }

          switchGroupOfSlides(group) {
            let result = false;

            if (group) {
              const slides = this.getItems({
                enabled: true
              });
              slides.forEach(slide => {
                if (!this.slides[slide.index].belongsTo(group)) {
                  this.disableSlide(slide.index);
                }
              });
              result = this.enableGroupOfSlides(group);
            }

            return result;
          }

          jump(direction, whoUse, fast, cIndex) {
            let result = false;
            let effect = this.option('slide.animation.type');
            let currentIndex = cIndex;
            const isContains = ['next', 'prev'].includes(direction);
            const l = this.slides.length;

            if (!this.effect || !this.enabledIndexesOfSlides.length || this.index === null) {
              return result;
            }

            if (currentIndex === $J.U) {
              currentIndex = this.index;
            }

            if (!isContains) {
              const res = this.findSlideIndex(direction);

              if (res >= 0) {
                direction = res;
              }
            }

            const index = helper.sliderLib.findIndex(direction, currentIndex, l, this.option('loop'));

            if (index === null) {
              return result;
            }

            if (this.index !== index) {
              if (!this.slides[index].enabled || !this.slides[index].slideAvailable) {
                if (isContains) {
                  result = this.jump(direction, whoUse, fast, index);
                }

                return result;
              }

              clearTimeout(this.autoplayTimer);

              if (!isContains) {
                if (index > this.index) {
                  direction = 'next';
                } else {
                  direction = 'prev';
                }
              }

              this.checkLoop(index);

              if (!effect || fast) {
                effect = 'blank';
              }

              if (this.selectors) {
                this.selectors.activateItem(index);
                this.selectors.jump(index);
              }

              this.effect.make({
                index: this.index,
                node: this.slides[this.index].node
              }, {
                index: index,
                node: this.slides[index].node
              }, {
                effect: effect,
                direction: direction
              }, {
                whoUse: whoUse
              });
              result = true;
            } else {
              this.slides[index].secondSelectorClick();
            }

            this.index = index;
            return result;
          }

          checkLoop(index) {
            if (this.arrows) {
              const l = this.enabledIndexesOfSlides.filter(indexSlide => {
                return !this.slides[indexSlide].selectorPinned && this.slides[indexSlide].slideAvailable;
              }).length;

              if (l < 2) {
                this.arrows.disable('backward');
                this.arrows.disable('forward');
              } else if (!this.option('loop')) {
                const newIndex = this.enabledIndexesOfSlides.indexOf(index);
                this.arrows.disable();

                if (newIndex === 0 || l === 1) {
                  this.arrows.disable('backward');
                }

                if (newIndex === l - 1 || l === 1) {
                  this.arrows.disable('forward');
                }
              } else {
                this.arrows.disable();
              }
            }
          }

          createFullscreenButton() {
            if (!this.option(FULLSCREEN + '.enable') || this.fullscreenButton) {
              return;
            }

            this.fullscreenButton = $J.$new('div').addClass(CSS_MAIN_CLASS + '-button').addClass(CSS_MAIN_CLASS + '-button-' + FULLSCREEN).addClass(STANDARD_BUTTON_CLASS);
            this.fullscreenButton.append($J.$new('div').addClass(CSS_MAIN_CLASS + '-icon'));

            if (this.slides[this.index].spinInited) {
              this.enableFullscreenButton();
              this.visibleFullscreenButton();
            } else {
              this.disableFullscreenButton();
              this.hideFullscreenButton();
            }

            this.fullscreenButton.addEvent(['btnclick', 'tap'], e => {
              e.stop();

              if (this.isFullscreen === globalVariables.FULLSCREEN.CLOSED || this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                this.disableFullscreenButton();
                this.hideFullscreenButton();

                if (this.isFullscreen === globalVariables.FULLSCREEN.CLOSED) {
                  this.enterFullScreen();
                } else {
                  this.exitFullScreen();
                }
              }
            });
            this.controlsWrapper.append(this.fullscreenButton);

            if (this.slides[this.index].slideReady) {
              setTimeout(() => {
                if (!this.slides[this.index].videoSlide || this.isFullscreenState()) {
                  this.enableFullscreenButton();
                  this.visibleFullscreenButton();
                }
              }, 0);
            }
          }

          visibleFullscreenButton() {
            if (this.fullscreenButton) {
              this.fullscreenButton.removeClass(FULLSCREEN_BUTTON_HIDE_CLASS);
            }
          }

          hideFullscreenButton() {
            if (this.fullscreenButton) {
              this.fullscreenButton.addClass(FULLSCREEN_BUTTON_HIDE_CLASS);
            }
          }

          enableFullscreenButton() {
            if (this.fullscreenButton) {
              this.fullscreenButton.removeAttr('disabled');
            }
          }

          disableFullscreenButton() {
            if (this.fullscreenButton) {
              this.fullscreenButton.attr('disabled', 'disabled');
            }
          }

          createEffect() {
            this.effect = new Effect({
              time: this.option('slide.animation.duration'),
              orientation: this.option('orientation')
            });
            this.effect.parentClass = this;
            this.on('effectStart', e => {
              e.stopAll();
              this.isMoving = true;
              this.disableFullscreenButton();

              if (this.slides[e.indexes[1]].videoSlide && this.isFullscreen !== globalVariables.FULLSCREEN.OPENED) {
                this.hideFullscreenButton();
              }

              this.slides[e.indexes[0]].beforeHide();
              this.slides[e.indexes[1]].beforeShow();

              if (e.data.callbackData.whoUse !== 4) {
                this.sendEvent('beforeSlideIn', {
                  slide: this.slides[e.indexes[1]].api
                });
                this.sendEvent('beforeSlideOut', {
                  slide: this.slides[e.indexes[0]].api
                });
              }
            });
            this.on('effectEnd', e => {
              e.stopAll();

              if (!this.slides[e.indexes[1]].videoSlide || this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                this.enableFullscreenButton();
                this.visibleFullscreenButton();
              }

              this.slides[e.indexes[0]].afterHide();
              this.slides[e.indexes[1]].afterShow(e.data.callbackData.whoUse);

              if (e.data.callbackData.whoUse !== 4) {
                this.sendEvent('afterSlideIn', {
                  slide: this.slides[e.indexes[1]].api
                });
                this.sendEvent('afterSlideOut', {
                  slide: this.slides[e.indexes[0]].api
                });
              }

              this.autoplay();
              this.isMoving = false;
              this.residualAutoplayTime = this.autoplayDelay;
            });
          }

          createArrows() {
            const option = this.option;

            if (!option('arrows')) {
              return;
            }

            this.arrows = new Arrows({
              orientation: option('orientation')
            });
            this.arrows.hide();
            this.arrows.parentClass = this;
            this.on('arrowAction', e => {
              e.stopAll(); // e.data.type === 'next' || 'prev'

              const index = this.getNextIndex(e.data.type, this.index, this.slides.length, this.option('loop'));
              this.jump(index, 2);
            });
            this.arrows.nodes.forEach(node => {
              this.controlsWrapper.append(node);
            });
          }

          getNextIndex(direction, index, length, loop) {
            const resultIndex = helper.sliderLib.findIndex(direction, index, length, loop);
            let result = resultIndex;

            if (resultIndex !== null && resultIndex !== this.index && (this.slides[resultIndex].selectorPinned || !this.slides[resultIndex].slideAvailable || !this.slides[resultIndex].enabled)) {
              result = this.getNextIndex(direction, resultIndex, length, loop);
            }

            return result;
          }

          isHiddenSlides() {
            return !this.slides.some(slide => {
              return !slide.customSelector || slide.customSelector && slide.slideAvailable;
            });
          }

          createSelectors() {
            const option = this.option;

            if (!option('thumbnails.enable') && !option('fullscreen.thumbnails.enable')) {
              this.isSelectorsReady = true;
              return;
            }

            this.selectors = new Selectors(this.slides.map(slide => slide.selectorData), {
              isStandardGrid: this.isStandardGrid,
              standardStyle: option('thumbnails.type'),
              standardSize: option('thumbnails.size'),
              standardPosition: option('thumbnails.enable') ? option('thumbnails.position') : false,
              standardWatermark: option('thumbnails.watermark'),
              isFullscreenGrid: this.isFullscreenGrid,
              fullscreenStyle: option('fullscreen.thumbnails.type'),
              fullscreenSize: option('fullscreen.thumbnails.size'),
              fullscreenPosition: option('fullscreen.thumbnails.enable') ? option('fullscreen.thumbnails.position') : false,
              fullscreenAutohide: option('fullscreen.thumbnails.autohide'),
              fullscreenWatermark: option('fullscreen.thumbnails.watermark'),
              arrows: option('arrows')
            });
            this.selectors.parentClass = this;
            this.on('selectorsReady', e => {
              e.stopAll();
              this.isSelectorsReady = true;
              this.postInitialization();
            });
            this.on('getSelectorProportion', e => {
              e.stopAll();
              const index = this.getSlideByUUID(e.data.UUID);

              if (index !== null) {
                const slide = this.slides[index];

                if (slide) {
                  const result = {
                    size: null,
                    isSirv: true
                  };
                  slide.getSelectorProportion().then(data => {
                    result.isSirv = slide.isSirvSelector();
                    result.size = data.size;
                    e.data.resultingCallback(result);
                  }).catch(err => {
                    result.isSirv = slide.isSirvSelector();
                    this.pickOut(err.UUID);
                    e.data.resultingCallback(result);
                  });
                } else {
                  e.data.resultingCallback(null);
                }
              } else {
                e.data.resultingCallback(null);
              }
            });
            this.on('getSelectorImgUrl', e => {
              e.stopAll();
              const index = this.getSlideByUUID(e.data.UUID);

              if (index !== null) {
                const slide = this.slides[index];

                if (slide) {
                  slide.getSelectorImgUrl(e.data.type, e.data.size, e.data.crop, e.data.watermark).then(result => {
                    e.data.resultingCallback({
                      src: result.src,
                      srcset: result.srcset,
                      size: result.size,
                      alt: result.alt,
                      referrerpolicy: result.referrerpolicy
                    });
                  }).catch(err => {
                    e.data.resultingCallback(null);
                  });
                } else {
                  e.data.resultingCallback(null);
                }
              } else {
                e.data.resultingCallback(null);
              }
            });
            this.on('changeSlide', e => {
              e.stopAll();
              const index = this.getSlideByUUID(e.data.UUID);

              if (index !== null) {
                const _tmp = this.option(FULLSCREEN + '.enable') && this.option(FULLSCREEN + '.always');

                if (this.slides[index].customSelector) {
                  this.sendEvent('thumbnailClick', {
                    slide: this.slides[index].api
                  });
                }

                this.jump(index, 2, _tmp);

                if (_tmp) {
                  this.enterFullScreen();
                }
              }
            });
            this.on('visibility', e => {
              e.stop();

              switch (e.action) {
                case 'show':
                  this.movingContainer.removeClass(CSS_MAIN_CLASS + '-selectors-closed');
                  break;

                case 'hide':
                  this.movingContainer.addClass(CSS_MAIN_CLASS + '-selectors-closed');
                  break;
                // no default
              }
            });
            this.on('selectorsDone', e => {
              e.stopAll();

              if (['left', 'right'].includes(this.selectors.currentStylePosition)) {
                this.onResize();
              }
            });
            this.selectorsWrapper.append(this.selectors.node);
            this.slides.forEach((slide, index) => {
              if (!slide.enabled) {
                this.selectors.disable(slide.UUID);
              }
            });
            this.showHideSelectors(true);
          }

          findSlide() {
            let dataSrc = this.instanceNode.attr('data-src');

            if (dataSrc) {
              let tmp;

              try {
                if (this.viewerFileContent) {
                  tmp = this.viewerFileContent;
                } else {
                  tmp = dataSrc.split('?')[0];
                  tmp = tmp.split('.');
                  tmp = tmp[tmp.length - 1];
                }
              } catch (e) {// empty
              }

              let node;

              if (tmp === 'spin' || helper.isVideo(dataSrc)) {
                node = $J.$new('div', {
                  'data-src': dataSrc
                });
                tmp = globalVariables.SLIDE.TYPES.SPIN;
              } else {
                if ([this.instanceNode.attr('data-type'), this.instanceNode.attr('data-effect')].includes('zoom')) {
                  tmp = globalVariables.SLIDE.TYPES.ZOOM;
                  node = $J.$new('div', {
                    'data-type': 'zoom',
                    'data-src': dataSrc
                  });
                } else {
                  tmp = globalVariables.SLIDE.TYPES.IMAGE;
                  node = $J.$new('img', {
                    'data-src': dataSrc
                  });
                }
              }

              if (this.viewerFileContent) {
                node.store('view-content', tmp);
              }

              this.instanceNode.append(node);
            } else {
              dataSrc = this.instanceNode.attr('data-bg-src');

              if (dataSrc) {
                this.instanceNode.append($J.$new('img', {
                  'data-src': dataSrc
                }));
              }
            }

            return this.getSlides(true);
          }

          canPinSlide(node) {
            const side = Slide.findPinnedSelectorSide(node);
            const pinnedSlides = this.slides.filter(slide => slide.pinnedSelectorSide === side);

            if (pinnedSlides.length < 3) {
              return true;
            }

            return false;
          }

          getSlideByUUID(uuid) {
            let result = null;

            for (let i = 0, l = this.slides.length; i < l; i++) {
              const slide = this.slides[i];

              if (slide.UUID === uuid) {
                result = i;
                break;
              }
            }

            return result;
          }

          pickOut(uuid) {
            const index = this.getSlideByUUID(uuid);

            if (index === null) {
              return;
            }

            this.removeSlide(index);

            if (!this.slides.length) {
              this.emit('destroy', {
                data: {
                  id: this.id,
                  node: this.instanceNode.node
                }
              });
              return;
            }

            if (this.slides.length < 2) {
              // clear selectors class and additional things
              if (this.option('thumbnails.enable') || this.option('fullscreen.thumbnails.enable')) {
                this.changeClasses(this.classes.standard, true);
                this.setContainerSize();
              }
            }

            if (!this.isToolStarted) {
              this.searchingOfProportions();
            }

            this.postInitialization();
          }

          getSlides(fromFindSlide) {
            let slides;

            if (fromFindSlide) {
              slides = Array.from(this.instanceNode.node.childNodes);
            } else {
              slides = Array.from(this.instanceNode.node.childNodes).filter(slide => {
                let result = false;
                this.sliderNodes.push(slide.cloneNode(true));

                if (slide.tagName && ['div', 'img', 'iframe', 'figure', 'video', 'picture', SELECTOR_TAG].includes($(slide).tagName)) {
                  result = true;
                }

                slide.parentNode.removeChild(slide);
                return result;
              });
              slides = slidePinnedFilter(slides);
            }

            let filteredSlides = slides.map(slide => Slide.parse(slide));
            globalFunctions.viewerFilters.forEach(callback => {
              let fs = [].concat(filteredSlides);
              fs = fs.map(s => {
                const r = {};
                Object.entries(s).forEach(item => {
                  if (item[0] === 'type') {
                    item[1] = globalVariables.SLIDE.NAMES[item[1]];
                  }

                  helper.createReadOnlyProp(r, ...item);
                });
                return r;
              });
              const result = callback(this.id, fs);

              if (Array.isArray(result)) {
                filteredSlides = result.map(s => {
                  let r = s;

                  for (let i = 0, l = filteredSlides.length; i < l; i++) {
                    if (s.node === filteredSlides[i].node) {
                      r = filteredSlides.splice(i, 1)[0];
                      break;
                    }
                  }

                  return r;
                });
              }
            });
            slides = filteredSlides;

            if (!fromFindSlide && !slides.length) {
              slides = this.findSlide();
            }

            slides = helper.sortSlidesByOrder(this.option('itemsOrder'), slides);
            return slides;
          }

          createSlides(slides) {
            let index = 0;
            slides.forEach(slide => {
              if (!Slide.isSirvComponent(slide.node) || Slide.hasComponent(slide.node)) {
                slide = $(slide.node);

                if (slide.tagName === SELECTOR_TAG) {
                  const div = $J.$new('div');

                  if (slide.attr('data-id')) {
                    div.attr('data-id', slide.attr('data-id'));
                  }

                  if (slide.attr('data-group')) {
                    div.attr('data-group', slide.attr('data-group'));
                  }

                  div.append(slide);
                  slide = div;
                }

                slide.addClass(CSS_MAIN_CLASS + '-component');

                const _slide = new Slide(slide.node, index, this.slideOptions);

                _slide.parentClass = this;
                this.slides.push(_slide);

                if (_slide.enabled && _slide.slideAvailable) {
                  this.enabledIndexesOfSlides.push(index);
                }

                index += 1;
              }
            });
            this.firstSlideAhead = this.enabledIndexesOfSlides.length > MAX_SLIDES_TO_CHANGE_PRELOAD_BEHAVIOR;
            this.enabledIndexesOfSlides.forEach((slideindex, i) => {
              if (!this.firstSlideAhead || i < MAX_SLIDES_TO_CHANGE_PRELOAD_BEHAVIOR) {
                this.slides[slideindex].startGettingInfo();
              }
            });

            if (this.index > this.slides.length - 1) {
              this.index = 0;
            }

            this.postInitialization();
          }

          checkSingleSlide() {
            const isSingle = this.enabledIndexesOfSlides.length === 1;
            this.enabledIndexesOfSlides.forEach(index => {
              this.slides[index].single(isSingle);
            });
          }

          showHideArrows() {
            if (this.arrows) {
              const visibleSlides = this.visibleSlides();

              if (visibleSlides < 2 || this.option(FULLSCREEN + '.always') && !this.isFullscreenState()) {
                this.arrows.hide();
              } else if (visibleSlides > 1 && (!this.option(FULLSCREEN + '.always') || this.isFullscreenState())) {
                this.arrows.show();
              }
            }
          }

          canShowSelectors(selectorCount) {
            const property = this.isFullscreen === globalVariables.FULLSCREEN.OPENED ? 'fullscreen.thumbnails.always' : 'thumbnails.always';
            return this.option(property) || selectorCount > 1;
          }

          showHideSelectors(force
          /* container size can be set faster than we can detect selector's visibility */
          ) {
            if (this.selectors) {
              if (!this.selectorsDebounce) {
                this.selectorsDebounce = helper.debounce(() => {
                  if (this.selectors) {
                    const canShow = this.canShowSelectors(this.enabledIndexesOfSlides.length);

                    if (canShow) {
                      if (!this.selectors.isSelectorsActionEnabled()) {
                        this.movingContainer.setCssProp('height', '100%');
                        this.selectorsWrapper.removeClass(CSS_MAIN_CLASS + '-hide-selectors');
                        this.selectors.enableActions();
                        this.onResize();
                      }
                    } else {
                      if (this.selectors.isSelectorsActionEnabled()) {
                        this.selectorsWrapper.addClass(CSS_MAIN_CLASS + '-hide-selectors');
                        this.selectors.disableActions();
                        this.onResize();
                      }
                    }
                  }
                }, force ? 0 : 32);
              }

              this.selectorsDebounce();
            }
          }

          getAvailableSlideIndex(startIndex) {
            if (startIndex === this.slides.length - 1 && !this.slides[startIndex].slideAvailable) {
              return -1;
            }

            if (this.slides[startIndex + 1].slideAvailable) {
              return startIndex + 1;
            }

            return this.getAvailableSlideIndex(startIndex + 1);
          }

          addAvailableSlideNode(slide, index) {
            const slideNode = slide.node;
            const l = this.slides.length;

            if (slide.slideAvailable) {
              if (l > 1 && index !== l - 1) {
                if (this.slides[index + 1].slideAvailable) {
                  this.slidesContainer.node.insertBefore(slideNode.node, this.slides[index + 1].node.node);
                } else {
                  const indexAvailableSlide = this.getAvailableSlideIndex(index);

                  if (indexAvailableSlide < 0) {
                    this.slidesContainer.append(slideNode);
                  } else {
                    this.slidesContainer.node.insertBefore(slideNode.node, this.slides[indexAvailableSlide].node.node);
                  }
                }
              } else {
                this.slidesContainer.append(slideNode);
              }
            }
          }

          sortItems(order) {
            if (!Array.isArray(order)) {
              order = this.option('itemsOrder');
            }

            if (!order.length) {
              return;
            }

            this.slides = helper.sortSlidesByOrder(order, this.slides);

            if (this.selectors) {
              this.selectors.sortSelectors(this.slides.map(slide => slide.UUID), order.length);
            }

            this.slides.forEach((slide, index) => {
              slide.newIndex = index;
            });

            for (let indexSlide = 0, l = this.slides.length; indexSlide < l; indexSlide++) {
              if (this.slides[indexSlide].slideActive) {
                this.index = this.slides[indexSlide].index;
                break;
              }
            }
          }

          insertSlide(indexOfSlide, htmlNodeSlide) {
            const pinnedNode = htmlNodeSlide.querySelector(SELECTOR_TAG) || htmlNodeSlide;

            if (Slide.findPinnedSelectorSide(pinnedNode) && !this.canPinSlide(pinnedNode)) {
              return false;
            }

            if (!$J.defined(indexOfSlide)) {
              indexOfSlide = this.slides.length + 1;
            }

            if ($J.typeOf(indexOfSlide) === 'number' && indexOfSlide >= 0 && htmlNodeSlide && (!Slide.isSirvComponent(htmlNodeSlide) || Slide.hasComponent(htmlNodeSlide))) {
              $(htmlNodeSlide).addClass(CSS_MAIN_CLASS + '-component');

              if (indexOfSlide > this.slides.length) {
                indexOfSlide = this.slides.length;
              }

              clearTimeout(this.timerRemove);
              const slide = new Slide(htmlNodeSlide, indexOfSlide, this.slideOptions, true);
              slide.parentClass = this;
              this.slides.splice(indexOfSlide, 0, slide);
              let nonIndex = this.index === null;

              if (this.index === null) {
                if (slide.enabled && slide.slideAvailable) {
                  // this.index = 0; // TODO check it
                  this.index = indexOfSlide;
                } else {
                  nonIndex = false;
                }
              } else if (indexOfSlide <= this.index) {
                this.index += 1;
              }

              this.enabledIndexesOfSlides = [];
              this.slides.forEach((_slide, index) => {
                _slide.newIndex = index;

                if (_slide.enabled) {
                  this.controlEnabledSlides(index);
                }
              });
              this.addAvailableSlideNode(slide, indexOfSlide);
              /*
                  new component for slider is needed css
              */

              this.addComponentsCSS();
              slide.appendToDOM(); // all elements need to be in dom

              slide.initVideoPlayer();
              slide.startGettingInfo();
              slide.loadThumbnail();
              slide.startFullInit(null);
              slide.startTool(this.index === indexOfSlide, this.firstSlideAhead ? false : this.option('slide.preload'), this.firstSlideAhead);
              slide.broadcast('inView', {
                data: this.isInView
              });

              if (this.index === indexOfSlide) {
                slide.loadContent();
                slide.beforeShow();
                slide.afterShow(globalVariables.SLIDE_SHOWN_BY.INIT);
              }

              if (this.isFullscreen === globalVariables.FULLSCREEN.OPENED && !slide.sirv) {
                slide.broadcast('before' + _FULLSCREEN + 'In', {
                  data: {
                    pseudo: this.isPseudo
                  }
                });
                slide.broadcast('after' + _FULLSCREEN + 'In', {
                  data: {
                    pseudo: this.isPseudo
                  }
                });
              }

              this.checkLoop(this.index);

              if (this.selectors) {
                this.selectors.insert(indexOfSlide, slide.selectorData);

                if (nonIndex) {
                  this.selectors.activateItem(this.index);
                }
              }

              this.checkSingleSlide();
              this.showHideSelectors();
              this.showHideArrows();
              return true;
            }

            return false;
          }

          removeSlide(indexOfSlide) {
            let flag = false;

            if ($J.typeOf(indexOfSlide) === 'string') {
              indexOfSlide = this.findSlideIndex(indexOfSlide);
            }

            if ($J.typeOf(indexOfSlide) === 'number' && indexOfSlide >= 0 && indexOfSlide < this.slides.length) {
              const slideUUID = this.slides[indexOfSlide].$J_UUID;

              if (this.slides[indexOfSlide].enabled) {
                this.disableSlide(indexOfSlide, true);
              } else {
                flag = true;
              }

              this.slides[indexOfSlide].destroy();
              this.slides.splice(indexOfSlide, 1);
              this.enabledIndexesOfSlides = [];
              this.slides.forEach((slide, index) => {
                slide.newIndex = index;

                if (slide.enabled) {
                  this.controlEnabledSlides(index);
                }
              });

              if (this.selectors) {
                this.selectors.pickOut(slideUUID);
              }

              if (this.index !== null && indexOfSlide <= this.index && this.index !== 0) {
                this.index -= 1;
              }

              if (flag) {
                this.checkSingleSlide();
              }

              if (this.isHiddenSlides()) {
                this.timerRemove = setTimeout(() => {
                  if (this.instanceNode) {
                    this.emit('destroy', {
                      data: {
                        id: this.id,
                        node: this.instanceNode.node
                      }
                    });
                  }
                }, 100);
              }

              return true;
            }

            return false;
          }

          createContextMenu() {
            const option = this.option;
            const contextmenuData = [];

            if (option('contextmenu.enable')) {
              if (option('contextmenu.text.zoom.in') || option('contextmenu.text.zoom.out')) {
                if (option('contextmenu.text.zoom.in')) {
                  contextmenuData.push({
                    id: 'zoomin',
                    label: option('contextmenu.text.zoom.in'),
                    hidden: false,
                    action: e => {
                      this.slides[this.index].zoomIn(e.left, e.top);
                    }
                  });
                }

                if (option('contextmenu.text.zoom.out')) {
                  contextmenuData.push({
                    id: 'zoomout',
                    label: option('contextmenu.text.zoom.out'),
                    disabled: true,
                    hidden: false,
                    action: e => {
                      this.slides[this.index].zoomOut(e.left, e.top);
                    }
                  });
                }
              }

              if (option(FULLSCREEN + '.enable') && (option('contextmenu.text.' + FULLSCREEN + '.enter') || option('contextmenu.text.' + FULLSCREEN + '.exit'))) {
                if (option('contextmenu.text.' + FULLSCREEN + '.enter')) {
                  // isExist
                  contextmenuData.push({
                    id: 'enter' + FULLSCREEN,
                    label: option('contextmenu.text.' + FULLSCREEN + '.enter'),
                    hidden: !option(FULLSCREEN + '.enable'),
                    action: () => {
                      this.enterFullScreen();
                    }
                  });
                }

                if (option('contextmenu.text.' + FULLSCREEN + '.exit')) {
                  contextmenuData.push({
                    id: 'exit' + FULLSCREEN,
                    label: option('contextmenu.text.' + FULLSCREEN + '.exit'),
                    hidden: true,
                    action: () => {
                      this.exitFullScreen();
                    }
                  });
                }
              }

              if (option('contextmenu.text.download')) {
                if (contextmenuData.length) {
                  contextmenuData.push({
                    id: 'sirv-separator',
                    hidden: false,
                    separator: true
                  });
                }

                contextmenuData.push({
                  id: 'download',
                  label: option('contextmenu.text.download'),
                  action: () => {
                    let dlw;
                    const url = this.slides[this.index].originImageUrl;

                    if (url) {
                      dlw = $J.$new('iframe').setCss({
                        width: 0,
                        height: 0,
                        display: 'none'
                      }).appendTo($J.D.node.body);
                      dlw.node.src = url + '?format=original&dl';
                    }
                  }
                });
              }

              this.movingContainer.addEvent('contextmenu', e => {
                let magnify;
                let canShow = false;
                let zoomData;
                let dl = true;
                let zoomMenu = false;
                let fullscreenMenu = false;
                let downloadMenu = false;
                const zoomin = 'zoomin';
                const zoomout = 'zoomout';
                const enterfullscreen = 'enter' + FULLSCREEN;
                const exitfullscreen = 'exit' + FULLSCREEN;
                e.stopDefaults();

                if (this.contextMenu && !this.isMoving && this.enabledIndexesOfSlides.length) {
                  const item = this.slides[this.index];
                  const typeOfSlide = item.typeOfSlide;
                  const t = globalVariables.SLIDE.TYPES;

                  if (this.isReady && item.isReady && item.sirv && typeOfSlide) {
                    const opts = item.options;

                    switch (typeOfSlide) {
                      case t.SPIN:
                        magnify = true;
                        break;

                      case t.ZOOM:
                        magnify = opts.mode === 'deep';
                        break;

                      case t.IMAGE:
                        break;

                      case t.VIDEO:
                        dl = false;
                        break;
                      // no default
                    }

                    if (magnify && this.slides[this.index].zoomSizeExist && (option('contextmenu.text.zoom.in') || option('contextmenu.text.zoom.out'))) {
                      zoomData = this.slides[this.index].zoomData;
                      this.contextMenu.showItem(zoomin);

                      if (zoomData.isZoomed && zoomData.zoom === 1) {
                        this.contextMenu.disableItem(zoomin);
                      } else {
                        this.contextMenu.enableItem(zoomin);
                      }

                      this.contextMenu.showItem(zoomout); // if (!zoomData.isZoomed || zoomData.zoom === 0) {

                      if (!zoomData.isZoomed) {
                        this.contextMenu.disableItem(zoomout);
                      } else {
                        this.contextMenu.enableItem(zoomout);
                      }

                      zoomMenu = true;
                    } else {
                      this.contextMenu.hideItem(zoomin);
                      this.contextMenu.hideItem(zoomout);
                    }

                    if (option(FULLSCREEN + '.enable')) {
                      if (this.isFullscreenState()) {
                        this.contextMenu.hideItem(enterfullscreen);

                        if (this.contextMenu.isExist(exitfullscreen)) {
                          this.contextMenu.showItem(exitfullscreen);

                          if (zoomData && zoomData.isZoomed) {
                            this.contextMenu.disableItem(exitfullscreen);
                          } else {
                            this.contextMenu.enableItem(exitfullscreen);
                          }

                          fullscreenMenu = true;
                        }
                      } else {
                        if (this.contextMenu.isExist(enterfullscreen)) {
                          this.contextMenu.showItem(enterfullscreen);

                          if (zoomData && zoomData.isZoomed) {
                            this.contextMenu.disableItem(enterfullscreen);
                          } else {
                            this.contextMenu.enableItem(enterfullscreen);
                          }

                          fullscreenMenu = true;
                        }

                        this.contextMenu.hideItem(exitfullscreen);
                      }
                    }

                    if (this.contextMenu.isExist('download') && dl) {
                      this.contextMenu.showItem('download');
                      downloadMenu = true;
                    } else {
                      this.contextMenu.hideItem('download');
                    }

                    if (zoomMenu || fullscreenMenu || downloadMenu) {
                      if ((zoomMenu || fullscreenMenu) && downloadMenu && typeOfSlide !== t.VIDEO) {
                        this.contextMenu.showItem('sirv-separator');
                      } else {
                        this.contextMenu.hideItem('sirv-separator');
                      }

                      canShow = true;
                      this.broadcast('stopContext');
                    }
                  }

                  this.contextMenu.canShow = canShow;
                }
              });

              if (contextmenuData.length && !$J.browser.mobile) {
                this.contextMenu = new ContextMenu(this.movingContainer, contextmenuData, 'sirv');

                if (option('fullscreen.enable')) {
                  this.contextMenu.fullScreenBox = this.fullScreenBox;
                }
              }
            } else {
              this.movingContainer.addEvent('contextmenu', e => {
                e.stop();
              });
            }
          }

          enterFullScreen() {
            if (this.isFullscreen !== globalVariables.FULLSCREEN.CLOSED) {
              return false;
            }

            this.addHistory();
            this.isFullscreen = globalVariables.FULLSCREEN.OPENING;
            this.fullscreenStartTime = +new Date();
            const isPseudo = !this.option('fullscreen.native') || !$J.browser.fullScreen.capable || !$J.browser.fullScreen.enabled();

            if (iPhoneSafariViewportRuler) {
              iPhoneSafariViewportRuler.appendTo($J.D.node.body);
            }

            this.disableFullscreenButton();
            this.hideFullscreenButton();

            if (this.selectors) {
              this.setClasses();

              if (this.option('fullscreen.thumbnails.enable')) {
                this.appendSelectors();
              }

              this.selectors.beforeEnterFullscreen();
            }

            this.slideWrapper.removeClass(globalVariables.CSS_CURSOR_FULSCREEN_ALWAYS);
            this.fullScreenBox.setCss({
              position: 'fixed',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              overflow: 'hidden',
              zIndex: 99999999999
            });
            this.boxSize = this.instanceNode.size;
            this.boxBoundaries = this.instanceNode.rect;
            this.fullScreenBox.append(this.movingContainer);
            $($J.D.node.body).append(this.fullScreenBox);
            this.movingContainer.setCssProp('height', '100%');
            this.broadcast('before' + _FULLSCREEN + 'In', {
              data: {
                pseudo: isPseudo
              }
            });
            this.slideWrapper.setCssProp('height', '');

            if (ProductDetail && this.productDetail) {
              this.productDetail.open();
            }

            $J.browser.fullScreen.request(this.fullScreenBox, {
              windowFullscreen: !this.option('fullscreen.native'),
              onEnter: this.onEnteredFullScreen.bind(this),
              // onExit: this.onExitFullScreen.bind(this),
              onExit: () => {
                if ([globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.OPENING].includes(this.isFullscreen)) {
                  return;
                }

                this.isFullscreen = globalVariables.FULLSCREEN.CLOSING;

                this._beforeExitFullscreen();

                this.broadcast('before' + _FULLSCREEN + 'Out', {
                  data: {
                    pseudo: false
                  }
                });
                this.onExitFullScreen();
              },
              fallback: () => {
                const rootTag = $J.D.node.getElementsByTagName('html')[0];
                $(rootTag).addClass(PSEUDO_FULLSCREEN_CLASS); // eslint-disable-next-line no-unused-vars

                $(document.body).render();
                setTimeout(() => this.onEnteredFullScreen(true), 64); // const fullSize = $J.D.size;
                // const scrolls = $J.W.scroll;
                // // const docFullSize = $($J.D).fullSize;
                // const rootTag = $J.D.node.getElementsByTagName('html')[0];
                // $(rootTag).addClass(PSEUDO_FULLSCREEN_CLASS);
                // let top = 0 + scrolls.y;
                // // Properly handle iPhone Safari (>10) address bar, bookmark bar and status bar
                // // if (isHandset && $J.browser.platform === 'ios' && $J.browser.uaName === 'safari' && parseInt($J.browser.uaVersion, 10) > 10) {
                // if (iPhoneSafariViewportRuler) {
                //     top = Math.abs(iPhoneSafariViewportRuler.node.getBoundingClientRect().top);
                //     // this.expandBox.setCss({ height: window.innerHeight, maxHeight: '100vh', top: Math.abs(iPhoneSafariViewportRuler,node.getBoundingClientRect().top) });
                // }
                // if (!this.fullScreenFX) {
                //     this.fullScreenFX = new $J.FX(this.fullScreenBox, {
                //         duration: 1,
                //         transition: $J.FX.getTransition().expoOut,
                //         onStart: () => {
                //             this.fullScreenBox.setCss({
                //                 width: this.boxSize.width,
                //                 height: this.boxSize.height,
                //                 top: this.boxBoundaries.top,
                //                 left: this.boxBoundaries.left
                //             }).appendTo($J.D.node.body);
                //         },
                //         onAfterRender: () => {},
                //         onComplete: () => {
                //             this.onEnteredFullScreen(true);
                //             this.fullScreenFX = null;
                //         }
                //     });
                // }
                // this.fullScreenFX.start({
                //     width:  [this.boxSize.width, fullSize.width],
                //     height: [this.boxSize.height, fullSize.height],
                //     // top:    [this.boxBoundaries.top, 0 + scrolls.y],
                //     top:    [this.boxBoundaries.top, top],
                //     left:   [this.boxBoundaries.left, 0 + scrolls.x],
                //     opacity: [0, 1]
                // });
              }
            });
            return true;
          }

          onEnteredFullScreen(pseudo) {
            if (this.isFullscreen !== globalVariables.FULLSCREEN.OPENING) {
              return;
            }

            this.isPseudo = pseudo; // the variable is necessary for custom inserting slide

            if (pseudo && this.isFullscreen === globalVariables.FULLSCREEN.OPENING) {
              this.fullScreenBox.setCss({
                top: iPhoneSafariViewportRuler ? Math.abs(iPhoneSafariViewportRuler.node.getBoundingClientRect().top) : 0,
                left: 0,
                right: 0,
                bottom: 0,
                width: 'auto',
                height: iPhoneSafariViewportRuler ? $J.W.node.innerHeight : 'auto',
                display: this.productDetail ? 'flex' : 'block',
                position: 'fixed'
              }); // if (iPhoneSafariViewportRuler) {
              //     this.fullScreenBox.setCss({ height: $J.W.node.innerHeight, top: Math.abs(iPhoneSafariViewportRuler.node.getBoundingClientRect().top) });
              // }

              $J.D.addEvent('keydown', this.pseudoFSEvent);
            }

            this.isFullscreen = globalVariables.FULLSCREEN.OPENED;

            if (this.fullscreenButton) {
              this.fullscreenButton.removeClass(STANDARD_BUTTON_CLASS);
              this.fullscreenButton.addClass(FULLSCREEN_BUTTON_CLASS);

              if (!this.slides[this.index] || !this.slides[this.index].videoSlide || this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                setTimeout(() => {
                  this.enableFullscreenButton();
                  this.visibleFullscreenButton();
                }, 1);
              }
            }

            if (this.selectors) {
              this.selectors.afterEnterFullscreen();
            }

            if (this.slides.length > 1) {
              $J.D.addEvent('keyup', this.keyBoardArrowsCallback);
            }

            this.showHideArrows();
            this.showHideSelectors();
            this.broadcast('after' + _FULLSCREEN + 'In', {
              data: {
                pseudo: pseudo
              }
            });
            this.onResize();
            let eventData = {};

            if (this.enabledIndexesOfSlides.length) {
              eventData = {
                slide: this.slides[this.index].api
              };
            }

            this.sendEvent(FULLSCREEN + 'In', eventData);
          }

          _beforeExitFullscreen() {
            this.disableFullscreenButton();
            this.hideFullscreenButton();

            if (this.option(FULLSCREEN + '.always')) {
              this.slideWrapper.addClass(globalVariables.CSS_CURSOR_FULSCREEN_ALWAYS);
            }

            if (this.selectors) {
              if (this.option('fullscreen.thumbnails.enable')) {
                this.appendSelectors();
              }

              this.setClasses();
              this.selectors.beforeExitFullscreen();
            }

            if (ProductDetail && this.productDetail) {
              this.productDetail.close();
            }
          }

          exitFullScreen() {
            if (this.isFullscreen !== globalVariables.FULLSCREEN.OPENED) {
              return false;
            }

            this.isFullscreen = globalVariables.FULLSCREEN.CLOSING;

            this._beforeExitFullscreen();

            if (iPhoneSafariViewportRuler) {
              iPhoneSafariViewportRuler.remove();
            }

            if ($J.browser.fullScreen.capable && $J.browser.fullScreen.enabled() && this.option('fullscreen.native')) {
              this.broadcast('before' + _FULLSCREEN + 'Out', {
                data: {
                  pseudo: false
                }
              });
              $J.browser.fullScreen.cancel.call(document);
            } else {
              const rootTag = $J.D.node.getElementsByTagName('html')[0];
              $(rootTag).removeClass(PSEUDO_FULLSCREEN_CLASS);
              this.broadcast('before' + _FULLSCREEN + 'Out', {
                data: {
                  pseudo: true
                }
              });
              this.onExitFullScreen(true); // const fullSize = this.fullScreenBox.size;
              // const fsBoxBoundaries = this.fullScreenBox.rect;
              // const rootTag = $J.D.node.getElementsByTagName('html')[0];
              // $(rootTag).removeClass(PSEUDO_FULLSCREEN_CLASS);
              // this.broadcast('before' + _FULLSCREEN + 'Out', { data: { pseudo: true } });
              // if (!this.fullScreenExitFX) {
              //     this.fullScreenExitFX = new $J.FX(this.fullScreenBox, {
              //         duration: 1,
              //         transition: $J.FX.getTransition().expoOut,
              //         onStart: () => {
              //             $($J.D).removeEvent('keydown', this.pseudoFSEvent);
              //             this.fullScreenBox.setCss({ position: 'absolute' });
              //         },
              //         onAfterRender: () => {},
              //         onComplete: () => {
              //             this.onExitFullScreen(true);
              //             this.fullScreenExitFX = null;
              //         }
              //     });
              // }
              // this.fullScreenExitFX.start({
              //     width:  [fullSize.width, this.boxSize.width],
              //     height: [fullSize.height, this.boxSize.height],
              //     top:    [0 + fsBoxBoundaries.top, this.boxBoundaries.top],
              //     left:   [0 + fsBoxBoundaries.left, this.boxBoundaries.left],
              //     opacity: [1, 0.5]
              // });
            }

            return true;
          }

          onExitFullScreen(pseudo) {
            if ([globalVariables.FULLSCREEN.CLOSED, globalVariables.FULLSCREEN.OPENING].includes(this.isFullscreen)) {
              return;
            }

            $J.D.removeEvent('keyup', this.keyBoardArrowsCallback);
            this.showHideArrows();
            this.showHideSelectors();
            this.instanceNode.append(this.movingContainer);
            this.fullScreenBox.remove();

            if (this.fullscreenButton) {
              this.fullscreenButton.removeClass(FULLSCREEN_BUTTON_CLASS);
              this.fullscreenButton.addClass(STANDARD_BUTTON_CLASS);

              if (!this.slides[this.index] || !this.slides[this.index].videoSlide || this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                setTimeout(() => {
                  this.enableFullscreenButton();
                  this.visibleFullscreenButton();
                }, 1);
              }
            }

            if (this.doHistory) {
              // If close initiated not by the Back button
              const urlHash = '#sirv-viewer-' + this.fullscreenViewId;

              try {
                if ($J.W.node.location.hash === urlHash) {
                  $J.W.node.history.back();
                }
              } catch (e) {// empty
              }
            }

            this.isFullscreen = globalVariables.FULLSCREEN.CLOSED;
            this.isPseudo = false;

            if (this.selectors) {
              this.selectors.afterExitFullscreen();
            }
            /*
                this.setContainerSize(); - it must be under this.isFullscreen = globalVariables.FULLSCREEN.CLOSED; and this.selectors.afterExitFullscreen();
                because after exit from fullscreen with this options:
                {
                    thumbnails: {
                        enable: true,
                        position: 'bottom'
                    },
                     fullscreen: {
                        thumbnails: {
                            enable: false
                        },
                    }
                }
                slider container is got wrong size
            */


            this.setContainerSize(); // this.sendStats(FULLSCREEN + 'Close', { duration: +new Date() - this.fullscreenStartTime });

            this.fullscreenStartTime = null;
            this.broadcast('after' + _FULLSCREEN + 'Out', {
              data: {
                pseudo: pseudo
              }
            });
            let eventData = {};

            if (this.enabledIndexesOfSlides.length) {
              eventData = {
                slide: this.slides[this.index].api
              };
            }

            this.sendEvent(FULLSCREEN + 'Out', eventData);
            this.onResize();
          }

          getSlide(index) {
            if (index === null || $J.typeOf(index) === 'number' && index >= this.slides.length) {
              index = this.index;
            }

            if ($J.typeOf(index) === 'string') {
              index = this.findSlideIndex(index);
            }

            return this.slides[index]?.api;
          }

          onResizeWithoutSelectors() {
            if (!this.destroyed) {
              // Properly handle address bar and status bar on iPhone
              // if (isHandset && $J.browser.platform === 'ios' && $J.browser.uaName === 'safari' && parseInt($J.browser.uaVersion, 10) > 10) {
              if (iPhoneSafariViewportRuler && this.isFullscreen === globalVariables.FULLSCREEN.OPENED) {
                // this.fullScreenBox.setCss({ top: Math.abs(iPhoneSafariViewportRuler.node.getBoundingClientRect().top) });
                this.fullScreenBox.setCss({
                  height: $J.W.node.innerHeight,
                  top: Math.abs(iPhoneSafariViewportRuler.node.getBoundingClientRect().top)
                });
              }

              this.setRootMargin();
              this.setContainerSize();
              this.slides.forEach(slide => {
                slide.resize();
              });
            }
          }

          onResize() {
            if (this.destroyed) {
              return;
            } // this.setContainerSize();


            if (this.selectors) {
              this.selectors.onResize();
            }

            this.onResizeDebounce();
          }

          play(delay) {
            let result = false;
            let currentDelay = this.option('slide.delay');

            if ($J.defined(delay) && $J.typeOf(delay) === 'number' && delay > 9
            /* 9 is min delay */
            ) {
                currentDelay = delay;
              }

            if (this.autoplayTimer === null && !this.isAutoplay || currentDelay !== this.autoplayDelay) {
              this.autoplayDelay = currentDelay;
              this.isAutoplay = true;
              this.residualAutoplayTime = this.autoplayDelay;
              this.autoplay();
              result = true;
            }

            return result;
          }

          pause() {
            const result = this.autoplayTimer;
            this.isAutoplay = false;
            clearTimeout(this.autoplayTimer);
            this.autoplayTimer = null;
            this.residualAutoplayTime = this.autoplayDelay;
            return result === null;
          }

          pauseAutoplay() {
            clearTimeout(this.autoplayTimer);
            this.autoplayTimer = null;
            this.residualAutoplayTime -= +new Date() - this.currentAutoplayTime;
          }

          autoplay() {
            if (this.isAutoplay) {
              this.currentAutoplayTime = +new Date();
              let delay = this.autoplayDelay;

              if (this.residualAutoplayTime !== delay) {
                if (this.residualAutoplayTime < MIN_AUTOPLAY) {
                  delay = MIN_AUTOPLAY;
                } else {
                  delay = this.residualAutoplayTime;
                }
              }

              clearTimeout(this.autoplayTimer);
              this.autoplayTimer = setTimeout(() => {
                if (!this.destroyed) {
                  this.jump('next', globalVariables.SLIDE_SHOWN_BY.AUTOPLAY);
                }
              }, delay);
            }
          }

          destroy() {
            this.destroyed = true;
            this.onResizeDebounce.cancel();
            this.onResizeDebounce = null;
            clearTimeout(this.autoplayTimer);
            this.autoplayTimer = null;

            if (this.selectorsDebounce) {
              this.selectorsDebounce.cancel();
              this.selectorsDebounce = null;
            }

            $($J.W).removeEvent('resize', this.onResizeHandler);
            this.onResizeHandler = null;
            $($J.D).removeEvent('keyup', this.keyBoardArrowsCallback);

            if (this.inViewModule) {
              this.inViewModule.disconnect();
              this.inViewModule = null;
            }

            if (this.doHistory) {
              $($J.W).removeEvent('popstate', this.onHistoryStateChange);
              globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.splice(globalVariables.FULLSCREEN_VIEWERS_IDs_ARRAY.indexOf(this.fullscreenViewId), 1);
            }

            this.movingContainer.removeEvent('mouseout');
            this.slideWrapper.removeClass(globalVariables.CSS_CURSOR_FULSCREEN_ALWAYS);

            if (this.clearingTouchdragFunction) {
              this.clearingTouchdragFunction();
            }

            this.slidesContainer.removeEvent('touchdrag');

            if (isCustomId(this.id)) {
              this.instanceNode.removeAttr('id');
            }

            if (this.contextMenu) {
              this.movingContainer.removeEvent('contextmenu');
              this.contextMenu.destroy();
              this.contextMenu = null;
            }

            if (this.productDetail) {
              this.productDetail.destroy();
              this.productDetail = null;
            }

            if (this.fullscreenButton) {
              this.fullscreenButton.removeEvent(['btnclick', 'tap']);
              this.fullscreenButton.remove();
            }

            this.fullscreenButton = null;

            if (this.effect) {
              this.effect.destroy();
              this.effect = null;
              this.on('effectStart');
              this.on('effectEnd');
            }

            if (this.arrows) {
              this.arrows.destroy();
              this.arrows = null;
              this.off('arrowAction');
            }

            if (this.selectors) {
              this.selectors.destroy();
              this.selectors = null;
              this.off('visibility');
              this.off('changeSlide');
              this.off('selectorsReady');
              this.off('getSelectorImgUrl');
              this.off('selectorsDone');
              this.off('getSelectorProportion');
            }

            this.off('componentEvent');
            this.off('goTo' + _FULLSCREEN);
            this.off('goTo' + _FULLSCREEN + 'Out');
            this.off('infoReady');
            this.off('slideVideoPlay');
            this.off('slideVideoPause');
            this.off('slideVideoEnd');
            this.slides.forEach(slide => {
              const node = slide.originNode;
              $(node).removeClass(CSS_MAIN_CLASS + '-component');
              slide.destroy();
            });
            this.slides = [];
            this.off('stats');
            this.sliderNodes.forEach(node => this.instanceNode.append(node));
            this.sliderNodes = [];
            $($J.D).removeEvent('keydown', this.pseudoFSEvent);
            this.pseudoFSEvent = null;
            $($J.D).removeEvent('keyup', this.keyBoardArrowsCallback);
            this.keyBoardArrowsCallback = null;
            this.fullScreenBox.remove();
            this.fullScreenBox = null;
            this.controlsWrapper.remove();
            this.controlsWrapper = null;
            this.slidesContainer.remove();
            this.slidesContainer = null;
            this.selectorsWrapper.remove();
            this.selectorsWrapper = null;
            this.slideWrapper.remove();
            this.slideWrapper = null;
            this.movingContainer.remove();
            this.movingContainer = null;
            this.isReady = false;
            this.doSetSize = false;
            this.instanceNode = null;
            this.externalContainer = null;
            super.destroy();
          }

        }

        return Slider;
      })();
      /* eslint-env es6 */

      /* global defaultOptions, SirvSlider, EventEmitter, $, $J, globalFunctions, SliderBuilder, Promise, SELECTOR_TAG */

      /* eslint-disable dot-notation */

      /* eslint-disable no-use-before-define */

      /* eslint quote-props: ["error", "as-needed", { "keywords": true, "unnecessary": false }] */

      /* eslint no-unused-vars: ["error", { "args": "none", "varsIgnorePattern": "Slider" }] */


      const Slider = (() => {
        const checkArgument = value => {
          if ($J.typeOf(value) !== 'number' && $J.typeOf(value) !== 'string') {
            value = null;
          }

          return value;
        };

        const clearPrivateOptions = obj => {
          Object.entries(obj).forEach(([key, value]) => {
            value = $(value.split(';'));

            if (value.length) {
              if (value[value.length - 1] === '') {
                value.splice(value.length - 1, 1);
              }

              value = value.map(_value => {
                return _value.replace(new RegExp('^' + key + '\\.'), '');
              });
              obj[key] = value.join(';');
            }
          });
          return obj;
        };

        const getOptions = (source, opt) => {
          const optType = $J.typeOf(opt);
          let value;
          let result = null;

          if (optType === 'string') {
            result = source[opt];
          } else if (optType === 'array') {
            value = opt.shift();

            if (source[value]) {
              if (opt.length) {
                result = getOptions(source[value], opt);
              } else {
                result = source[value];
              }
            }
          }

          return result;
        };

        const getOptionsByType = (options, oType, def) => {
          return {
            common: getOptions(options.common, oType) || def,
            mobile: getOptions(options.mobile, oType) || def
          };
        };

        const removeProperties = obj => {
          const rm = _obj => {
            ['spin', 'zoom', 'image', 'video'].forEach(v => {
              if (_obj[v]) {
                delete _obj[v];
              }
            });
          };

          rm(obj.common);
          rm(obj.mobile);
        };

        class Slider_ extends EventEmitter {
          constructor(node, options, force, lazyInit) {
            super();
            this.node = node;
            this.slider = null;
            this.lazyInit = lazyInit;
            this.options = {};
            this.spinOptions = {};
            this.zoomOptions = {};
            this.imageOptions = {};
            this.videoOptions = {};
            this.sliderBuilder = new SliderBuilder(options, this.node);
            this.parseOptions(options);
            this.privateOptions = {
              common: {},
              mobile: {}
            };
            this.toolOptions = null;
            this.inViewTimer = null;
            this.isRun = false;
            this.api = {
              isReady: this.isReady.bind(this),
              // start: this.start.bind(this),
              // stop: this.stop.bind(this),
              items: this.items.bind(this),
              disableItem: this.disableItem.bind(this),
              enableItem: this.enableItem.bind(this),
              enableGroup: this.enableGroup.bind(this),
              disableGroup: this.disableGroup.bind(this),
              switchGroup: this.switchGroup.bind(this),
              insertItem: this.insertItem.bind(this),
              removeItem: this.removeItem.bind(this),
              removeAllItems: this.removeAllItems.bind(this),
              jump: this.jump.bind(this),
              itemsCount: this.itemsCount.bind(this),
              next: this.next.bind(this),
              prev: this.prev.bind(this),
              isFullscreen: this.isFullscreen.bind(this),
              fullscreen: this.fullscreen.bind(this),
              child: this.child.bind(this),
              play: this.play.bind(this),
              pause: this.pause.bind(this),
              sortItems: this.sortItems.bind(this)
            };
            this.on('viewerPublicEvent', e => {
              Object.assign(e.data.slider, this.api);

              if (e.data.slide) {
                e.data.slide.parent = () => {
                  return this.api;
                };

                if (e.data.slide[e.data.slide.component]) {
                  e.data.slide[e.data.slide.component].parent = () => {
                    return e.data.slide;
                  };
                }
              }
            });
            this.makeOptions();
            const as = this.toolOptions.get('autostart');

            if (as && as !== 'off' || force) {
              this.run();
            }
          }

          parseOptions(options) {
            const viewer = 'viewer';
            const spin = 'spin';
            const zoom = 'zoom';
            const image = 'image';
            const video = 'video';
            const common = options.common;
            const mobile = options.mobile;
            this.options = getOptionsByType(options, viewer, {});
            this.spinOptions = {
              common: getOptions(common, [viewer, spin]) || getOptions(common, spin) || {},
              mobile: getOptions(mobile, [viewer, spin]) || getOptions(mobile, spin) || {}
            };
            this.zoomOptions = {
              common: getOptions(common, [viewer, zoom]) || getOptions(common, zoom) || {},
              mobile: getOptions(mobile, [viewer, zoom]) || getOptions(mobile, zoom) || {}
            };
            this.imageOptions = {
              common: getOptions(common, [viewer, image]) || getOptions(common, image) || {},
              mobile: getOptions(mobile, [viewer, image]) || getOptions(mobile, image) || {}
            };
            this.videoOptions = {
              common: getOptions(common, [viewer, video]) || getOptions(common, video) || {},
              mobile: getOptions(mobile, [viewer, video]) || getOptions(mobile, video) || {}
            };
            removeProperties(this.options);
          }

          getSlideOptions() {
            const spin = getOptionsByType(this.privateOptions, 'spin', '');
            const zoom = getOptionsByType(this.privateOptions, 'zoom', '');
            const image = getOptionsByType(this.privateOptions, 'image', '');
            const video = getOptionsByType(this.privateOptions, 'video', '');
            return {
              spin: {
                common: this.spinOptions,
                local: spin
              },
              zoom: {
                common: this.zoomOptions,
                local: zoom
              },
              image: {
                common: this.imageOptions,
                local: image
              },
              video: {
                common: this.videoOptions,
                local: video
              }
            };
          }

          makeOptions() {
            const exclude = {
              spin: /^spin/,
              zoom: /^zoom/,
              image: /^image/,
              video: /^video/
            };
            this.toolOptions = new $J.Options(defaultOptions);
            this.toolOptions.fromJSON(this.options.common);
            this.privateOptions.common = this.toolOptions.fromString(this.node.attr('data-options') || '', exclude);
            this.privateOptions.common = clearPrivateOptions(this.privateOptions.common);

            if ($J.browser.touchScreen && $J.browser.mobile) {
              this.toolOptions.fromJSON(this.options.mobile);
              this.privateOptions.mobile = this.toolOptions.fromString(this.node.attr('data-mobile-options') || '', exclude);
              this.privateOptions.mobile = clearPrivateOptions(this.privateOptions.mobile);
            }
          }

          createSlider(content) {
            this.slider = new SirvSlider(this.node, {
              options: this.toolOptions,
              slideOptions: this.getSlideOptions(),
              lazyInit: this.lazyInit,
              viewerFileContent: content
            });
            this.slider.parentClass = this;
            this.api.id = this.slider.id;
          }

          run(force) {
            this.isRun = true;
            this.sliderBuilder.getOptions().then(data => {
              this.parseOptions(data.dataOptions);

              if (force) {
                this.makeOptions();
              }

              if (data.content) {
                this.createSlider(data.content);
              } else {
                this.sliderBuilder.buildViewer().then(data2 => {
                  this.node = data2.mainNode;
                  this.createSlider();
                });
              }
            }).catch(error => {
              // eslint-disable-next-line no-console
              console.log('Sirv: cannot get view from ' + error.error);
            });
            return true;
          }

          isReady() {
            let result = false;

            if (this.slider) {
              result = this.slider.isReady;
            }

            return result;
          }

          isFullscreen() {
            let result = false;

            if (this.isReady()) {
              result = this.slider.isFullscreen === 2;
            }

            return result;
          }

          startFullInit(options, force, lazyInit) {
            let as;

            if (this.slider) {
              this.lazyInit = lazyInit;
              this.parseOptions(options);
              this.makeOptions();
              as = this.toolOptions.get('autostart');

              if (as && as !== 'off' || force) {
                this.slider.startFullInit({
                  options: this.toolOptions,
                  slideOptions: this.getSlideOptions(),
                  lazyInit: this.lazyInit
                });
              }
            }
          }

          start() {
            let result = false;

            if (!this.slider) {
              result = this.run(true);
            }

            return result;
          }

          stop() {
            let result = false;

            if (this.slider) {
              result = true;
              this.slider.destroy();
              this.slider = null;
              this.off('viewerPublicEvent');
              this.isRun = false;
              this.sliderBuilder.destroy();
              this.sliderBuilder = null;
              this.destroy();
            }

            return result;
          }

          insertItem(htmlSlide, indexOfSlide) {
            let result = false;

            if (this.isReady()) {
              if ($J.typeOf(htmlSlide) === 'string') {
                const div = $J.$new('div');
                div.node.innerHTML = htmlSlide.trim();
                htmlSlide = div.node.firstChild;

                if (htmlSlide && (htmlSlide.nodeType === 3 || htmlSlide.nodeType === 8 || !['div', 'img', SELECTOR_TAG].includes($(htmlSlide).tagName))) {
                  htmlSlide = null;
                }
              } else if ($(htmlSlide).tagName === SELECTOR_TAG) {
                const div = $J.$new('div');
                div.append(htmlSlide);
                htmlSlide = div.node;
              }

              result = this.slider.insertSlide(indexOfSlide, htmlSlide);
            }

            return result;
          }

          removeItem(indexOfSlide) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.removeSlide(indexOfSlide);
            }

            return result;
          }

          removeAllItems() {
            let result = true;

            if (this.isReady()) {
              for (let i = this.itemsCount() - 1; i >= 0; i--) {
                const r = this.removeItem(i);

                if (result) {
                  result = r;
                }
              }
            } else {
              result = false;
            }

            return result;
          }

          itemsCount(settings) {
            let result = 0;

            if (this.isReady()) {
              const items = this.items(settings);

              if (items !== null) {
                result = items.length;
              }
            }

            return result;
          }

          items(settings) {
            let result = null;

            if (this.isReady()) {
              result = this.slider.getItems(settings);
              result.forEach(item => {
                item.parent = () => {
                  return this.api;
                };
              });
            }

            return result;
          }

          disableItem(indexOfSlide) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.disableSlide(indexOfSlide);
            }

            return result;
          }

          enableItem(indexOfSlide) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.enableSlide(indexOfSlide);
            }

            return result;
          }

          enableGroup(group) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.enableGroupOfSlides(group);
            }

            return result;
          }

          disableGroup(group) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.disableGroupOfSlides(group);
            }

            return result;
          }

          switchGroup(group) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.switchGroupOfSlides(group);
            }

            return result;
          }

          jump(indexOfSlide) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.jump(indexOfSlide);
            }

            return result;
          }

          next() {
            let result = false;

            if (this.isReady()) {
              result = this.slider.jump('next');
            }

            return result;
          }

          prev() {
            let result = false;

            if (this.isReady()) {
              result = this.slider.jump('prev');
            }

            return result;
          }

          fullscreen() {
            let result = false;

            if (this.isReady()) {
              if (this.isFullscreen()) {
                result = this.slider.exitFullScreen();
              } else {
                result = this.slider.enterFullScreen();
              }
            }

            return result;
          }

          child(numberOfSlide) {
            let result = null;

            if (this.isReady()) {
              numberOfSlide = checkArgument(numberOfSlide);
              result = this.slider.getSlide(numberOfSlide);

              if (result) {
                result.parent = () => {
                  return this.api;
                };
              }
            }

            return result;
          }

          play(delay) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.play(delay);
            }

            return result;
          }

          pause() {
            let result = false;

            if (this.isReady()) {
              result = this.slider.pause();
            }

            return result;
          }

          sortItems(order) {
            if (this.isReady()) {
              this.slider.sortItems(order);
            }
          }

          isEqual(node) {
            return node === this.node;
          }

          checkReadiness(eventname, component) {
            let result = false;

            if (this.isReady()) {
              result = this.slider.checkReadiness(eventname, component);
            }

            return result;
          }

          sendEvent(eventname, component) {
            if (this.isReady()) {
              this.slider.sendReadyEvent(eventname, component);
            }
          }

        }

        return Slider_;
      })();

      return Slider;
    });
    /* eslint-env es6 */

    /* global helper */

    /* global LazyImage */

    /* global EventManager */

    /* global Slider */

    /* eslint-disable indent */

    /* eslint no-template-curly-in-string: "off" */

    /* eslint-disable dot-notation */

    /* eslint-disable no-use-before-define */

    /* eslint-disable no-lonely-if */

    /* eslint-disable no-case-declarations */

    /* eslint-disable no-global-assign */

    const w = window;
    const _Sirv = {
      items: {},
      eventManager: null,
      options: {}
    };
    const isLazyImage = true; // TODO

    const baseModules = ['magicJS', 'globalVariables', 'globalFunctions', 'EventManager', 'helper', 'Slider'];

    if (isLazyImage) {
      baseModules.push('LazyImage');
    }

    w.Sirv.require(baseModules, (magicJS, globalVariables, globalFunctions, EventManager, helper, Slider, LazyImage) => {
      const $J = magicJS; // eslint-disable-next-line

      const $ = $J;

      const getQuerySelector = (qSelector, context) => {
        let result = qSelector;

        if ($J.typeOf(result) === 'string') {
          result = (context || document).querySelector(result);
        }

        return $J.$(result);
      };

      const findSirvItem = (qSelector, type, context) => {
        let t = [];
        let a = null;
        const storage = _Sirv.items[type];

        if (storage.length && qSelector) {
          a = getQuerySelector(qSelector, context);

          if (a) {
            t = storage.filter(_ => {
              // return _.isEqual(a); // TODO ?????
              return _.node === a;
            });
          }
        }

        return t.length ? t[0] : null;
      };

      const getShadowDOM = node => {
        let result = false;
        const parent = node.parentNode;

        if (parent) {
          if (parent instanceof ShadowRoot) {
            result = parent;
          } else {
            result = getShadowDOM(parent);
          }
        }

        return result;
      };

      const getNodes = (qSelectorAll, from) => {
        let result;

        if (!from) {
          from = document;
        }

        if ($J.typeOf(qSelectorAll) === 'collection') {
          result = qSelectorAll;
        } else if (['element', 'magicjs-element'].includes($J.typeOf(qSelectorAll))) {
          result = [qSelectorAll];
        } else {
          // shadow dom is not magicjs element
          result = Array.from(($J.$(from).node || from).querySelectorAll(qSelectorAll || '.Sirv')); // result = result.concat(getSirvShadowDOM(qSelectorAll || '.Sirv'));
        }

        return result;
      };

      const getTypeOfView = node => {
        let result = null; // let tmp;

        node = $J.$(node);

        if (node.hasClass('Sirv')) {
          if (node.tagName === 'img' || node.attr('data-bg-src') || node.getCss('background-image') && node.getCss('background-image') !== 'none') {
            result = 'image';
          } else {
            // tmp = node.attr('data-effect');
            // if (tmp) {
            //     result = tmp;
            // } else {
            //     tmp = node.attr('data-src');
            //     if (tmp) {
            //         result = 'spin';
            //     } else {
            //         result = 'viewer';
            //     }
            // }
            // if (node.attr('data-effect') || node.attr('data-src')) {
            result = 'viewer'; // }
          }
        }

        return result;
      };

      const stopLaunching = (options, type) => {
        let result = false;
        let currentType = type;

        if (currentType === 'image') {
          currentType = 'lazyImage';
        }

        if (options.common[currentType] && (options.common[currentType].autostart === false || ['false', 'off'].includes(options.common[currentType].autostart))) {
          result = true;
        }

        if (!result && $J.browser.touchScreen && $J.browser.mobile) {
          if (options.mobile[currentType] && (options.mobile[currentType].autostart === false || ['false', 'off'].includes(options.mobile[currentType].autostart))) {
            result = true;
          }
        }

        return result;
      };

      _Sirv.items.image = [];
      _Sirv.items.viewer = [];

      _Sirv.start = (qSelectorAll, context, typeOfComponent, force) => {
        let lazyInit = false;

        if ($J.typeOf(qSelectorAll) === 'boolean') {
          lazyInit = qSelectorAll;
          qSelectorAll = undefined;
        }

        Array.from(getNodes(qSelectorAll, context)).forEach(node => {
          const magicNode = $J.$(node);

          if (node && magicNode.hasClass('Sirv')) {
            let type = getTypeOfView(magicNode.node);

            if (typeOfComponent && typeOfComponent !== type) {
              type = null;
            }

            _Sirv.options.common = helper.deepExtend({}, $J.W.node['SirvOptions'] || {});
            _Sirv.options.mobile = helper.deepExtend({}, $J.W.node['SirvMobileOptions'] || {});

            if (type) {
              if (['image', 'viewer'].includes(type)) {
                if (!force && stopLaunching(_Sirv.options, type)) {
                  return;
                }

                let effect = findSirvItem(magicNode.node, type);

                if (effect) {
                  effect.startFullInit(Object.assign({}, _Sirv.options), force, lazyInit);
                } else {
                  switch (type) {
                    case 'image':
                      if (isLazyImage) {
                        globalFunctions.rootDOM.attachNode(node);
                        globalFunctions.rootDOM.resetGlobalCSS(node);
                        effect = new LazyImage(magicNode.node, {
                          options: {
                            common: helper.deepExtend({}, _Sirv.options.common.lazyImage || {}),
                            mobile: helper.deepExtend({}, _Sirv.options.mobile.lazyImage || {})
                          }
                        }, force); // if inline autostart option is not false

                        if (effect.isRun) {
                          _Sirv.items.image.push(effect);

                          effect.parentClass = _Sirv.eventManager;
                        } else {
                          globalFunctions.rootDOM.detachNode(node);
                        }
                      } else {
                        console.info('Sirv: Image component wasn\'t found.');
                      }

                      break;

                    case 'viewer':
                      globalFunctions.rootDOM.attachNode(node);
                      globalFunctions.rootDOM.addMainStyle(node);
                      effect = new Slider(magicNode, Object.assign({}, _Sirv.options), force, lazyInit); // if inline autostart option is not false or off

                      if (effect.isRun) {
                        _Sirv.items.viewer.push(effect);

                        effect.parentClass = _Sirv.eventManager;
                      } else {
                        globalFunctions.rootDOM.detachNode(node);
                      }

                      break;
                    // no default
                  }
                }
              }
            }
          }
        });
      };

      _Sirv.stop = (qSelectorAll, context, typeOfComponent) => {
        let types = ['image', 'viewer'];

        if (typeOfComponent) {
          types = [typeOfComponent];
        }

        types.forEach(type => {
          if (qSelectorAll || context) {
            Array.from(getNodes(qSelectorAll, context)).forEach(node => {
              const item = findSirvItem(node, type);

              if (item && item.stop()) {
                _Sirv.items[type].splice(_Sirv.items[type].indexOf(item), 1);
              }
            });
          } else {
            _Sirv.items[type] = _Sirv.items[type].filter(_item => {
              return !_item.stop(true);
            });
          }
        });
      };

      _Sirv.getInstance = (qSelector, type, context) => {
        const inst = findSirvItem(qSelector, type, context);
        return inst ? inst.api : inst;
      };

      _Sirv.eventManager = new EventManager(_Sirv.items);

      _Sirv.addFilterCallback = (callback, first) => {
        if (first) {
          globalFunctions.viewerFilters.unshift(callback);
        } else {
          globalFunctions.viewerFilters.push(callback);
        }
      };

      _Sirv.removeFilterCallback = callback => {
        const newArray = [];
        globalFunctions.viewerFilters.forEach(cb => {
          if (cb !== callback) {
            newArray.push(cb);
          }
        });
        globalFunctions.viewerFilters = newArray;
      };

      _Sirv.removeAllFilterCallback = () => {
        globalFunctions.viewerFilters = [];
      };

      globalFunctions.stop = (node, viewer) => {
        return _Sirv.stop(node, null, viewer);
      };
      /**
       * Observe DOM changes; automatically start newly added .Sirv instances and stop removed ones.
       * @return
       */


      const observeDOM = () => {
        const notChild = node => {
          let result = false;

          if (node.closest) {
            result = !node.closest('div.Sirv');
          } else {
            result = $J.browser.engine === 'trident';
          }

          return result;
        };

        const domChanges = {
          added: [],
          removed: []
        };
        const processDOMChanges = helper.debounce(() => {
          const added = domChanges.added.splice(0);
          const removed = domChanges.removed.splice(0); // Process added nodes

          added.forEach(node => {
            node = $J.$(node);

            if (node.node && node.node.nodeType !== 3 && node.node.nodeType !== 8 && node.node.getElementsByClassName) {
              if (node.hasClass('Sirv')) {
                _Sirv.start(node, null, getTypeOfView(node));
              } else if (globalFunctions.rootDOM.rootContains(node.node) && notChild(node.node)) {
                _Sirv.start(null, node);
              }
            }
          }); // Process removed nodes

          const removedInstances = [];
          removed.forEach(node => {
            node = $J.$(node);

            if (node.node && node.node.nodeType !== 3 && node.node.nodeType !== 8 && node.node.getElementsByClassName) {
              if (node.hasClass('Sirv')) {
                removedInstances.push(node);
              } else {
                [].push.apply(removedInstances, node.node.getElementsByClassName('Sirv'));
              }
            }

            removedInstances.forEach(_node => {
              _node = $J.$(_node);

              if (!$J.D.node.body.contains(_node.node)) {
                try {
                  _Sirv.stop(_node, null, getTypeOfView(_node));
                } catch (ex) {
                  /* empty */
                }
              }
            });
          });
        }, 250); // eslint-disable-next-line

        const collectDOMChanges = (mutations, observer) => {
          for (let i = 0, l = mutations.length; i < l; i++) {
            if (mutations[i].type === 'childList') {
              [].push.apply(domChanges.added, mutations[i].addedNodes);
              [].push.apply(domChanges.removed, mutations[i].removedNodes);
            }
          }

          processDOMChanges();
        };

        if ($J.W.node.MutationObserver) {
          new MutationObserver(collectDOMChanges).observe($J.D.node.body, {
            childList: true,
            subtree: true,
            attributes: false
          });
        }
      };

      globalFunctions.rootDOM.resetGlobalCSS();
      globalFunctions.iconsHash.make();

      if ($J.D.node.readyState === 'loading') {
        _Sirv.start(true);
      }

      $J.D.addEvent('domready', () => {
        _Sirv.start();

        observeDOM(globalFunctions);
      });
    });

    const sayDeprecated = apiName => {
      console.log('sirv.js: The method Sirv' + apiName + '.refresh() is deprecated. \r\n         Use Sirv' + apiName + '.stop() and Sirv' + apiName + '.start() instead.');
    };

    w.Sirv.version = 'develop-1646918247508';
    w.Sirv.build = '[[build_datetime]]';
    w.Sirv.options = {};
    w.Sirv.lazyimage = {
      start: (qSelectorAll, context) => {
        _Sirv.start(qSelectorAll, context, 'image', true);
      },
      stop: (qSelectorAll, context) => {
        _Sirv.stop(qSelectorAll, context, 'image');
      },
      getInstance: (qSelector, context) => {
        let result = null;

        if (_Sirv.getInstance) {
          result = _Sirv.getInstance(qSelector, 'image', context);
        }

        return result;
      },
      refresh: () => {
        sayDeprecated('.image');
      },
      on: (nameOfEvent, callback) => w.Sirv.on(nameOfEvent, callback),
      off: (nameOfEvent, callback) => w.Sirv.off(nameOfEvent, callback)
    };
    w.Sirv.viewer = {
      start: (qSelectorAll, context) => {
        _Sirv.start(qSelectorAll, context, 'viewer', true);
      },
      stop: (qSelectorAll, context) => {
        _Sirv.stop(qSelectorAll, context, 'viewer');
      },
      getInstance: (qSelector, context) => {
        let result = null;

        if (_Sirv.getInstance) {
          result = _Sirv.getInstance(qSelector, 'viewer', context);
        }

        return result;
      },
      refresh: () => {
        sayDeprecated('.viewer');
      },
      on: (nameOfEvent, callback) => {
        return w.Sirv.on(nameOfEvent, callback);
      },
      off: (nameOfEvent, callback) => {
        return w.Sirv.off(nameOfEvent, callback);
      },
      filters: {
        add: (callback, first) => {
          _Sirv.addFilterCallback(callback, first);
        },
        remove: callback => {
          _Sirv.removeFilterCallback(callback);
        },
        removeAll: () => {
          _Sirv.removeAllFilterCallback();
        }
      }
    };

    w.Sirv.start = (qSelectorAll, context) => {
      _Sirv.start(qSelectorAll, context, null, true);
    };

    w.Sirv.stop = (qSelectorAll, context) => {
      _Sirv.stop(qSelectorAll, context);
    };

    w.Sirv.getInstance = (qSelector, type, context) => {
      let instance = null;

      if (_Sirv.getInstance) {
        const m = type === 'lazyimage' ? w.Sirv.lazyimage : w.Sirv.viewer;
        instance = m.getInstance(qSelector, context);
      }

      return instance;
    };

    w.Sirv.refresh = () => {
      sayDeprecated('');
    };

    w.Sirv.on = (nameOfEvent, callback) => {
      return _Sirv.eventManager.addEvent(nameOfEvent, callback);
    };

    w.Sirv.off = (nameOfEvent, callback) => {
      return _Sirv.eventManager.removeEvent(nameOfEvent, callback);
    };

    w.Sirv.whenReady = callback => callback();

    w.Sirv.whenLoaded = callback => callback();
  })();
}
//# sourceMappingURL=sirv.js.map
